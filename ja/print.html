<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>bytekin ドキュメント (日本語)</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">bytekin ドキュメント (日本語)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bytekinの紹介"><a class="header" href="#bytekinの紹介">bytekinの紹介</a></h1>
<h2 id="bytekinとは"><a class="header" href="#bytekinとは">bytekinとは?</a></h2>
<p><strong>bytekin</strong>は、<a href="https://asm.ow2.io/">ASM</a>上に構築された軽量で使いやすいJavaバイトコード変換フレームワークです。開発者がバイトコードレベルでJavaクラスをプログラム的に変更できるようにし、強力なコードインジェクション、メソッドインターセプション、変換機能を提供します。</p>
<p>bytekinは以下のように設計されています:</p>
<ul>
<li><strong>シンプル</strong>: 直感的なアノテーションベースAPI</li>
<li><strong>軽量</strong>: 最小限の依存関係(ASMのみ)</li>
<li><strong>柔軟</strong>: 複数の変換戦略</li>
<li><strong>強力</strong>: 複雑なバイトコード操作のサポート</li>
</ul>
<h2 id="主な機能"><a class="header" href="#主な機能">主な機能</a></h2>
<ul>
<li><strong>インジェクション</strong>: メソッドの特定の位置(先頭、return文など)にカスタムコードを挿入</li>
<li><strong>インボケーション</strong>: メソッド呼び出しをインターセプトして動作を変更</li>
<li><strong>リダイレクト</strong>: メソッド呼び出しのターゲットを変更</li>
<li><strong>定数の変更</strong>: バイトコード内の定数値を変更</li>
<li><strong>変数の変更</strong>: ローカル変数を操作</li>
<li><strong>マッピングサポート</strong>: クラスとメソッド名を自動的に変換</li>
<li><strong>ビルダーパターン</strong>: トランスフォーマー構築のための流暢なAPI</li>
</ul>
<h2 id="ユースケース"><a class="header" href="#ユースケース">ユースケース</a></h2>
<p>bytekinは以下のようなシナリオに最適です:</p>
<ol>
<li><strong>ログ記録や監視の追加</strong> - ソースコードを変更せずに既存のクラスに追加</li>
<li><strong>AOP(アスペクト指向プログラミング)の実装</strong> - フレームワークのオーバーヘッドなし</li>
<li><strong>セキュリティチェックの追加</strong> - 実行時に追加</li>
<li><strong>サードパーティライブラリの動作を変更</strong> - バイトコードレベルで</li>
<li><strong>モックやスタブの実装</strong> - テスト用に</li>
<li><strong>コードの計装</strong> - プロファイリングや分析のため</li>
<li><strong>横断的関心事の適用</strong> - 複数のクラスに</li>
</ol>
<h2 id="なぜbytekinなのか"><a class="header" href="#なぜbytekinなのか">なぜbytekinなのか?</a></h2>
<p>フル機能フレームワークとは異なり、bytekinは:</p>
<ul>
<li><strong>最小限</strong>: ASMのみに依存し、重い依存関係なし</li>
<li><strong>直接的</strong>: リフレクションのオーバーヘッドなしでバイトコードを直接操作</li>
<li><strong>柔軟</strong>: アノテーションベースとプログラマティックの両方のアプローチをサポート</li>
<li><strong>高速</strong>: JVMロード時の効率的なバイトコード操作</li>
</ul>
<h2 id="プロジェクト構造"><a class="header" href="#プロジェクト構造">プロジェクト構造</a></h2>
<p>bytekinプロジェクトはいくつかのモジュールに分かれています:</p>
<ul>
<li><strong>変換エンジン</strong>: コアバイトコード操作ロジック</li>
<li><strong>インジェクションシステム</strong>: メソッドインジェクション機能</li>
<li><strong>マッピングシステム</strong>: クラスとメソッド名マッピングのサポート</li>
<li><strong>ユーティリティ</strong>: バイトコード操作のためのヘルパークラス</li>
</ul>
<h2 id="次のステップ"><a class="header" href="#次のステップ">次のステップ</a></h2>
<ul>
<li><a href="./getting-started.html">導入</a>で最初の変換を開始</li>
<li>バイトコード操作の背後にある<a href="./core-concepts.html">コアコンセプト</a>を学習</li>
<li>bytekinで利用可能な<a href="./features.html">すべての機能</a>を探索</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytekinを始める"><a class="header" href="#bytekinを始める">bytekinを始める</a></h1>
<p>このセクションでは、bytekinのセットアップと最初のバイトコード変換の作成方法を説明します。</p>
<h2 id="前提条件"><a class="header" href="#前提条件">前提条件</a></h2>
<ul>
<li>Java 8以上</li>
<li>Javaの基本的な理解</li>
<li>MavenまたはGradle(依存関係管理のため)</li>
</ul>
<h2 id="インストール"><a class="header" href="#インストール">インストール</a></h2>
<h3 id="maven"><a class="header" href="#maven">Maven</a></h3>
<p><code>pom.xml</code>に以下を追加してください:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.github.brqnko.bytekin&lt;/groupId&gt;
    &lt;artifactId&gt;bytekin&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="gradle"><a class="header" href="#gradle">Gradle</a></h3>
<p><code>build.gradle</code>に以下を追加してください:</p>
<pre><code class="language-gradle">dependencies {
    implementation 'io.github.brqnko.bytekin:bytekin:1.0'
}
</code></pre>
<h2 id="最初の変換"><a class="header" href="#最初の変換">最初の変換</a></h2>
<h3 id="ステップ1-フッククラスの作成"><a class="header" href="#ステップ1-フッククラスの作成">ステップ1: フッククラスの作成</a></h3>
<p>ターゲットクラスをどのように変換したいかを定義する<code>@ModifyClass</code>アノテーションを持つクラスを作成します:</p>
<pre><code class="language-java">import io.github.brqnko.bytekin.injection.ModifyClass;
import io.github.brqnko.bytekin.injection.Inject;
import io.github.brqnko.bytekin.injection.At;
import io.github.brqnko.bytekin.data.CallbackInfo;

@ModifyClass("com.example.Calculator")
public class CalculatorHooks {

    @Inject(methodName = "add", methodDesc = "(II)I", at = At.HEAD)
    public static CallbackInfo onAddHead(int a, int b) {
        System.out.println("Adding " + a + " + " + b);
        return CallbackInfo.empty();
    }
}
</code></pre>
<h3 id="ステップ2-トランスフォーマーの作成"><a class="header" href="#ステップ2-トランスフォーマーの作成">ステップ2: トランスフォーマーの作成</a></h3>
<p>フッククラスで<code>BytekinTransformer</code>をインスタンス化します:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(CalculatorHooks.class)
    .build();
</code></pre>
<h3 id="ステップ3-クラスの変換"><a class="header" href="#ステップ3-クラスの変換">ステップ3: クラスの変換</a></h3>
<p>ターゲットクラスのバイトコードに変換を適用します:</p>
<pre><code class="language-java">byte[] originalBytecode = loadClassBytecode("com.example.Calculator");
byte[] transformedBytecode = transformer.transform("com.example.Calculator", originalBytecode);
</code></pre>
<h3 id="ステップ4-変換されたクラスの使用"><a class="header" href="#ステップ4-変換されたクラスの使用">ステップ4: 変換されたクラスの使用</a></h3>
<p>カスタム<code>ClassLoader</code>を使用して、変換されたバイトコードをJVMにロードします:</p>
<pre><code class="language-java">ClassLoader loader = new ByteArrayClassLoader(transformedBytecode);
Class&lt;?&gt; transformedClass = loader.loadClass("com.example.Calculator");
</code></pre>
<h2 id="結果"><a class="header" href="#結果">結果</a></h2>
<p>変換されたクラスには、<code>add</code>メソッドにロギングが追加されます:</p>
<pre><code class="language-java">// 元のコード
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}

// 変換後のコード
public class Calculator {
    public int add(int a, int b) {
        System.out.println("Adding " + a + " + " + b);  // インジェクション済み!
        return a + b;
    }
}
</code></pre>
<h2 id="次のステップ-1"><a class="header" href="#次のステップ-1">次のステップ</a></h2>
<ul>
<li><a href="./core-concepts.html">コアコンセプト</a>について学ぶ</li>
<li>すべての<a href="./features.html">機能</a>を探る</li>
<li><a href="./examples.html">例</a>をチェックする</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="インストールガイド"><a class="header" href="#インストールガイド">インストールガイド</a></h1>
<h2 id="mavenを使用する場合"><a class="header" href="#mavenを使用する場合">Mavenを使用する場合</a></h2>
<h3 id="1-依存関係を追加"><a class="header" href="#1-依存関係を追加">1. 依存関係を追加</a></h3>
<p><code>pom.xml</code>ファイルを編集し、以下の依存関係を追加します:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.github.brqnko.bytekin&lt;/groupId&gt;
    &lt;artifactId&gt;bytekin&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="2-プロジェクトを更新"><a class="header" href="#2-プロジェクトを更新">2. プロジェクトを更新</a></h3>
<p>Mavenを実行して依存関係をダウンロードします:</p>
<pre><code class="language-bash">mvn clean install
</code></pre>
<h2 id="gradleを使用する場合"><a class="header" href="#gradleを使用する場合">Gradleを使用する場合</a></h2>
<h3 id="1-依存関係を追加-1"><a class="header" href="#1-依存関係を追加-1">1. 依存関係を追加</a></h3>
<p><code>build.gradle</code>ファイルを編集し、以下を追加します:</p>
<pre><code class="language-gradle">dependencies {
    implementation 'io.github.brqnko.bytekin:bytekin:1.0'
}
</code></pre>
<h3 id="2-プロジェクトを同期"><a class="header" href="#2-プロジェクトを同期">2. プロジェクトを同期</a></h3>
<p>Android StudioまたはIntelliJ IDEAの場合、Gradleを手動で同期できます。コマンドラインの場合:</p>
<pre><code class="language-bash">./gradlew build
</code></pre>
<h2 id="依存関係の要件"><a class="header" href="#依存関係の要件">依存関係の要件</a></h2>
<p>bytekinは最小限の依存関係を持っています:</p>
<div class="table-wrapper"><table><thead><tr><th>依存関係</th><th>バージョン</th><th>目的</th></tr></thead><tbody>
<tr><td>ASM</td><td>9.7.1+</td><td>バイトコード操作ライブラリ</td></tr>
<tr><td>Java</td><td>8+</td><td>ランタイム環境</td></tr>
</tbody></table>
</div>
<h2 id="検証"><a class="header" href="#検証">検証</a></h2>
<p>インストール後、簡単なテストを実行してbytekinが正しくセットアップされていることを確認します:</p>
<pre><code class="language-java">import io.github.brqnko.bytekin.transformer.BytekinTransformer;

public class BytekinVer {
    public static void main(String[] args) {
        BytekinTransformer transformer = new BytekinTransformer.Builder()
            .build();
        System.out.println("bytekinは使用する準備ができています!");
    }
}
</code></pre>
<h2 id="インストールのトラブルシューティング"><a class="header" href="#インストールのトラブルシューティング">インストールのトラブルシューティング</a></h2>
<h3 id="maven-依存関係が見つからない"><a class="header" href="#maven-依存関係が見つからない">Maven: 依存関係が見つからない</a></h3>
<ul>
<li>インターネットに接続されていることを確認</li>
<li><code>mvn clean</code>を実行してから<code>mvn install</code>を再度実行</li>
<li>リポジトリにアクセスできるか確認</li>
</ul>
<h3 id="gradle-ビルドが失敗する"><a class="header" href="#gradle-ビルドが失敗する">Gradle: ビルドが失敗する</a></h3>
<ul>
<li>最初に<code>./gradlew clean</code>を実行</li>
<li>Gradleラッパーのバージョンを確認</li>
<li>Javaバージョンの互換性を確認</li>
</ul>
<h2 id="次のステップ-2"><a class="header" href="#次のステップ-2">次のステップ</a></h2>
<ul>
<li><a href="./first-transformation.html">最初の変換</a></li>
<li><a href="./core-concepts.html">コアコンセプト</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最初の変換-1"><a class="header" href="#最初の変換-1">最初の変換</a></h1>
<p>このガイドでは、シンプルなバイトコード変換を実演する完全な例を作成します。</p>
<h2 id="例-計算機にロギングを追加する"><a class="header" href="#例-計算機にロギングを追加する">例: 計算機にロギングを追加する</a></h2>
<h3 id="ステップ1-ターゲットクラスの作成"><a class="header" href="#ステップ1-ターゲットクラスの作成">ステップ1: ターゲットクラスの作成</a></h3>
<p>まず、変換する簡単な計算機クラスを作成しましょう:</p>
<pre><code class="language-java">package com.example;

public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public int subtract(int a, int b) {
        return a - b;
    }

    public int multiply(int a, int b) {
        return a * b;
    }
}
</code></pre>
<h3 id="ステップ2-フックメソッドの作成"><a class="header" href="#ステップ2-フックメソッドの作成">ステップ2: フックメソッドの作成</a></h3>
<p>インジェクションしたい内容を定義する<code>@ModifyClass</code>アノテーション付きのクラスを作成します:</p>
<pre><code class="language-java">package com.example;

import io.github.brqnko.bytekin.injection.ModifyClass;
import io.github.brqnko.bytekin.injection.Inject;
import io.github.brqnko.bytekin.injection.At;
import io.github.brqnko.bytekin.data.CallbackInfo;

@ModifyClass("com.example.Calculator")
public class CalculatorHooks {

    @Inject(
        methodName = "add",
        methodDesc = "(II)I",
        at = At.HEAD
    )
    public static CallbackInfo logAdd(int a, int b) {
        System.out.println("Computing: " + a + " + " + b);
        return CallbackInfo.empty();
    }

    @Inject(
        methodName = "multiply",
        methodDesc = "(II)I",
        at = At.HEAD
    )
    public static CallbackInfo logMultiply(int a, int b) {
        System.out.println("Computing: " + a + " * " + b);
        return CallbackInfo.empty();
    }
}
</code></pre>
<h3 id="ステップ3-トランスフォーマーの構築"><a class="header" href="#ステップ3-トランスフォーマーの構築">ステップ3: トランスフォーマーの構築</a></h3>
<pre><code class="language-java">package com.example;

import io.github.brqnko.bytekin.transformer.BytekinTransformer;

public class TransformerSetup {
    public static BytekinTransformer createTransformer() {
        return new BytekinTransformer.Builder(CalculatorHooks.class)
            .build();
    }
}
</code></pre>
<h3 id="ステップ4-変換の適用"><a class="header" href="#ステップ4-変換の適用">ステップ4: 変換の適用</a></h3>
<pre><code class="language-java">package com.example;

import io.github.brqnko.bytekin.transformer.BytekinTransformer;

public class Main {
    public static void main(String[] args) {
        // 元のバイトコードを取得
        byte[] originalBytecode = getClassBytecode("com.example.Calculator");

        // トランスフォーマーを作成
        BytekinTransformer transformer = TransformerSetup.createTransformer();

        // 変換を適用
        byte[] transformedBytecode = transformer.transform(
            "com.example.Calculator",
            originalBytecode
        );

        // 変換されたクラスをロード
        Calculator calc = loadTransformedClass(transformedBytecode);

        // 変換されたクラスを使用
        int result = calc.add(5, 3);
        // 出力: "Computing: 5 + 3" その後 "8"

        result = calc.multiply(4, 7);
        // 出力: "Computing: 4 * 7" その後 "28"
    }

    // クラスバイトコードを取得するヘルパー(疑似コード)
    static byte[] getClassBytecode(String className) {
        // 実装はクラスローダーのセットアップに依存します
        return new byte[]{};
    }

    // 変換されたクラスをロードするヘルパー(疑似コード)
    static Calculator loadTransformedClass(byte[] bytecode) {
        // カスタムClassLoaderを使用してロード
        return null;
    }
}
</code></pre>
<h2 id="何が起こったのか"><a class="header" href="#何が起こったのか">何が起こったのか?</a></h2>
<p>変換プロセス:</p>
<ol>
<li><strong>スキャン</strong>: <code>@Inject</code>アノテーションを持つメソッドを<code>CalculatorHooks</code>でスキャンしました</li>
<li><strong>発見</strong>: <code>com.example.Calculator</code>をターゲットとするインジェクションを見つけました</li>
<li><strong>変更</strong>: フックメソッドを呼び出すようにCalculatorクラスのバイトコードを変更しました</li>
<li><strong>挿入</strong>: 指定されたメソッドの先頭にロギングコードを挿入しました</li>
</ol>
<h2 id="変換前と変換後"><a class="header" href="#変換前と変換後">変換前と変換後</a></h2>
<p><strong>変換前:</strong></p>
<pre><code class="language-java">public int add(int a, int b) {
    return a + b;
}
</code></pre>
<p><strong>変換後:</strong></p>
<pre><code class="language-java">public int add(int a, int b) {
    // インジェクションされたコード
    com.example.CalculatorHooks.logAdd(a, b);
    // 元のコード
    return a + b;
}
</code></pre>
<h2 id="次のステップ-3"><a class="header" href="#次のステップ-3">次のステップ</a></h2>
<ul>
<li><a href="./inject.html#at-enum">At列挙型</a>で他のインジェクションポイントを探る</li>
<li><a href="./invoke.html">インボケーション変換</a>について学ぶ</li>
<li>より多くの<a href="./examples.html">例</a>をチェックする</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="コアコンセプト"><a class="header" href="#コアコンセプト">コアコンセプト</a></h1>
<p>このセクションでは、bytekinとバイトコード変換の背後にある基本的なコンセプトについて説明します。</p>
<h2 id="バイトコードとは"><a class="header" href="#バイトコードとは">バイトコードとは?</a></h2>
<p>Javaソースコードは<strong>バイトコード</strong>にコンパイルされます - これはJava仮想マシン(JVM)上で実行されるプラットフォーム非依存の中間表現です。ソースコードとは異なり、バイトコードは人間が読める形式ではありませんが、標準化されておりプログラム的に操作できます。</p>
<h3 id="バイトコードの構造"><a class="header" href="#バイトコードの構造">バイトコードの構造</a></h3>
<p>Javaバイトコードは以下で構成されています:</p>
<ul>
<li><strong>定数プール</strong>: 文字列リテラル、メソッド参照、フィールド参照</li>
<li><strong>メソッド</strong>: 命令シーケンスを持つコンパイル済みメソッド</li>
<li><strong>フィールド</strong>: クラスプロパティ</li>
<li><strong>属性</strong>: 行番号、ローカル変数、例外などのメタデータ</li>
</ul>
<h2 id="バイトコード変換とは"><a class="header" href="#バイトコード変換とは">バイトコード変換とは?</a></h2>
<p><strong>バイトコード変換</strong>は、コンパイル後でクラスロード前にバイトコードを読み取り、分析し、変更するプロセスです。これにより、ソースコードを変更せずにクラスの動作を変更できます。</p>
<h3 id="ユースケース-1"><a class="header" href="#ユースケース-1">ユースケース</a></h3>
<ol>
<li><strong>ランタイム監視</strong>: ソースを変更せずにログ記録を追加</li>
<li><strong>横断的関心事</strong>: 複数のクラスに動作を適用</li>
<li><strong>テスト</strong>: メソッドをモックまたはスタブ化</li>
<li><strong>セキュリティ</strong>: セキュリティチェックをインジェクト</li>
<li><strong>パフォーマンス</strong>: プロファイリング計装を追加</li>
</ol>
<h2 id="bytekinの位置づけ"><a class="header" href="#bytekinの位置づけ">bytekinの位置づけ</a></h2>
<p>bytekinは以下によってバイトコード変換を簡素化します:</p>
<ol>
<li><strong>ASMの複雑さを抽象化</strong>: 生のASM上にクリーンなAPIを提供</li>
<li><strong>アノテーションベース構成</strong>: Javaアノテーションを使用して変換を定義</li>
<li><strong>複数の戦略</strong>: インジェクション、メソッドインターセプション、リダイレクトのサポート</li>
<li><strong>マッピングサポート</strong>: 難読化または名前変更されたクラスを処理</li>
<li><strong>柔軟なビルダーパターン</strong>: プログラム的に変換を構成</li>
</ol>
<h2 id="変換パイプライン"><a class="header" href="#変換パイプライン">変換パイプライン</a></h2>
<pre><code>ターゲットクラスバイトコード
        ↓
   BytekinTransformer
        ↓
  フッククラスをスキャン
        ↓
  変換を適用
        ↓
   変更されたバイトコード
</code></pre>
<h2 id="主要コンポーネント"><a class="header" href="#主要コンポーネント">主要コンポーネント</a></h2>
<h3 id="フッククラス"><a class="header" href="#フッククラス">フッククラス</a></h3>
<p>ターゲットクラスの変換方法を定義する<code>@ModifyClass</code>でアノテートされたクラス。変換アノテーションを持つメソッドを含みます。</p>
<h3 id="トランスフォーマー"><a class="header" href="#トランスフォーマー">トランスフォーマー</a></h3>
<p>バイトコードに変換を適用するオブジェクト。bytekinは変換プロセス全体を処理する<code>BytekinTransformer</code>を提供します。</p>
<h3 id="アノテーション"><a class="header" href="#アノテーション">アノテーション</a></h3>
<p>変換動作を定義するJavaコードの特別なマーカー:</p>
<ul>
<li><code>@ModifyClass</code>: ターゲットクラスをマーク</li>
<li><code>@Inject</code>: 特定の位置にコードを挿入</li>
<li><code>@Invoke</code>: メソッド呼び出しをインターセプト</li>
<li>その他...</li>
</ul>
<h3 id="callbackinfo"><a class="header" href="#callbackinfo">CallbackInfo</a></h3>
<p>変換動作を制御するデータ構造:</p>
<ul>
<li><code>cancelled</code>: 元のコードをスキップするかどうか</li>
<li><code>returnValue</code>: カスタム戻り値</li>
<li><code>modifyArgs</code>: 変更されたメソッド引数</li>
</ul>
<h2 id="重要なコンセプト"><a class="header" href="#重要なコンセプト">重要なコンセプト</a></h2>
<h3 id="メソッドディスクリプタ"><a class="header" href="#メソッドディスクリプタ">メソッドディスクリプタ</a></h3>
<p>メソッドディスクリプタはJVM形式でメソッドシグネチャを記述します:</p>
<pre><code>(パラメータ型)戻り値型
</code></pre>
<p>例:</p>
<ul>
<li><code>(II)I</code> - 2つのintを取り、intを返す</li>
<li><code>(Ljava/lang/String;)V</code> - Stringを取り、voidを返す</li>
<li><code>()Ljava/lang/String;</code> - 何も取らず、Stringを返す</li>
</ul>
<h3 id="クラス名"><a class="header" href="#クラス名">クラス名</a></h3>
<p>bytekinでは、クラス名はドット表記を使用します:</p>
<ul>
<li>Java表記: <code>java.lang.String</code></li>
<li>内部表記: <code>java/lang/String</code></li>
<li>bytekinはJava表記を使用</li>
</ul>
<h2 id="次のステップ-4"><a class="header" href="#次のステップ-4">次のステップ</a></h2>
<ul>
<li><a href="./how-it-works.html">bytekinの仕組み</a>について学習</li>
<li><a href="./features.html">すべての機能</a>を探索</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="バイトコードの基礎"><a class="header" href="#バイトコードの基礎">バイトコードの基礎</a></h1>
<h2 id="javaバイトコードとは"><a class="header" href="#javaバイトコードとは">Javaバイトコードとは?</a></h2>
<p>Javaソースコード（<code>.java</code>ファイル）はJavaバイトコード（<code>.class</code>ファイルに含まれる）にコンパイルされます。このバイトコードはJava仮想マシン（JVM）が理解するプラットフォーム非依存の中間言語です。</p>
<h3 id="ソースコードとバイトコード"><a class="header" href="#ソースコードとバイトコード">ソースコードとバイトコード</a></h3>
<p><strong>Javaソースコード:</strong></p>
<pre><code class="language-java">public class Example {
    public void greet(String name) {
        System.out.println("Hello, " + name);
    }
}
</code></pre>
<p><strong>コンパイルされたバイトコード（概念的）:</strong></p>
<pre><code>aload_0
aload_1
invokedynamic &lt;concat&gt;
getstatic System.out
swap
invokevirtual println
return
</code></pre>
<p>バイトコードバージョンはより冗長で、オペレーティングシステムに依存しません。</p>
<h2 id="バイトコードが重要な理由"><a class="header" href="#バイトコードが重要な理由">バイトコードが重要な理由</a></h2>
<ol>
<li><strong>プラットフォーム非依存</strong>: JVMがあればどのシステムでも動作</li>
<li><strong>実行時の柔軟性</strong>: ロード前にバイトコードを変換可能</li>
<li><strong>セキュリティ</strong>: JVMはバイトコードの正しさを検証可能</li>
<li><strong>最適化</strong>: JVMはネイティブコードにJITコンパイル可能</li>
<li><strong>イントロスペクション</strong>: ツールはソースコードなしでバイトコードを分析可能</li>
</ol>
<h2 id="バイトコードの読み方"><a class="header" href="#バイトコードの読み方">バイトコードの読み方</a></h2>
<h3 id="検査ツール"><a class="header" href="#検査ツール">検査ツール</a></h3>
<ul>
<li><strong>javap</strong>: 組み込みのJava逆アセンブラ</li>
<li><strong>Bytecode Viewer</strong>: バイトコード検査用のGUIツール</li>
<li><strong>ASM Tree View</strong>: IDE可視化プラグイン</li>
</ul>
<h3 id="例-javapの使用"><a class="header" href="#例-javapの使用">例: javapの使用</a></h3>
<pre><code class="language-bash">javap -c Example.class
</code></pre>
<p>出力は各メソッドのバイトコード命令を表示します。</p>
<h2 id="一般的なバイトコード命令"><a class="header" href="#一般的なバイトコード命令">一般的なバイトコード命令</a></h2>
<p>頻繁に遭遇するバイトコード命令:</p>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>目的</th></tr></thead><tbody>
<tr><td><code>aload</code></td><td>オブジェクト参照をロード</td></tr>
<tr><td><code>iload</code></td><td>整数をロード</td></tr>
<tr><td><code>invoke*</code></td><td>メソッドを呼び出す（静的、仮想など）</td></tr>
<tr><td><code>return</code></td><td>メソッドから戻る</td></tr>
<tr><td><code>getstatic</code></td><td>静的フィールドを読む</td></tr>
<tr><td><code>putstatic</code></td><td>静的フィールドに書き込む</td></tr>
<tr><td><code>new</code></td><td>新しいオブジェクトを作成</td></tr>
</tbody></table>
</div>
<h2 id="メソッドディスクリプタシグネチャ"><a class="header" href="#メソッドディスクリプタシグネチャ">メソッドディスクリプタ（シグネチャ）</a></h2>
<p>バイトコードはメソッドシグネチャに特別な記法を使用します:</p>
<pre><code>(パラメータ型)戻り値型
</code></pre>
<h3 id="プリミティブ型"><a class="header" href="#プリミティブ型">プリミティブ型</a></h3>
<ul>
<li><code>Z</code> - boolean</li>
<li><code>B</code> - byte</li>
<li><code>C</code> - char</li>
<li><code>S</code> - short</li>
<li><code>I</code> - int</li>
<li><code>J</code> - long</li>
<li><code>F</code> - float</li>
<li><code>D</code> - double</li>
<li><code>V</code> - void</li>
</ul>
<h3 id="オブジェクト型"><a class="header" href="#オブジェクト型">オブジェクト型</a></h3>
<ul>
<li><code>Ljava/lang/String;</code> - Stringクラス</li>
<li><code>L...classname...;</code> - 任意のクラス</li>
</ul>
<h3 id="配列型"><a class="header" href="#配列型">配列型</a></h3>
<ul>
<li><code>[I</code> - int配列</li>
<li><code>[Ljava/lang/String;</code> - String配列</li>
</ul>
<h3 id="例"><a class="header" href="#例">例</a></h3>
<ul>
<li><code>(II)I</code> - 2つの整数を加算: <code>int method(int a, int b) { return ...; }</code></li>
<li><code>(Ljava/lang/String;)V</code> - 文字列を受け取り、何も返さない: <code>void method(String s) { ... }</code></li>
<li><code>()Ljava/lang/String;</code> - パラメータなし、文字列を返す: <code>String method() { ... }</code></li>
<li><code>([Ljava/lang/String;)V</code> - 文字列配列を受け取る: <code>void method(String[] args) { ... }</code></li>
</ul>
<h2 id="クラス参照"><a class="header" href="#クラス参照">クラス参照</a></h2>
<p>クラスは完全修飾名を<code>/</code>区切りで参照されます:</p>
<ul>
<li><code>java/lang/String</code></li>
<li><code>java/util/ArrayList</code></li>
<li><code>com/mycompany/MyClass</code></li>
</ul>
<p>bytekinでは、通常、ドット付きの標準Java記法を使用します:</p>
<ul>
<li><code>java.lang.String</code></li>
<li><code>java.util.ArrayList</code></li>
<li><code>com.mycompany.MyClass</code></li>
</ul>
<h2 id="クラスファイル形式"><a class="header" href="#クラスファイル形式">クラスファイル形式</a></h2>
<p>コンパイルされた<code>.class</code>ファイルには以下が含まれます:</p>
<ol>
<li><strong>マジックナンバー</strong>: クラスファイルとして識別（<code>0xCAFEBABE</code>）</li>
<li><strong>バージョン</strong>: Javaバージョン情報</li>
<li><strong>定数プール</strong>: 文字列、メソッド名、フィールド名、型情報</li>
<li><strong>アクセスフラグ</strong>: public、final、abstractなど</li>
<li><strong>このクラス</strong>: クラス名</li>
<li><strong>スーパークラス</strong>: 親クラス</li>
<li><strong>インターフェース</strong>: 実装されたインターフェース</li>
<li><strong>フィールド</strong>: クラスメンバー変数</li>
<li><strong>メソッド</strong>: バイトコード付きメソッド</li>
<li><strong>属性</strong>: 追加のメタデータ</li>
</ol>
<h2 id="重要な注意事項"><a class="header" href="#重要な注意事項">重要な注意事項</a></h2>
<ul>
<li>バイトコードは<strong>人間が読めるものではない</strong>が、<strong>体系的で分析可能</strong></li>
<li><strong>すべてのJavaソースの構造</strong>がバイトコードにマッピングされる</li>
<li><strong>バイトコードは検証可能</strong> - JVMは実行前に正しさをチェック</li>
<li><strong>バイトコードは操作可能</strong> - ソースコードなしでプログラム的に操作できる</li>
</ul>
<h2 id="次のステップ-5"><a class="header" href="#次のステップ-5">次のステップ</a></h2>
<ul>
<li><a href="./how-it-works.html">bytekinの動作</a>を学ぶ</li>
<li><a href="./core-concepts.html">コア概念</a>を理解する</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytekinの動作"><a class="header" href="#bytekinの動作">bytekinの動作</a></h1>
<p>このドキュメントでは、bytekinの内部メカニズムとバイトコードをどのように変換するかを説明します。</p>
<h2 id="変換プロセス"><a class="header" href="#変換プロセス">変換プロセス</a></h2>
<h3 id="ステップ1-初期化"><a class="header" href="#ステップ1-初期化">ステップ1: 初期化</a></h3>
<pre><code>フッククラスを定義
        ↓
BytekinTransformer.Builderを作成
        ↓
フッククラスをBuilderに渡す
</code></pre>
<p>例:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(
    CalculatorHooks.class,
    StringHooks.class
).build();
</code></pre>
<h3 id="ステップ2-分析"><a class="header" href="#ステップ2-分析">ステップ2: 分析</a></h3>
<p><code>build()</code>が呼び出されると、bytekinは:</p>
<ol>
<li>フッククラスのアノテーションをスキャン</li>
<li>変換ルールを抽出</li>
<li>メソッドシグネチャを検証</li>
<li>変換戦略を準備</li>
<li>BytekinClassTransformerインスタンスを作成</li>
</ol>
<pre><code>Builder.build()
    ↓
@ModifyClassアノテーションをスキャン
    ↓
@Inject、@Invokeなどを抽出
    ↓
トランスフォーマーマップを作成
    ↓
BytekinTransformerを返す
</code></pre>
<h3 id="ステップ3-変換"><a class="header" href="#ステップ3-変換">ステップ3: 変換</a></h3>
<p><code>transform()</code>が呼び出されると:</p>
<pre><code class="language-java">byte[] transformed = transformer.transform("com.example.Calculator", bytecode);
</code></pre>
<p>bytekinは:</p>
<ol>
<li>ターゲットクラスを検索</li>
<li>一致するトランスフォーマーを見つける</li>
<li>ASMを使用してバイトコードを解析</li>
<li>登録されたすべての変換を適用</li>
<li>変更されたバイトコードを返す</li>
</ol>
<pre><code>ターゲットバイトコード
    ↓
ASM ClassReader
    ↓
BytekinClassVisitor
    ↓
インジェクションを適用
    ↓
インボケーションを適用
    ↓
リダイレクトを適用
    ↓
定数の変更を適用
    ↓
変数の変更を適用
    ↓
ASM ClassWriter
    ↓
変更されたバイトコード
</code></pre>
<h2 id="アーキテクチャ概要"><a class="header" href="#アーキテクチャ概要">アーキテクチャ概要</a></h2>
<h3 id="コアコンポーネント"><a class="header" href="#コアコンポーネント">コアコンポーネント</a></h3>
<pre><code>┌─────────────────────────────────────┐
│   BytekinTransformer (メインAPI)    │
└──────────────┬──────────────────────┘
               │
        ┌──────┴──────┐
        ↓             ↓
    Builder      transform()
        │             │
        └──────┬──────┘
               ↓
   ┌───────────────────────────┐
   │  BytekinClassTransformer  │
   └───────────┬───────────────┘
               ↓
   ┌───────────────────────────┐
   │   BytekinClassVisitor     │
   │  (ASM ClassVisitor)       │
   └───────────┬───────────────┘
               ↓
   ┌───────────────────────────┐
   │  BytekinMethodVisitor     │
   │  (ASM MethodVisitor)      │
   └───────────────────────────┘
</code></pre>
<h3 id="ビジターパターン"><a class="header" href="#ビジターパターン">ビジターパターン</a></h3>
<p>bytekinは<strong>ビジターパターン</strong>（ASMから）を使用します:</p>
<pre><code>┌─ ClassVisitor
│   └─ Method Visitor
│       └─ Code Visitor
│           └─ Instruction Handlers
</code></pre>
<p>ASMがバイトコードを解析する際、各要素（クラス、メソッド、フィールド、命令など）についてビジターのメソッドを呼び出して通知します。</p>
<h2 id="変換タイプ"><a class="header" href="#変換タイプ">変換タイプ</a></h2>
<h3 id="1-インジェクションコード挿入"><a class="header" href="#1-インジェクションコード挿入">1. インジェクション（コード挿入）</a></h3>
<p><strong>目標</strong>: メソッドの特定箇所にコードを挿入</p>
<pre><code>メソッドバイトコード
    ↓
インジェクションポイントを見つける
    ↓
フックメソッドへの呼び出しを挿入
    ↓
元のコードを続行
</code></pre>
<p>例の場所:</p>
<ul>
<li><code>At.HEAD</code>: メソッド本体の前</li>
<li><code>At.RETURN</code>: return文の前</li>
<li><code>At.TAIL</code>: メソッドの終わり</li>
</ul>
<h3 id="2-インボケーションメソッド呼び出しのインターセプト"><a class="header" href="#2-インボケーションメソッド呼び出しのインターセプト">2. インボケーション（メソッド呼び出しのインターセプト）</a></h3>
<p><strong>目標</strong>: メソッド内のメソッド呼び出しをインターセプト</p>
<pre><code>メソッドバイトコード
    ↓
ターゲットメソッド呼び出しを見つける
    ↓
同じ引数でフックメソッドを呼び出す
    ↓
必要に応じて引数を変更
    ↓
メソッド呼び出しを行う（またはスキップ）
</code></pre>
<h3 id="3-リダイレクト呼び出し先の変更"><a class="header" href="#3-リダイレクト呼び出し先の変更">3. リダイレクト（呼び出し先の変更）</a></h3>
<p><strong>目標</strong>: どのメソッドが呼び出されるかを変更</p>
<pre><code>A()へのメソッド呼び出し
    ↓
呼び出しをインターセプト
    ↓
B()にリダイレクト
</code></pre>
<h3 id="4-定数の変更"><a class="header" href="#4-定数の変更">4. 定数の変更</a></h3>
<p><strong>目標</strong>: 定数値を変更</p>
<pre><code>定数Xをロード
    ↓
定数Yに置き換え
</code></pre>
<h3 id="5-変数の変更"><a class="header" href="#5-変数の変更">5. 変数の変更</a></h3>
<p><strong>目標</strong>: ローカル変数の値を変更</p>
<pre><code>インデックスNのローカル変数
    ↓
スロットからロード
    ↓
変更を適用
    ↓
戻して格納
</code></pre>
<h2 id="主要なデータ構造"><a class="header" href="#主要なデータ構造">主要なデータ構造</a></h2>
<h3 id="injection"><a class="header" href="#injection">Injection</a></h3>
<p>コードのインジェクションを表します:</p>
<ul>
<li><strong>ターゲットメソッド</strong>: どのメソッドにインジェクトするか</li>
<li><strong>フックメソッド</strong>: どのフックメソッドを呼び出すか</li>
<li><strong>場所</strong>: どこにインジェクトするか（HEAD、RETURNなど）</li>
<li><strong>パラメータ</strong>: どのパラメータを渡すか</li>
</ul>
<h3 id="invocation"><a class="header" href="#invocation">Invocation</a></h3>
<p>メソッド呼び出しのインターセプトを表します:</p>
<ul>
<li><strong>ターゲットメソッド</strong>: どのメソッドがターゲットを呼び出すか</li>
<li><strong>ターゲット呼び出し</strong>: どの呼び出しをインターセプトするか</li>
<li><strong>フックメソッド</strong>: どのフックを呼び出すか</li>
<li><strong>シフト</strong>: 呼び出しの前か後か</li>
</ul>
<h3 id="callbackinfo-1"><a class="header" href="#callbackinfo-1">CallbackInfo</a></h3>
<p>インジェクションの動作を制御します:</p>
<pre><code class="language-java">public class CallbackInfo {
    public boolean cancelled;      // 実行をキャンセル?
    public Object returnValue;     // カスタムリターン?
    public Object[] modifyArgs;    // 変更された引数?
}
</code></pre>
<h2 id="マッピングシステム"><a class="header" href="#マッピングシステム">マッピングシステム</a></h2>
<p>bytekinは難読化されたコードのクラス/メソッド名マッピングをサポートしています:</p>
<pre><code>元の名前     マップされた名前
     ↓                  ↓
  a.class  ────→  com.example.Calculator
  b(II)I   ────→  add(II)I
</code></pre>
<p>マッピングは変換中に適用されます:</p>
<pre><code>フッククラスが"com.example.Calculator"を参照
    ↓
マッピングを適用
    ↓
バイトコード内のマップされた名前を探す
    ↓
それに応じて変換
</code></pre>
<h2 id="スレッドセーフティ"><a class="header" href="#スレッドセーフティ">スレッドセーフティ</a></h2>
<ul>
<li><strong>BytekinTransformer</strong>: <code>build()</code>後はスレッドセーフ</li>
<li><strong>Builder</strong>: 設定中はスレッドセーフではない</li>
<li><strong>transform()</strong>: 複数のスレッドから同時に呼び出し可能</li>
</ul>
<h2 id="パフォーマンスの考慮事項"><a class="header" href="#パフォーマンスの考慮事項">パフォーマンスの考慮事項</a></h2>
<h3 id="効率"><a class="header" href="#効率">効率</a></h3>
<ul>
<li><strong>1回限りのコスト</strong>: トランスフォーマーのビルド</li>
<li><strong>変換時間</strong>: バイトコードサイズに比例</li>
<li><strong>ランタイムオーバーヘッド</strong>: インジェクトされたコードのみが実行される</li>
</ul>
<h3 id="最適化のヒント"><a class="header" href="#最適化のヒント">最適化のヒント</a></h3>
<ol>
<li>トランスフォーマーを1回ビルドして再利用</li>
<li>クラスロードの早い段階で変換を使用</li>
<li>フックメソッドの複雑さを最小限に抑える</li>
<li>ボトルネックを特定するためにプロファイル</li>
</ol>
<h2 id="次のステップ-6"><a class="header" href="#次のステップ-6">次のステップ</a></h2>
<ul>
<li><a href="./features.html">機能</a>を探索する</li>
<li><a href="./advanced-usage.html">高度な使用方法</a>について学ぶ</li>
<li><a href="./examples.html">例</a>を確認する</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="機能概要"><a class="header" href="#機能概要">機能概要</a></h1>
<p>bytekinはJavaバイトコードを操作するためのいくつかの強力な変換機能を提供します。このセクションでは各機能の概要を説明します。</p>
<h2 id="利用可能な機能"><a class="header" href="#利用可能な機能">利用可能な機能</a></h2>
<h3 id="1-inject---コードの挿入"><a class="header" href="#1-inject---コードの挿入">1. Inject - コードの挿入</a></h3>
<p>ソースコードを変更せずに、メソッドの特定の箇所にカスタムコードを挿入します。</p>
<p><strong>ユースケース:</strong></p>
<ul>
<li>ログステートメントの追加</li>
<li>横断的関心事の実装</li>
<li>セキュリティチェックの追加</li>
<li>パラメータの検証</li>
</ul>
<p><strong>例:</strong></p>
<pre><code class="language-java">@Inject(methodName = "calculate", methodDesc = "(II)I", at = At.HEAD)
public static CallbackInfo logStart(int a, int b) {
    System.out.println("Starting calculation");
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>詳細:</strong> <a href="./inject.html">Inject変換</a></p>
<h3 id="2-invoke---メソッド呼び出しのインターセプト"><a class="header" href="#2-invoke---メソッド呼び出しのインターセプト">2. Invoke - メソッド呼び出しのインターセプト</a></h3>
<p>メソッド呼び出しをインターセプトし、必要に応じて引数や戻り値を変更します。</p>
<p><strong>ユースケース:</strong></p>
<ul>
<li>特定のメソッド呼び出しのインターセプト</li>
<li>メソッド引数の変更</li>
<li>メソッドのモックやスタブ化</li>
<li>前処理/後処理の追加</li>
</ul>
<p><strong>例:</strong></p>
<pre><code class="language-java">@Invoke(
    targetMethodName = "process",
    targetMethodDesc = "(Ljava/lang/String;)V",
    invokeMethodName = "validate",
    invokeMethodDesc = "(Ljava/lang/String;)V",
    shift = Shift.BEFORE
)
public static CallbackInfo validateBefore(String input) {
    return new CallbackInfo(false, null, new Object[]{input.trim()});
}
</code></pre>
<p><strong>詳細:</strong> <a href="./invoke.html">Invoke変換</a></p>
<h3 id="3-redirect---メソッド呼び出しのリダイレクト"><a class="header" href="#3-redirect---メソッド呼び出しのリダイレクト">3. Redirect - メソッド呼び出しのリダイレクト</a></h3>
<p>実行時に呼び出されるメソッドを変更します。</p>
<p><strong>ユースケース:</strong></p>
<ul>
<li>代替実装への呼び出しのリダイレクト</li>
<li>メソッド動作のモック</li>
<li>メソッド転送の実装</li>
<li>条件に基づく動作の変更</li>
</ul>
<p><strong>例:</strong></p>
<pre><code class="language-java">@Redirect(
    targetMethodName = "oldMethod",
    targetMethodDesc = "(I)V",
    redirectMethodName = "newMethod",
    redirectMethodDesc = "(I)V"
)
public static void redirectCall(int value) {
    System.out.println("Redirected to new method: " + value);
}
</code></pre>
<p><strong>詳細:</strong> <a href="./redirect.html">Redirect変換</a></p>
<h3 id="4-定数の変更-1"><a class="header" href="#4-定数の変更-1">4. 定数の変更</a></h3>
<p>バイトコードに埋め込まれた定数値を変更します。</p>
<p><strong>ユースケース:</strong></p>
<ul>
<li>ハードコードされた設定値の変更</li>
<li>文字列リテラルの変更</li>
<li>数値定数の変更</li>
<li>実行時の定数のパッチ</li>
</ul>
<p><strong>例:</strong></p>
<pre><code class="language-java">@ModifyConstant(
    methodName = "getVersion",
    oldValue = "1.0",
    newValue = "2.0"
)
public static CallbackInfo updateVersion() {
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>詳細:</strong> <a href="./constant-modification.html">定数の変更</a></p>
<h3 id="5-変数の変更-1"><a class="header" href="#5-変数の変更-1">5. 変数の変更</a></h3>
<p>メソッド内のローカル変数の値を変更します。</p>
<p><strong>ユースケース:</strong></p>
<ul>
<li>入力のサニタイゼーション</li>
<li>データの変換</li>
<li>変数値のデバッグ</li>
<li>カスタムロジックの実装</li>
</ul>
<p><strong>例:</strong></p>
<pre><code class="language-java">@ModifyVariable(
    methodName = "process",
    variableIndex = 1
)
public static void transformVariable(int original) {
    // 変換ロジック
}
</code></pre>
<p><strong>詳細:</strong> <a href="./variable-modification.html">変数の変更</a></p>
<h2 id="機能の組み合わせ"><a class="header" href="#機能の組み合わせ">機能の組み合わせ</a></h2>
<p>複雑な変換のために複数の機能を組み合わせて使用できます:</p>
<pre><code class="language-java">@ModifyClass("com.example.Service")
public class ServiceHooks {

    // ロギングのインジェクション
    @Inject(methodName = "handle", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
    public static CallbackInfo logStart(String input) {
        System.out.println("Processing: " + input);
        return CallbackInfo.empty();
    }

    // 内部呼び出しのインターセプト
    @Invoke(
        targetMethodName = "handle",
        targetMethodDesc = "(Ljava/lang/String;)V",
        invokeMethodName = "validate",
        invokeMethodDesc = "(Ljava/lang/String;)V",
        shift = Shift.BEFORE
    )
    public static CallbackInfo validateInput(String input) {
        return new CallbackInfo(false, null, new Object[]{sanitize(input)});
    }

    private static String sanitize(String input) {
        return input.trim().toLowerCase();
    }
}
</code></pre>
<h2 id="適切な機能の選択"><a class="header" href="#適切な機能の選択">適切な機能の選択</a></h2>
<div class="table-wrapper"><table><thead><tr><th>機能</th><th>目的</th><th>複雑さ</th></tr></thead><tbody>
<tr><td>Inject</td><td>メソッドの特定箇所にコードを挿入</td><td>低</td></tr>
<tr><td>Invoke</td><td>特定の呼び出しをインターセプト</td><td>中</td></tr>
<tr><td>Redirect</td><td>呼び出し先を変更</td><td>中</td></tr>
<tr><td>定数の変更</td><td>ハードコードされた値を変更</td><td>低</td></tr>
<tr><td>変数の変更</td><td>ローカル変数を変換</td><td>高</td></tr>
</tbody></table>
</div>
<h2 id="次のステップ-7"><a class="header" href="#次のステップ-7">次のステップ</a></h2>
<ul>
<li><a href="./inject.html">Inject</a>変換について学ぶ</li>
<li><a href="./invoke.html">Invoke</a>インターセプトを探索する</li>
<li><a href="./examples.html">例</a>を確認する</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="インジェクション変換"><a class="header" href="#インジェクション変換">インジェクション変換</a></h1>
<p><code>@Inject</code>アノテーションを使用すると、ターゲットメソッドの特定のポイントにカスタムコードを挿入できます。</p>
<h2 id="基本的な使用法"><a class="header" href="#基本的な使用法">基本的な使用法</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.Calculator")
public class CalculatorHooks {

    @Inject(
        methodName = "add",
        methodDesc = "(II)I",
        at = At.HEAD
    )
    public static CallbackInfo onAddStart(int a, int b) {
        System.out.println("Adding: " + a + " + " + b);
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="アノテーションパラメータ"><a class="header" href="#アノテーションパラメータ">アノテーションパラメータ</a></h2>
<h3 id="methodname-必須"><a class="header" href="#methodname-必須">methodName (必須)</a></h3>
<p>インジェクション対象のメソッド名。</p>
<pre><code class="language-java">methodName = "add"
</code></pre>
<h3 id="methoddesc-必須"><a class="header" href="#methoddesc-必須">methodDesc (必須)</a></h3>
<p>ターゲットメソッドシグネチャのJVMディスクリプタ。</p>
<pre><code class="language-java">methodDesc = "(II)I"  // int add(int a, int b)
</code></pre>
<p>詳細は<a href="./bytecode-basics.html#method-descriptors-signatures">メソッドディスクリプタ</a>をご覧ください。</p>
<h3 id="at-必須"><a class="header" href="#at-必須">at (必須)</a></h3>
<p>メソッド内のどこにコードをインジェクションするか。</p>
<h2 id="at列挙型---インジェクションポイント"><a class="header" href="#at列挙型---インジェクションポイント">At列挙型 - インジェクションポイント</a></h2>
<h3 id="athead"><a class="header" href="#athead">At.HEAD</a></h3>
<p>メソッドの最初、既存のコードの前にインジェクションします。</p>
<pre><code class="language-java">@Inject(methodName = "calculate", methodDesc = "()I", at = At.HEAD)
public static CallbackInfo atMethodStart() {
    System.out.println("Method started");
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>結果:</strong></p>
<pre><code class="language-java">public int calculate() {
    System.out.println("Method started");  // インジェクション済み
    // 元のコードはここ
}
</code></pre>
<h3 id="atreturn"><a class="header" href="#atreturn">At.RETURN</a></h3>
<p>メソッド内のすべてのreturn文の前にインジェクションします。</p>
<pre><code class="language-java">@Inject(methodName = "getValue", methodDesc = "()I", at = At.RETURN)
public static CallbackInfo beforeReturn(CallbackInfo ci) {
    System.out.println("Returning: " + ci.returnValue);
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>結果:</strong></p>
<pre><code class="language-java">public int getValue() {
    if (condition) {
        System.out.println("Returning: " + value);  // インジェクション済み
        return value;
    }

    System.out.println("Returning: " + defaultValue);  // インジェクション済み
    return defaultValue;
}
</code></pre>
<h3 id="attail"><a class="header" href="#attail">At.TAIL</a></h3>
<p>メソッドの最後、すべてのコードの後、暗黙的なreturnの前にインジェクションします。</p>
<pre><code class="language-java">@Inject(methodName = "cleanup", methodDesc = "()V", at = At.TAIL)
public static CallbackInfo atMethodEnd() {
    System.out.println("Cleanup complete");
    return CallbackInfo.empty();
}
</code></pre>
<h2 id="フックメソッドのパラメータ"><a class="header" href="#フックメソッドのパラメータ">フックメソッドのパラメータ</a></h2>
<p>フックメソッドは、ターゲットメソッドと同じパラメータに加えて<code>CallbackInfo</code>を受け取ります:</p>
<pre><code class="language-java">// ターゲットメソッド:
public String process(String input, int count) { ... }

// フックメソッド:
@Inject(methodName = "process", methodDesc = "(Ljava/lang/String;I)Ljava/lang/String;", at = At.HEAD)
public static CallbackInfo processHook(String input, int count, CallbackInfo ci) {
    // パラメータにアクセス可能
    return CallbackInfo.empty();
}
</code></pre>
<h2 id="callbackinfo---動作の制御"><a class="header" href="#callbackinfo---動作の制御">CallbackInfo - 動作の制御</a></h2>
<p><code>CallbackInfo</code>オブジェクトを使用して、インジェクションの動作を制御できます:</p>
<pre><code class="language-java">public class CallbackInfo {
    public boolean cancelled;      // 元のコードをスキップするか?
    public Object returnValue;     // カスタム値を返すか?
}
</code></pre>
<h3 id="実行のキャンセル"><a class="header" href="#実行のキャンセル">実行のキャンセル</a></h3>
<p>元のメソッドをスキップして早期にreturnします:</p>
<pre><code class="language-java">@Inject(methodName = "authenticate", methodDesc = "(Ljava/lang/String;)Z", at = At.HEAD)
public static CallbackInfo checkPermission(String user, CallbackInfo ci) {
    if (!user.equals("admin")) {
        ci.cancelled = true;
        ci.returnValue = false;  // 元のコードを実行せずfalseを返す
    }
    return ci;
}
</code></pre>
<h3 id="カスタム戻り値"><a class="header" href="#カスタム戻り値">カスタム戻り値</a></h3>
<p>元の結果の代わりにカスタム値を返します:</p>
<pre><code class="language-java">@Inject(methodName = "getCached", methodDesc = "()Ljava/lang/Object;", at = At.HEAD)
public static CallbackInfo useCachedValue(CallbackInfo ci) {
    Object cached = getFromCache();
    if (cached != null) {
        ci.cancelled = true;
        ci.returnValue = cached;
    }
    return ci;
}
</code></pre>
<h2 id="複数のインジェクション"><a class="header" href="#複数のインジェクション">複数のインジェクション</a></h2>
<p>同じメソッドに複数回インジェクションできます:</p>
<pre><code class="language-java">@ModifyClass("com.example.Service")
public class ServiceHooks {

    @Inject(methodName = "handle", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
    public static CallbackInfo logStart(String input) {
        System.out.println("Start: " + input);
        return CallbackInfo.empty();
    }

    @Inject(methodName = "handle", methodDesc = "(Ljava/lang/String;)V", at = At.RETURN)
    public static CallbackInfo logEnd(String input) {
        System.out.println("End: " + input);
        return CallbackInfo.empty();
    }
}
</code></pre>
<p>両方のインジェクションが適用されます。</p>
<h2 id="インスタンスメソッド-vs-静的メソッド"><a class="header" href="#インスタンスメソッド-vs-静的メソッド">インスタンスメソッド vs 静的メソッド</a></h2>
<p>インスタンスメソッドの場合、最初のパラメータは通常<code>this</code>(オブジェクトインスタンス)です:</p>
<pre><code class="language-java">// ターゲットインスタンスメソッド:
public class Calculator {
    public int add(int a, int b) { return a + b; }
}

// フックは'this'を受け取れます:
@Inject(methodName = "add", methodDesc = "(II)I", at = At.HEAD)
public static CallbackInfo onAdd(Calculator self, int a, int b) {
    System.out.println("Calculator instance: " + self);
    return CallbackInfo.empty();
}
</code></pre>
<h2 id="ベストプラクティス"><a class="header" href="#ベストプラクティス">ベストプラクティス</a></h2>
<ol>
<li><strong>フックをシンプルに保つ</strong>: 複雑なロジックは別のメソッドに</li>
<li><strong>例外を避ける</strong>: フックメソッド内で例外を処理する</li>
<li><strong>ガードにAt.HEADを使用</strong>: 早期に条件をチェック</li>
<li><strong>At.RETURNに注意</strong>: 複数のreturnには処理が必要</li>
<li><strong>十分にテスト</strong>: インジェクションが正しく動作することを検証</li>
</ol>
<h2 id="例-1"><a class="header" href="#例-1">例</a></h2>
<p>完全な動作例については、<a href="./examples-basic.html#inject-examples">例 - インジェクション</a>をご覧ください。</p>
<h2 id="次のステップ-8"><a class="header" href="#次のステップ-8">次のステップ</a></h2>
<ul>
<li>メソッドインターセプションのための<a href="./invoke.html">インボケーション</a>について学ぶ</li>
<li><a href="./advanced-usage.html">高度な使用法</a>を探る</li>
<li><a href="./api-reference.html">APIリファレンス</a>をチェック</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="インボケーション変換"><a class="header" href="#インボケーション変換">インボケーション変換</a></h1>
<p><code>@Invoke</code>アノテーションを使用すると、メソッド呼び出しをインターセプトし、実行前に引数をオプションで変更できます。</p>
<h2 id="基本的な使用法-1"><a class="header" href="#基本的な使用法-1">基本的な使用法</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.DataProcessor")
public class ProcessorHooks {

    @Invoke(
        targetMethodName = "process",
        targetMethodDesc = "(Ljava/lang/String;)V",
        invokeMethodName = "validate",
        invokeMethodDesc = "(Ljava/lang/String;)V",
        shift = Shift.BEFORE
    )
    public static CallbackInfo validateBeforeProcess(String data) {
        if (data == null || data.isEmpty()) {
            return new CallbackInfo(true, null, new Object[]{"default"});
        }
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="アノテーションパラメータ-1"><a class="header" href="#アノテーションパラメータ-1">アノテーションパラメータ</a></h2>
<h3 id="targetmethodname-必須"><a class="header" href="#targetmethodname-必須">targetMethodName (必須)</a></h3>
<p>インターセプトする呼び出しを含むメソッド名。</p>
<pre><code class="language-java">targetMethodName = "process"
</code></pre>
<h3 id="targetmethoddesc-必須"><a class="header" href="#targetmethoddesc-必須">targetMethodDesc (必須)</a></h3>
<p>呼び出しを含むメソッドのJVMディスクリプタ。</p>
<pre><code class="language-java">targetMethodDesc = "(Ljava/lang/String;)V"
</code></pre>
<h3 id="invokemethodname-必須"><a class="header" href="#invokemethodname-必須">invokeMethodName (必須)</a></h3>
<p>呼び出されているメソッド(インターセプトしたいもの)の名前。</p>
<pre><code class="language-java">invokeMethodName = "helper"
</code></pre>
<h3 id="invokemethoddesc-必須"><a class="header" href="#invokemethoddesc-必須">invokeMethodDesc (必須)</a></h3>
<p>呼び出されているメソッドのJVMディスクリプタ。</p>
<pre><code class="language-java">invokeMethodDesc = "(I)Ljava/lang/String;"
</code></pre>
<h3 id="shift-必須"><a class="header" href="#shift-必須">shift (必須)</a></h3>
<p>メソッド呼び出しに対してフックを実行するタイミング。</p>
<h2 id="shift列挙型---タイミング"><a class="header" href="#shift列挙型---タイミング">Shift列挙型 - タイミング</a></h2>
<h3 id="shiftbefore"><a class="header" href="#shiftbefore">Shift.BEFORE</a></h3>
<p>メソッドが呼び出される<strong>前</strong>にフックを実行します。</p>
<pre><code class="language-java">@Invoke(
    targetMethodName = "process",
    targetMethodDesc = "(Ljava/lang/String;)V",
    invokeMethodName = "validate",
    invokeMethodDesc = "(Ljava/lang/String;)V",
    shift = Shift.BEFORE
)
public static CallbackInfo beforeCall(String input) {
    System.out.println("Before calling validate");
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>結果:</strong></p>
<pre><code class="language-java">public void process(String input) {
    System.out.println("Before calling validate");  // インジェクション済み
    validate(input);
    // 残りのコード
}
</code></pre>
<h3 id="shiftafter"><a class="header" href="#shiftafter">Shift.AFTER</a></h3>
<p>メソッドが呼び出された<strong>後</strong>にフックを実行します。</p>
<pre><code class="language-java">@Invoke(
    targetMethodName = "process",
    targetMethodDesc = "(Ljava/lang/String;)V",
    invokeMethodName = "save",
    invokeMethodDesc = "()V",
    shift = Shift.AFTER
)
public static CallbackInfo afterCall() {
    System.out.println("After calling save");
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>結果:</strong></p>
<pre><code class="language-java">public void process(String input) {
    // 何らかのコード
    save();
    System.out.println("After calling save");  // インジェクション済み
}
</code></pre>
<h2 id="引数の変更"><a class="header" href="#引数の変更">引数の変更</a></h2>
<p><code>CallbackInfo</code>を使用して、インターセプトされた呼び出しに渡される引数を変更します:</p>
<pre><code class="language-java">@Invoke(
    targetMethodName = "processData",
    targetMethodDesc = "(Ljava/lang/String;I)V",
    invokeMethodName = "transform",
    invokeMethodDesc = "(Ljava/lang/String;I)V",
    shift = Shift.BEFORE
)
public static CallbackInfo sanitizeInput(String data, int count, CallbackInfo ci) {
    // 引数を変更
    String sanitized = data.trim().toLowerCase();
    int newCount = Math.max(0, count);

    ci.modifyArgs = new Object[]{sanitized, newCount};
    return ci;
}
</code></pre>
<p><strong>結果:</strong></p>
<pre><code class="language-java">public void processData(String data, int count) {
    // 元: transform(data, count);
    // フック後: transform(data.trim().toLowerCase(), max(0, count));
    transform(data, count);
}
</code></pre>
<h2 id="メソッド呼び出しのキャンセル"><a class="header" href="#メソッド呼び出しのキャンセル">メソッド呼び出しのキャンセル</a></h2>
<p>メソッドが呼び出されないようにします:</p>
<pre><code class="language-java">@Invoke(
    targetMethodName = "deleteFile",
    targetMethodDesc = "(Ljava/lang/String;)Z",
    invokeMethodName = "delete",
    invokeMethodDesc = "(Ljava/io/File;)Z",
    shift = Shift.BEFORE
)
public static CallbackInfo preventDeletion(File file, CallbackInfo ci) {
    if (isSystemFile(file)) {
        // delete()を呼び出さず、falseを返す
        ci.cancelled = true;
        ci.returnValue = false;
    }
    return ci;
}
</code></pre>
<h2 id="戻り値の処理"><a class="header" href="#戻り値の処理">戻り値の処理</a></h2>
<p>戻り値にアクセスして変更します(<code>Shift.AFTER</code>の場合):</p>
<pre><code class="language-java">@Invoke(
    targetMethodName = "getValue",
    targetMethodDesc = "()I",
    invokeMethodName = "compute",
    invokeMethodDesc = "()I",
    shift = Shift.AFTER
)
public static CallbackInfo modifyReturnValue(CallbackInfo ci) {
    // 戻り値にアクセス
    int original = (int) ci.returnValue;

    // 変更する
    ci.returnValue = original * 2;

    return ci;
}
</code></pre>
<h2 id="複雑な例"><a class="header" href="#複雑な例">複雑な例</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.UserService")
public class UserServiceHooks {

    // ログイン試行をインターセプト
    @Invoke(
        targetMethodName = "authenticate",
        targetMethodDesc = "(Ljava/lang/String;Ljava/lang/String;)Z",
        invokeMethodName = "validateCredentials",
        invokeMethodDesc = "(Ljava/lang/String;Ljava/lang/String;)Z",
        shift = Shift.BEFORE
    )
    public static CallbackInfo logAuthAttempt(
        String username, String password, CallbackInfo ci
    ) {
        // 試行をログに記録
        System.out.println("Auth attempt for: " + username);

        // 特定のユーザー名をブロック
        if (username.equals("blocked")) {
            ci.cancelled = true;
            ci.returnValue = false;
        }

        return ci;
    }
}
</code></pre>
<h2 id="ベストプラクティス-1"><a class="header" href="#ベストプラクティス-1">ベストプラクティス</a></h2>
<ol>
<li><strong>呼び出しフローを理解する</strong>: メソッドがどこで呼び出されるかを知る</li>
<li><strong>タイミングを考慮する</strong>: 入力検証には<code>BEFORE</code>、出力変換には<code>AFTER</code></li>
<li><strong>引数の変更をテスト</strong>: 型が一致することを確認</li>
<li><strong>キャンセルを慎重に処理</strong>: 呼び出し元のコードがキャンセルされた呼び出しを処理することを確認</li>
<li><strong>パフォーマンスをプロファイル</strong>: フックはすべての呼び出しで実行される</li>
</ol>
<h2 id="制限事項"><a class="header" href="#制限事項">制限事項</a></h2>
<ul>
<li>明示的なメソッド呼び出しのみインターセプト可能、バイトコードからの仮想メソッド呼び出しは不可</li>
<li>コンストラクタへの呼び出しを直接インターセプトできない</li>
<li>すべての呼び出しでパフォーマンスへの影響が発生する</li>
</ul>
<h2 id="例-2"><a class="header" href="#例-2">例</a></h2>
<p>完全な動作例については、<a href="./examples-basic.html#invoke-examples">例 - インボケーション</a>をご覧ください。</p>
<h2 id="次のステップ-9"><a class="header" href="#次のステップ-9">次のステップ</a></h2>
<ul>
<li><a href="./redirect.html">リダイレクト</a>変換について学ぶ</li>
<li><a href="./advanced-usage.html">高度な使用法</a>を探る</li>
<li><a href="./api-reference.html">APIリファレンス</a>をチェック</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="リダイレクト変換"><a class="header" href="#リダイレクト変換">リダイレクト変換</a></h1>
<p><code>@Redirect</code>アノテーションを使用すると、実行時に実際に呼び出されるメソッドを変更できます。</p>
<h2 id="基本的な使用法-2"><a class="header" href="#基本的な使用法-2">基本的な使用法</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.LegacyService")
public class LegacyServiceHooks {

    @Redirect(
        targetMethodName = "oldMethod",
        targetMethodDesc = "(I)V",
        redirectMethodName = "newMethod",
        redirectMethodDesc = "(I)V"
    )
    public static void redirectCall(int value) {
        System.out.println("Redirecting call with value: " + value);
    }
}
</code></pre>
<h2 id="アノテーションパラメータ-2"><a class="header" href="#アノテーションパラメータ-2">アノテーションパラメータ</a></h2>
<h3 id="targetmethodname-必須-1"><a class="header" href="#targetmethodname-必須-1">targetMethodName (必須)</a></h3>
<p>リダイレクトする呼び出しを含むメソッドの名前。</p>
<pre><code class="language-java">targetMethodName = "process"
</code></pre>
<h3 id="targetmethoddesc-必須-1"><a class="header" href="#targetmethoddesc-必須-1">targetMethodDesc (必須)</a></h3>
<p>ターゲットメソッドのJVMディスクリプタ。</p>
<pre><code class="language-java">targetMethodDesc = "(Ljava/lang/String;)V"
</code></pre>
<h3 id="redirectmethodname-必須"><a class="header" href="#redirectmethodname-必須">redirectMethodName (必須)</a></h3>
<p>代わりに呼び出す新しいメソッドの名前。</p>
<pre><code class="language-java">redirectMethodName = "newImplementation"
</code></pre>
<h3 id="redirectmethoddesc-必須"><a class="header" href="#redirectmethoddesc-必須">redirectMethodDesc (必須)</a></h3>
<p>リダイレクトメソッドのJVMディスクリプタ。</p>
<pre><code class="language-java">redirectMethodDesc = "(Ljava/lang/String;)V"
</code></pre>
<h2 id="リダイレクトの仕組み"><a class="header" href="#リダイレクトの仕組み">リダイレクトの仕組み</a></h2>
<p><strong>前:</strong></p>
<pre><code class="language-java">public class LegacyAPI {
    public void oldMethod(int value) {
        // 古い実装
    }
}

public class Client {
    public void use() {
        api.oldMethod(42);  // oldMethodを呼び出す
    }
}
</code></pre>
<p><strong>リダイレクト後:</strong></p>
<pre><code class="language-java">public class Client {
    public void use() {
        api.newMethod(42);  // newMethodにリダイレクト!
    }
}
</code></pre>
<h2 id="実用的な例"><a class="header" href="#実用的な例">実用的な例</a></h2>
<h3 id="移行戦略"><a class="header" href="#移行戦略">移行戦略</a></h3>
<p>古いAPIから新しいAPIに段階的に移行:</p>
<pre><code class="language-java">@ModifyClass("com.example.Application")
public class APIRedirection {

    @Redirect(
        targetMethodName = "main",
        targetMethodDesc = "([Ljava/lang/String;)V",
        redirectMethodName = "legacySearch",
        redirectMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
        from = "oldSearch",
        to = "modernSearch"
    )
    public static void upgradeSearch() {
        // 検索呼び出しが最新の実装にルーティングされる
    }
}
</code></pre>
<h3 id="テストのためのモッキング"><a class="header" href="#テストのためのモッキング">テストのためのモッキング</a></h3>
<p>実際の実装をテストダブルで置き換え:</p>
<pre><code class="language-java">@ModifyClass("com.example.DataAccess")
public class TestRedirection {

    @Redirect(
        targetMethodName = "query",
        targetMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
        redirectMethodName = "fetchFromDatabase",
        redirectMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
        from = "realDB",
        to = "mockDB"
    )
    public static void useMockDatabase() {
        // すべてのデータベース呼び出しがモック実装を使用
    }
}
</code></pre>
<h3 id="パフォーマンス最適化"><a class="header" href="#パフォーマンス最適化">パフォーマンス最適化</a></h3>
<p>最適化された実装にルーティング:</p>
<pre><code class="language-java">@ModifyClass("com.example.Processing")
public class PerformanceOptimization {

    @Redirect(
        targetMethodName = "processLargeList",
        targetMethodDesc = "(Ljava/util/List;)Ljava/util/List;",
        redirectMethodName = "slowImplementation",
        redirectMethodDesc = "(Ljava/util/List;)Ljava/util/List;",
        from = "bruteForce",
        to = "optimized"
    )
    public static void useOptimizedAlgorithm() {
        // 遅いアルゴリズムの代わりに高速アルゴリズムを使用
    }
}
</code></pre>
<h2 id="他の変換との違い"><a class="header" href="#他の変換との違い">他の変換との違い</a></h2>
<div class="table-wrapper"><table><thead><tr><th>機能</th><th>インジェクション</th><th>インボケーション</th><th>リダイレクト</th></tr></thead><tbody>
<tr><td>何をするか</td><td>コードを挿入</td><td>呼び出しをインターセプト</td><td>ターゲットを変更</td></tr>
<tr><td>呼び出しは発生するか</td><td>はい</td><td>はい</td><td>はい、ただし異なるターゲット</td></tr>
<tr><td>実行をスキップできるか</td><td>はい</td><td>はい</td><td>はい</td></tr>
<tr><td>ユースケース</td><td>ロギングの追加</td><td>動作を変更</td><td>API移行</td></tr>
</tbody></table>
</div>
<h2 id="型の互換性"><a class="header" href="#型の互換性">型の互換性</a></h2>
<p>リダイレクトメソッドは互換性のあるシグネチャを持つ必要があります:</p>
<pre><code class="language-java">// 元の呼び出し
search(String query);  // (Ljava/lang/String;)Ljava/util/List;

// 互換性のあるシグネチャにリダイレクトする必要がある
newSearch(String query);  // (Ljava/lang/String;)Ljava/util/List;
</code></pre>
<p><strong>型の不一致は問題を引き起こします:</strong></p>
<pre><code class="language-java">// 間違い - パラメータの型が異なる
@Redirect(..., from = "process(int)", to = "process(String)")
</code></pre>
<h2 id="パフォーマンスの考慮事項-1"><a class="header" href="#パフォーマンスの考慮事項-1">パフォーマンスの考慮事項</a></h2>
<p>リダイレクトは通常のメソッド呼び出しと比較して最小限のオーバーヘッドです:</p>
<ol>
<li>直接的なバイトコード置換である</li>
<li>ラッパーやプロキシは作成されない</li>
<li>JVMは通常通りインライン化と最適化が可能</li>
</ol>
<h2 id="制限事項-1"><a class="header" href="#制限事項-1">制限事項</a></h2>
<ul>
<li>両方のメソッドは互換性のあるシグネチャを持つ必要がある</li>
<li>finalメソッドにリダイレクトできない</li>
<li>コンストラクタ呼び出しをリダイレクトできない(代わりに<code>@Invoke</code>を使用)</li>
<li>リダイレクトは静的 - すべての呼び出しで同じターゲット</li>
</ul>
<h2 id="ベストプラクティス-2"><a class="header" href="#ベストプラクティス-2">ベストプラクティス</a></h2>
<ol>
<li><strong>互換性を確保</strong>: メソッドシグネチャが完全に一致することを確認</li>
<li><strong>リダイレクトを文書化</strong>: なぜかを説明するコメントを残す</li>
<li><strong>リダイレクトをテスト</strong>: リダイレクト後の動作を検証</li>
<li><strong>移行に使用</strong>: 古いAPIから新しいAPIへの移行に最適</li>
<li><strong>注意する</strong>: 混乱を避けるためにすべてのリダイレクトを追跡</li>
</ol>
<h2 id="高度なパターン-条件付きリダイレクト"><a class="header" href="#高度なパターン-条件付きリダイレクト">高度なパターン: 条件付きリダイレクト</a></h2>
<p><code>@Redirect</code>は静的ですが、<code>@Invoke</code>と組み合わせて条件付き動作を実現できます:</p>
<pre><code class="language-java">@Invoke(
    targetMethodName = "search",
    targetMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
    invokeMethodName = "getResults",
    invokeMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
    shift = Shift.BEFORE
)
public static CallbackInfo selectImplementation(String query, CallbackInfo ci) {
    if (query.length() &gt; 100) {
        // 大きなクエリには最適化された検索を使用
        ci.returnValue = optimizedSearch(query);
        ci.cancelled = true;
    }
    return ci;
}
</code></pre>
<h2 id="次のステップ-10"><a class="header" href="#次のステップ-10">次のステップ</a></h2>
<ul>
<li><a href="./constant-modification.html">定数の変更</a>について学ぶ</li>
<li><a href="./advanced-usage.html">高度な使用法</a>を探る</li>
<li><a href="./examples.html">例</a>をチェック</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="定数の変更"><a class="header" href="#定数の変更">定数の変更</a></h1>
<p>ソースコードを再コンパイルすることなく、バイトコード内のハードコードされた定数値を変更します。</p>
<h2 id="基本的な使用方法"><a class="header" href="#基本的な使用方法">基本的な使用方法</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.Config")
public class ConfigHooks {

    @ModifyConstant(
        methodName = "getVersion",
        oldValue = "1.0.0",
        newValue = "2.0.0"
    )
    public static CallbackInfo updateVersion() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="変更可能な定数"><a class="header" href="#変更可能な定数">変更可能な定数</a></h2>
<ul>
<li>文字列リテラル</li>
<li>数値定数（int、long、float、double）</li>
<li>ブール定数</li>
<li>定数プール内の定数</li>
</ul>
<h2 id="文字列定数"><a class="header" href="#文字列定数">文字列定数</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.App")
public class AppHooks {

    @ModifyConstant(
        methodName = "getAPIEndpoint",
        oldValue = "http://localhost:8080",
        newValue = "https://api.production.com"
    )
    public static CallbackInfo updateEndpoint() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<p><strong>変更前:</strong></p>
<pre><code class="language-java">public String getAPIEndpoint() {
    return "http://localhost:8080";
}
</code></pre>
<p><strong>変更後:</strong></p>
<pre><code class="language-java">public String getAPIEndpoint() {
    return "https://api.production.com";
}
</code></pre>
<h2 id="数値定数"><a class="header" href="#数値定数">数値定数</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.Limits")
public class LimitsHooks {

    @ModifyConstant(
        methodName = "getMaxConnections",
        oldValue = 10,
        newValue = 100
    )
    public static CallbackInfo increaseLimit() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="同じメソッド内の複数の定数"><a class="header" href="#同じメソッド内の複数の定数">同じメソッド内の複数の定数</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.Config")
public class ConfigHooks {

    @ModifyConstant(
        methodName = "initialize",
        oldValue = "DEBUG",
        newValue = "PRODUCTION"
    )
    public static CallbackInfo updateMode() {
        return CallbackInfo.empty();
    }

    @ModifyConstant(
        methodName = "initialize",
        oldValue = "localhost",
        newValue = "example.com"
    )
    public static CallbackInfo updateHost() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<p>両方の変更が同じメソッドに適用されます。</p>
<h2 id="ユースケース-2"><a class="header" href="#ユースケース-2">ユースケース</a></h2>
<h3 id="環境設定"><a class="header" href="#環境設定">環境設定</a></h3>
<p>環境固有の値を変更:</p>
<pre><code class="language-java">@ModifyClass("com.example.Environment")
public class EnvironmentHooks {

    @ModifyConstant(
        methodName = "getDatabaseURL",
        oldValue = "jdbc:mysql://dev.local:3306/db",
        newValue = "jdbc:mysql://prod.remote:3306/db"
    )
    public static CallbackInfo updateDatabase() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<h3 id="フィーチャーフラグ"><a class="header" href="#フィーチャーフラグ">フィーチャーフラグ</a></h3>
<p>再コンパイルなしで機能を有効/無効化:</p>
<pre><code class="language-java">@ModifyClass("com.example.Features")
public class FeatureHooks {

    @ModifyConstant(
        methodName = "isNewFeatureEnabled",
        oldValue = false,
        newValue = true
    )
    public static CallbackInfo enableFeature() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<h3 id="apiバージョニング"><a class="header" href="#apiバージョニング">APIバージョニング</a></h3>
<p>APIエンドポイントを更新:</p>
<pre><code class="language-java">@ModifyClass("com.example.API")
public class APIHooks {

    @ModifyConstant(
        methodName = "getAPIVersion",
        oldValue = "v1",
        newValue = "v3"
    )
    public static CallbackInfo updateAPIVersion() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="パフォーマンスへの影響"><a class="header" href="#パフォーマンスへの影響">パフォーマンスへの影響</a></h2>
<p>定数の変更は<strong>最小限のランタイムオーバーヘッド</strong>です:</p>
<ol>
<li>変更はバイトコード変換時に行われる（1回のみ）</li>
<li>ランタイムパフォーマンスは再コンパイルされたコードと同一</li>
<li>JVMは変更された定数を最適化できる</li>
</ol>
<h2 id="制限事項-2"><a class="header" href="#制限事項-2">制限事項</a></h2>
<h3 id="変更できないもの"><a class="header" href="#変更できないもの">変更できないもの</a></h3>
<ul>
<li>ローカル変数の初期化（一部のケース）</li>
<li>実行時に作成される定数</li>
<li>JVMによってすでに最適化された定数</li>
</ul>
<h3 id="型の一致"><a class="header" href="#型の一致">型の一致</a></h3>
<p>古い値と新しい値は互換性のある型である必要があります:</p>
<pre><code class="language-java">// 正しい
@ModifyConstant(
    methodName = "getCount",
    oldValue = 10,        // int
    newValue = 20         // int - 互換性あり
)

// 誤り
@ModifyConstant(
    methodName = "getCount",
    oldValue = 10,        // int
    newValue = "20"       // String - 互換性なし!
)
</code></pre>
<h2 id="ベストプラクティス-3"><a class="header" href="#ベストプラクティス-3">ベストプラクティス</a></h2>
<ol>
<li><strong>設定に使用する</strong>: ロジックの変更には使用しない</li>
<li><strong>明確に文書化する</strong>: 定数が変更される理由を説明する</li>
<li><strong>値の一貫性を保つ</strong>: 正確な古い値を使用する</li>
<li><strong>すべてのパスをテストする</strong>: 新しい値でコードが動作することを確認する</li>
<li><strong>型の変更を避ける</strong>: 型の互換性を保つ</li>
</ol>
<h2 id="応用-条件付き変更"><a class="header" href="#応用-条件付き変更">応用: 条件付き変更</a></h2>
<p>より詳細な制御のために、他の変換と組み合わせる:</p>
<pre><code class="language-java">@ModifyClass("com.example.Service")
public class ServiceHooks {

    @Inject(
        methodName = "initialize",
        methodDesc = "()V",
        at = At.HEAD
    )
    public static CallbackInfo checkEnvironment() {
        String env = System.getProperty("environment");
        if ("production".equals(env)) {
            // プロダクション用の追加セットアップ
        }
        return CallbackInfo.empty();
    }

    @ModifyConstant(
        methodName = "getTimeout",
        oldValue = 5000,
        newValue = 30000
    )
    public static CallbackInfo productionTimeout() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="次のステップ-11"><a class="header" href="#次のステップ-11">次のステップ</a></h2>
<ul>
<li><a href="./variable-modification.html">変数の変更</a>について学ぶ</li>
<li><a href="./advanced-usage.html">高度な使用方法</a>を探索する</li>
<li><a href="./examples.html">例</a>を確認する</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="変数の変更"><a class="header" href="#変数の変更">変数の変更</a></h1>
<p>バイトコード変換中にメソッド内のローカル変数の値を変更します。</p>
<h2 id="基本的な使用方法-1"><a class="header" href="#基本的な使用方法-1">基本的な使用方法</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.Processor")
public class ProcessorHooks {

    @ModifyVariable(
        methodName = "process",
        variableIndex = 1
    )
    public static void sanitizeInput(String original) {
        // 変換ロジック
    }
}
</code></pre>
<h2 id="変数インデックスの理解"><a class="header" href="#変数インデックスの理解">変数インデックスの理解</a></h2>
<p>メソッド内のローカル変数はスロットに格納され、0から始まるインデックスが付けられます:</p>
<h3 id="インスタンスメソッド"><a class="header" href="#インスタンスメソッド">インスタンスメソッド</a></h3>
<pre><code class="language-java">public void process(String name, int count) {
    String result;
    // ...
}
</code></pre>
<p>変数インデックス:</p>
<ul>
<li><code>0</code>: <code>this</code>（暗黙的）</li>
<li><code>1</code>: <code>name</code>（第1引数）</li>
<li><code>2</code>: <code>count</code>（第2引数）</li>
<li><code>3</code>: <code>result</code>（ローカル変数）</li>
</ul>
<h3 id="静的メソッド"><a class="header" href="#静的メソッド">静的メソッド</a></h3>
<pre><code class="language-java">public static void process(String name, int count) {
    String result;
    // ...
}
</code></pre>
<p>変数インデックス:</p>
<ul>
<li><code>0</code>: <code>name</code>（第1引数）</li>
<li><code>1</code>: <code>count</code>（第2引数）</li>
<li><code>2</code>: <code>result</code>（ローカル変数）</li>
</ul>
<h2 id="アノテーションパラメータ-3"><a class="header" href="#アノテーションパラメータ-3">アノテーションパラメータ</a></h2>
<h3 id="methodname必須"><a class="header" href="#methodname必須">methodName（必須）</a></h3>
<p>対象メソッドの名前。</p>
<pre><code class="language-java">methodName = "process"
</code></pre>
<h3 id="variableindex必須"><a class="header" href="#variableindex必須">variableIndex（必須）</a></h3>
<p>変更するローカル変数のインデックス。</p>
<pre><code class="language-java">variableIndex = 1
</code></pre>
<h2 id="パラメータの変更"><a class="header" href="#パラメータの変更">パラメータの変更</a></h2>
<p>メソッドパラメータを変換:</p>
<pre><code class="language-java">@ModifyClass("com.example.UserService")
public class UserServiceHooks {

    @ModifyVariable(
        methodName = "createUser",
        variableIndex = 1  // 第1引数: email
    )
    public static void normalizeEmail(String original) {
        // 元のメールアドレスが正規化される
        // 例: "USER@EXAMPLE.COM" が "user@example.com" になる
    }
}
</code></pre>
<p><strong>変更前:</strong></p>
<pre><code class="language-java">public void createUser(String email) {
    // email = "USER@EXAMPLE.COM"
    // ...
}
</code></pre>
<p><strong>変更後:</strong></p>
<pre><code class="language-java">public void createUser(String email) {
    // email = "user@example.com" （正規化済み）
    // ...
}
</code></pre>
<h2 id="ローカル変数の変更"><a class="header" href="#ローカル変数の変更">ローカル変数の変更</a></h2>
<p>メソッド内で作成された変数を変換:</p>
<pre><code class="language-java">@ModifyClass("com.example.Calculator")
public class CalculatorHooks {

    @ModifyVariable(
        methodName = "calculateTotal",
        variableIndex = 2  // ローカル変数: total
    )
    public static void applyTaxToTotal(int original) {
        // total に1.1を掛けて税を適用
    }
}
</code></pre>
<h2 id="ユースケース-3"><a class="header" href="#ユースケース-3">ユースケース</a></h2>
<h3 id="入力のサニタイゼーション"><a class="header" href="#入力のサニタイゼーション">入力のサニタイゼーション</a></h3>
<p>メソッド入力をクリーンアップ:</p>
<pre><code class="language-java">@ModifyClass("com.example.WebService")
public class WebServiceHooks {

    @ModifyVariable(
        methodName = "handleRequest",
        variableIndex = 1  // request パラメータ
    )
    public static void sanitizeRequest(String original) {
        // 悪意のある文字を削除
    }

    @ModifyVariable(
        methodName = "handleRequest",
        variableIndex = 2  // path パラメータ
    )
    public static void validatePath(String original) {
        // パスがルートディレクトリから逸脱しないことを確認
    }
}
</code></pre>
<h3 id="データ変換"><a class="header" href="#データ変換">データ変換</a></h3>
<p>データ形式を変換:</p>
<pre><code class="language-java">@ModifyClass("com.example.DateProcessor")
public class DateProcessorHooks {

    @ModifyVariable(
        methodName = "processDate",
        variableIndex = 1  // date パラメータ
    )
    public static void convertToUTC(String original) {
        // ローカル時間からUTCに変換
    }
}
</code></pre>
<h3 id="型変換"><a class="header" href="#型変換">型変換</a></h3>
<p>データ型を変更:</p>
<pre><code class="language-java">@ModifyClass("com.example.Converter")
public class ConverterHooks {

    @ModifyVariable(
        methodName = "process",
        variableIndex = 1  // number パラメータ
    )
    public static void convertToPercentage(int original) {
        // 生の数値をパーセンテージに変換
    }
}
</code></pre>
<h2 id="高度なパターン"><a class="header" href="#高度なパターン">高度なパターン</a></h2>
<h3 id="複数の変数"><a class="header" href="#複数の変数">複数の変数</a></h3>
<p>同じメソッド内の複数の変数を変更:</p>
<pre><code class="language-java">@ModifyClass("com.example.Transfer")
public class TransferHooks {

    @ModifyVariable(
        methodName = "transfer",
        variableIndex = 1  // 送信元アカウント
    )
    public static void validateFromAccount(String original) {
        // 送信元アカウントを検証
    }

    @ModifyVariable(
        methodName = "transfer",
        variableIndex = 2  // 送信先アカウント
    )
    public static void validateToAccount(String original) {
        // 送信先アカウントを検証
    }

    @ModifyVariable(
        methodName = "transfer",
        variableIndex = 3  // 金額
    )
    public static void validateAmount(long original) {
        // 金額が正であることを確認
    }
}
</code></pre>
<p>3つすべての変更が同じメソッドに適用されます。</p>
<h2 id="型の保持"><a class="header" href="#型の保持">型の保持</a></h2>
<p>変更中に変数の型は保持されます:</p>
<pre><code class="language-java">@ModifyClass("com.example.Data")
public class DataHooks {

    // String パラメータの変更
    @ModifyVariable(methodName = "processName", variableIndex = 1)
    public static void transformName(String original) { }

    // int パラメータの変更
    @ModifyVariable(methodName = "processCount", variableIndex = 1)
    public static void transformCount(int original) { }

    // List パラメータの変更
    @ModifyVariable(methodName = "processItems", variableIndex = 1)
    public static void transformItems(List&lt;?&gt; original) { }
}
</code></pre>
<p>各フックは自動的に正しい型を受け取ります。</p>
<h2 id="制限事項-3"><a class="header" href="#制限事項-3">制限事項</a></h2>
<h3 id="変更できないもの-1"><a class="header" href="#変更できないもの-1">変更できないもの</a></h3>
<ul>
<li>使用されない変数</li>
<li>JVMによって最適化されて削除された値を持つ変数</li>
<li>初期化後に複雑な方法で変更される変数</li>
</ul>
<h3 id="課題"><a class="header" href="#課題">課題</a></h3>
<ol>
<li><strong>インデックスの計算</strong>: 変数インデックスを正しく識別する必要がある</li>
<li><strong>型安全性</strong>: パラメータの型が一致する必要がある</li>
<li><strong>スコープ</strong>: 変更はそのメソッド内でのみ有効</li>
<li><strong>デバッグ</strong>: 変更の追跡が困難な場合がある</li>
</ol>
<h2 id="正しい変数インデックスの特定"><a class="header" href="#正しい変数インデックスの特定">正しい変数インデックスの特定</a></h2>
<p><code>javap</code>を使用して変数レイアウトを検査:</p>
<pre><code class="language-bash">javap -c -private MyClass.class | grep -A 50 "methodName"
</code></pre>
<p>変数の位置を示すLocalVariableTableを探してください。</p>
<h2 id="ベストプラクティス-4"><a class="header" href="#ベストプラクティス-4">ベストプラクティス</a></h2>
<ol>
<li><strong>インデックスを文書化する</strong>: どの変数がどのインデックスかを明確にコメントする</li>
<li><strong>変換をシンプルに保つ</strong>: 複雑なロジックは別にすべき</li>
<li><strong>セマンティクスを保持する</strong>: 変更された値が意味をなすことを確認する</li>
<li><strong>徹底的にテストする</strong>: 変更された変数での動作を検証する</li>
<li><strong>インスペクタを使用する</strong>: 適用前にインデックスが正しいことを確認する</li>
</ol>
<h2 id="他の機能との組み合わせ"><a class="header" href="#他の機能との組み合わせ">他の機能との組み合わせ</a></h2>
<p>変数の変更をインジェクションと併用:</p>
<pre><code class="language-java">@ModifyClass("com.example.Service")
public class ServiceHooks {

    @Inject(
        methodName = "handle",
        methodDesc = "(Ljava/lang/String;)V",
        at = At.HEAD
    )
    public static CallbackInfo validateInput(String input) {
        if (input == null || input.isEmpty()) {
            return new CallbackInfo(true, null, null);
        }
        return CallbackInfo.empty();
    }

    @ModifyVariable(
        methodName = "handle",
        variableIndex = 1  // input パラメータ
    )
    public static void normalizeInput(String original) {
        // 入力も正規化
    }
}
</code></pre>
<h2 id="次のステップ-12"><a class="header" href="#次のステップ-12">次のステップ</a></h2>
<ul>
<li><a href="./advanced-usage.html">高度な使用方法</a>を探索する</li>
<li><a href="./mappings.html">マッピング</a>について学ぶ</li>
<li><a href="./examples.html">例</a>を確認する</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高度な使用方法"><a class="header" href="#高度な使用方法">高度な使用方法</a></h1>
<p>このセクションでは、bytekinを効果的に使用するための高度なパターンとテクニックについて説明します。</p>
<h2 id="プログラマティックapiアノテーションベース以外"><a class="header" href="#プログラマティックapiアノテーションベース以外">プログラマティックAPI(アノテーションベース以外)</a></h2>
<p>アノテーションは便利ですが、プログラマティックAPIを使用することもできます:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder()
    .inject("com.example.Calculator", new Injection(
        "add",
        "(II)I",
        At.HEAD,
        Arrays.asList(Parameter.THIS, Parameter.INT, Parameter.INT)
    ))
    .build();
</code></pre>
<h2 id="複数のフッククラス"><a class="header" href="#複数のフッククラス">複数のフッククラス</a></h2>
<p>フックを複数のクラスに整理し、すべてを渡します:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(
    LoggingHooks.class,
    AuthenticationHooks.class,
    PerformanceHooks.class,
    SecurityHooks.class
).build();
</code></pre>
<h2 id="クラスの再マッピング"><a class="header" href="#クラスの再マッピング">クラスの再マッピング</a></h2>
<p>マッピングを使用して難読化されたコードを処理します:</p>
<pre><code class="language-java">class MyMappingProvider implements IMappingProvider {
    @Override
    public String getClassName(String name) {
        // a.classをcom.example.Calculatorにマップ
        if ("a".equals(name)) return "com.example.Calculator";
        return name;
    }

    @Override
    public String getMethodName(String className, String methodName, String descriptor) {
        // bをaddにマップ
        if ("com.example.Calculator".equals(className) &amp;&amp; "b".equals(methodName)) {
            return "add";
        }
        return methodName;
    }

    @Override
    public String getFieldName(String className, String fieldName) {
        return fieldName;
    }
}

BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
    .mapping(new MyMappingProvider())
    .build();
</code></pre>
<h2 id="変換のチェーン化"><a class="header" href="#変換のチェーン化">変換のチェーン化</a></h2>
<p>同じクラスに複数の変換を適用します:</p>
<pre><code class="language-java">byte[] original = getClassBytecode("com.example.Service");

// 最初の変換
byte[] step1 = transformer1.transform("com.example.Service", original);

// 2番目の変換
byte[] step2 = transformer2.transform("com.example.Service", step1);

// 最終結果をロード
Class&lt;?&gt; clazz = loadFromBytecode(step2);
</code></pre>
<h2 id="条件付きフックロジック"><a class="header" href="#条件付きフックロジック">条件付きフックロジック</a></h2>
<p>条件に基づいてフックを実行します:</p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
public static CallbackInfo conditionalHook(String input, CallbackInfo ci) {
    // 特定の入力に対してのみインジェクト
    if (input.startsWith("test_")) {
        System.out.println("テストモード: " + input);
    }

    // 特定の環境に対してのみインジェクト
    String env = System.getProperty("app.env", "dev");
    if ("prod".equals(env)) {
        // 本番環境の場合の異なる動作
    }

    return ci;
}
</code></pre>
<h2 id="ステートフルフック"><a class="header" href="#ステートフルフック">ステートフルフック</a></h2>
<p>フックインボケーション間で状態を維持します:</p>
<pre><code class="language-java">@ModifyClass("com.example.RequestHandler")
public class RequestHooks {
    private static final Map&lt;String, Integer&gt; callCounts = new ConcurrentHashMap&lt;&gt;();

    @Inject(methodName = "handle", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
    public static CallbackInfo trackCalls(String id, CallbackInfo ci) {
        int count = callCounts.getOrDefault(id, 0);
        callCounts.put(id, count + 1);

        if (count &gt; 100) {
            System.out.println("高い呼び出し回数: " + id);
        }

        return ci;
    }
}
</code></pre>
<h2 id="複数の変換の組み合わせ"><a class="header" href="#複数の変換の組み合わせ">複数の変換の組み合わせ</a></h2>
<p>同じメソッドに異なる変換タイプを使用します:</p>
<pre><code class="language-java">@ModifyClass("com.example.DataService")
public class ServiceHooks {

    // エントリをログ記録
    @Inject(methodName = "query", methodDesc = "(Ljava/lang/String;)Ljava/util/List;",
            at = At.HEAD)
    public static CallbackInfo logEntry(String sql) {
        System.out.println("クエリ: " + sql);
        return CallbackInfo.empty();
    }

    // データベース呼び出しをインターセプト
    @Invoke(
        targetMethodName = "query",
        targetMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
        invokeMethodName = "execute",
        invokeMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
        shift = Shift.BEFORE
    )
    public static CallbackInfo cacheLookup(String sql, CallbackInfo ci) {
        List&lt;?&gt; cached = getFromCache(sql);
        if (cached != null) {
            ci.cancelled = true;
            ci.returnValue = cached;
        }
        return ci;
    }

    // 定数データベースURLを変更
    @ModifyConstant(methodName = "getConnection", oldValue = "localhost",
                    newValue = "db.production.com")
    public static CallbackInfo updateDbLocation() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="パフォーマンス最適化パターン"><a class="header" href="#パフォーマンス最適化パターン">パフォーマンス最適化パターン</a></h2>
<p>効率的なパフォーマンス監視のためにフックを使用します:</p>
<pre><code class="language-java">@ModifyClass("com.example.CriticalPath")
public class PerformanceHooks {
    private static final int SLOW_THRESHOLD = 1000; // ms

    @Inject(methodName = "criticalOperation", methodDesc = "()V", at = At.HEAD)
    public static CallbackInfo startTimer() {
        TIMER.set(System.currentTimeMillis());
        return CallbackInfo.empty();
    }

    @Inject(methodName = "criticalOperation", methodDesc = "()V", at = At.RETURN)
    public static CallbackInfo checkTimer() {
        long duration = System.currentTimeMillis() - TIMER.get();
        if (duration &gt; SLOW_THRESHOLD) {
            System.out.println("遅い操作: " + duration + "ms");
        }
        return CallbackInfo.empty();
    }

    private static final ThreadLocal&lt;Long&gt; TIMER = ThreadLocal.withInitial(() -&gt; 0L);
}
</code></pre>
<h2 id="セキュリティパターン---入力検証"><a class="header" href="#セキュリティパターン---入力検証">セキュリティパターン - 入力検証</a></h2>
<p>エントリポイントですべての入力を検証します:</p>
<pre><code class="language-java">@ModifyClass("com.example.WebController")
public class SecurityHooks {

    @Inject(methodName = "handleRequest", methodDesc = "(Ljava/lang/String;)V",
            at = At.HEAD)
    public static CallbackInfo validateRequest(String request, CallbackInfo ci) {
        if (request == null || isMalicious(request)) {
            ci.cancelled = true;  // リクエストをブロック
            return ci;
        }
        return ci;
    }

    private static boolean isMalicious(String request) {
        // SQLインジェクション、XSSなどをチェック
        return request.contains("DROP") || request.contains("&lt;script&gt;");
    }
}
</code></pre>
<h2 id="テストパターン---モックオブジェクト"><a class="header" href="#テストパターン---モックオブジェクト">テストパターン - モックオブジェクト</a></h2>
<p>テストで依存性インジェクションのためにフックを使用します:</p>
<pre><code class="language-java">@ModifyClass("com.example.UserService")
public class TestHooks {
    private static UserRepository mockRepository = new MockUserRepository();

    @Inject(methodName = "getUserById", methodDesc = "(I)Lcom/example/User;",
            at = At.HEAD)
    public static CallbackInfo useMockRepository() {
        // モックリポジトリをインジェクト
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="abテストパターン"><a class="header" href="#abテストパターン">A/Bテストパターン</a></h2>
<p>ユーザーに基づいて異なる実装にルーティングします:</p>
<pre><code class="language-java">@ModifyClass("com.example.Algorithm")
public class ABTestingHooks {

    @Invoke(
        targetMethodName = "process",
        targetMethodDesc = "(Ljava/lang/Object;)Ljava/lang/Object;",
        invokeMethodName = "compute",
        invokeMethodDesc = "(Ljava/lang/Object;)Ljava/lang/Object;",
        shift = Shift.BEFORE
    )
    public static CallbackInfo selectImplementation(Object data, CallbackInfo ci) {
        // ユーザーに基づいて新しいまたは古い実装にルーティング
        if (useNewImplementation(data)) {
            ci.returnValue = computeNew(data);
            ci.cancelled = true;
        }
        return ci;
    }

    private static boolean useNewImplementation(Object data) {
        String userId = extractUserId(data);
        int hash = userId.hashCode();
        return hash % 2 == 0;  // 50/50分割
    }
}
</code></pre>
<h2 id="フィーチャーフラグパターン"><a class="header" href="#フィーチャーフラグパターン">フィーチャーフラグパターン</a></h2>
<p>デプロイなしで機能を有効/無効にします:</p>
<pre><code class="language-java">@ModifyClass("com.example.Features")
public class FeatureFlagHooks {
    private static final Map&lt;String, Boolean&gt; flags = new ConcurrentHashMap&lt;&gt;();

    @Inject(methodName = "newFeature", methodDesc = "()V", at = At.HEAD)
    public static CallbackInfo checkFeatureFlag(CallbackInfo ci) {
        if (!isFeatureEnabled("newFeature")) {
            ci.cancelled = true;  // このメソッドをスキップ
        }
        return ci;
    }

    private static boolean isFeatureEnabled(String feature) {
        return flags.getOrDefault(feature, false);
    }

    public static void setFeatureFlag(String feature, boolean enabled) {
        flags.put(feature, enabled);
    }
}
</code></pre>
<h2 id="遅延初期化パターン"><a class="header" href="#遅延初期化パターン">遅延初期化パターン</a></h2>
<p>高コストな初期化を延期します:</p>
<pre><code class="language-java">@ModifyClass("com.example.Config")
public class ConfigHooks {
    private static volatile Configuration config;

    @Inject(methodName = "getConfig", methodDesc = "()Lcom/example/Configuration;",
            at = At.HEAD)
    public static CallbackInfo lazyInitialize(CallbackInfo ci) {
        if (config == null) {
            synchronized (ConfigHooks.class) {
                if (config == null) {
                    config = loadConfiguration();  // 高コストな操作
                }
            }
        }
        ci.cancelled = true;
        ci.returnValue = config;
        return ci;
    }
}
</code></pre>
<h2 id="次のステップ-13"><a class="header" href="#次のステップ-13">次のステップ</a></h2>
<ul>
<li>詳細な<a href="./mappings.html">マッピング</a>を探索</li>
<li><a href="./best-practices.html">ベストプラクティス</a>をレビュー</li>
<li><a href="./examples.html">例</a>をチェック</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="マッピング"><a class="header" href="#マッピング">マッピング</a></h1>
<p>bytekinは難読化または名前変更されたコードを扱うためのクラス名とメソッド名のマッピングをサポートしています。</p>
<h2 id="マッピングとは"><a class="header" href="#マッピングとは">マッピングとは?</a></h2>
<p>マッピングは人間が読める名前とバイトコード名の間を変換します。これは以下の場合に便利です:</p>
<ul>
<li>難読化されたコードを扱う場合</li>
<li>名前変更されたクラスに変換を適用する場合</li>
<li>バージョンの違いを処理する場合</li>
<li>複数の命名規則をサポートする場合</li>
</ul>
<h2 id="マッピングプロバイダーの作成"><a class="header" href="#マッピングプロバイダーの作成">マッピングプロバイダーの作成</a></h2>
<p><code>IMappingProvider</code>インターフェースを実装:</p>
<pre><code class="language-java">public class MyMappingProvider implements IMappingProvider {

    @Override
    public String getClassName(String name) {
        // クラス名をマップ
        if ("OriginalName".equals(name)) {
            return "MappedName";
        }
        return name;
    }

    @Override
    public String getMethodName(String className, String methodName, String descriptor) {
        // クラスとシグネチャに基づいてメソッド名をマップ
        if ("MyClass".equals(className) &amp;&amp; "oldMethod".equals(methodName)) {
            return "newMethod";
        }
        return methodName;
    }

    @Override
    public String getFieldName(String className, String fieldName) {
        // フィールド名をマップ
        if ("MyClass".equals(className) &amp;&amp; "oldField".equals(fieldName)) {
            return "newField";
        }
        return fieldName;
    }
}
</code></pre>
<h2 id="マッピングの使用"><a class="header" href="#マッピングの使用">マッピングの使用</a></h2>
<p>ビルダーにマッピングプロバイダーを渡す:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
    .mapping(new MyMappingProvider())
    .build();
</code></pre>
<h2 id="一般的なマッピングパターン"><a class="header" href="#一般的なマッピングパターン">一般的なマッピングパターン</a></h2>
<h3 id="シンプルな名前変更"><a class="header" href="#シンプルな名前変更">シンプルな名前変更</a></h3>
<pre><code class="language-java">public String getClassName(String name) {
    return name.replace("OldPrefix", "NewPrefix");
}
</code></pre>
<h3 id="ルックアップテーブル"><a class="header" href="#ルックアップテーブル">ルックアップテーブル</a></h3>
<pre><code class="language-java">private static final Map&lt;String, String&gt; classMap = new HashMap&lt;&gt;();

static {
    classMap.put("a", "com.example.ClassA");
    classMap.put("b", "com.example.ClassB");
}

public String getClassName(String name) {
    return classMap.getOrDefault(name, name);
}
</code></pre>
<h3 id="ファイルベースのマッピング"><a class="header" href="#ファイルベースのマッピング">ファイルベースのマッピング</a></h3>
<pre><code class="language-java">public String getClassName(String name) {
    // 設定ファイルから読み込み
    Properties props = loadMappings("mappings.properties");
    return props.getProperty(name, name);
}
</code></pre>
<h2 id="難読化されたコードのマッピング"><a class="header" href="#難読化されたコードのマッピング">難読化されたコードのマッピング</a></h2>
<p>難読化されたコードを扱う場合:</p>
<pre><code class="language-java">public class ObfuscationMapping implements IMappingProvider {

    @Override
    public String getClassName(String name) {
        // a.class -&gt; com.example.MyClass
        switch (name) {
            case "a": return "com.example.MyClass";
            case "b": return "com.example.OtherClass";
            default: return name;
        }
    }

    @Override
    public String getMethodName(String className, String methodName, String descriptor) {
        // a.b() -&gt; MyClass.process()
        if ("com.example.MyClass".equals(className)) {
            switch (methodName) {
                case "b": return "process";
                case "c": return "validate";
                default: return methodName;
            }
        }
        return methodName;
    }
}
</code></pre>
<h2 id="マッピングを使用したフック設定"><a class="header" href="#マッピングを使用したフック設定">マッピングを使用したフック設定</a></h2>
<p>人間が読める名前を使用してフックを書く:</p>
<pre><code class="language-java">@ModifyClass("com.example.UserService")  // 読みやすい名前を使用
public class UserServiceHooks {
    @Inject(methodName = "getUser", methodDesc = "(I)Lcom/example/User;", at = At.HEAD)
    public static CallbackInfo hook() { }
}
</code></pre>
<p>マッピングプロバイダーがバイトコード内の実際のクラス名に変換します。</p>
<h2 id="デフォルト何もしないマッピング"><a class="header" href="#デフォルト何もしないマッピング">デフォルト（何もしない）マッピング</a></h2>
<p>変更されない名前のために空のマッピングを使用:</p>
<pre><code class="language-java">public class EmptyMappingProvider implements IMappingProvider {

    @Override
    public String getClassName(String name) {
        return name;  // 変更なし
    }

    @Override
    public String getMethodName(String className, String methodName, String descriptor) {
        return methodName;  // 変更なし
    }

    @Override
    public String getFieldName(String className, String fieldName) {
        return fieldName;  // 変更なし
    }
}
</code></pre>
<h2 id="応用-バージョン固有のマッピング"><a class="header" href="#応用-バージョン固有のマッピング">応用: バージョン固有のマッピング</a></h2>
<p>複数のバージョンをサポート:</p>
<pre><code class="language-java">public class VersionAwareMappingProvider implements IMappingProvider {
    private final String version;

    public VersionAwareMappingProvider(String version) {
        this.version = version;
    }

    @Override
    public String getClassName(String name) {
        if ("1.0".equals(version)) {
            return mapToV1(name);
        } else if ("2.0".equals(version)) {
            return mapToV2(name);
        }
        return name;
    }

    private String mapToV1(String name) {
        // バージョン1のマッピング
        return name;
    }

    private String mapToV2(String name) {
        // バージョン2のマッピング
        return name;
    }
}
</code></pre>
<h2 id="次のステップ-14"><a class="header" href="#次のステップ-14">次のステップ</a></h2>
<ul>
<li><a href="./advanced-usage.html">高度な使用方法</a>を確認する</li>
<li><a href="./best-practices.html">ベストプラクティス</a>を確認する</li>
<li><a href="./examples.html">例</a>を探索する</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ビルダーパターン"><a class="header" href="#ビルダーパターン">ビルダーパターン</a></h1>
<p>bytekinは、トランスフォーマーをプログラム的に構築するための流暢なビルダーAPIを提供します。</p>
<h2 id="基本的な使用方法-2"><a class="header" href="#基本的な使用方法-2">基本的な使用方法</a></h2>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
    .build();
</code></pre>
<h2 id="マッピングの使用-1"><a class="header" href="#マッピングの使用-1">マッピングの使用</a></h2>
<p>ビルダー構築時に名前マッピングを適用します:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
    .mapping(new CustomMappingProvider())
    .build();
</code></pre>
<h2 id="プログラマティック変換の追加"><a class="header" href="#プログラマティック変換の追加">プログラマティック変換の追加</a></h2>
<p>アノテーションベースとプログラマティック構成を混在させます:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(AnnotationHooks.class)
    .inject("com.example.Extra", new Injection(...))
    .invoke("com.example.Another", new Invocation(...))
    .build();
</code></pre>
<h2 id="複数のフッククラス-1"><a class="header" href="#複数のフッククラス-1">複数のフッククラス</a></h2>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(
    LoggingHooks.class,
    SecurityHooks.class,
    PerformanceHooks.class
)
.mapping(myMappings)
.build();
</code></pre>
<h2 id="ビルダーメソッド"><a class="header" href="#ビルダーメソッド">ビルダーメソッド</a></h2>
<h3 id="mappingimappingprovider"><a class="header" href="#mappingimappingprovider">mapping(IMappingProvider)</a></h3>
<p>クラス/メソッド名変換のためのマッピングプロバイダーを設定します。</p>
<h3 id="injectstring-injection"><a class="header" href="#injectstring-injection">inject(String, Injection)</a></h3>
<p>インジェクション変換をプログラム的に追加します。</p>
<h3 id="invokestring-invocation"><a class="header" href="#invokestring-invocation">invoke(String, Invocation)</a></h3>
<p>インボケーション変換をプログラム的に追加します。</p>
<h3 id="redirectstring-redirectdata"><a class="header" href="#redirectstring-redirectdata">redirect(String, RedirectData)</a></h3>
<p>リダイレクト変換をプログラム的に追加します。</p>
<h3 id="modifyconstantstring-constantmodification"><a class="header" href="#modifyconstantstring-constantmodification">modifyConstant(String, ConstantModification)</a></h3>
<p>定数変更をプログラム的に追加します。</p>
<h3 id="modifyvariablestring-variablemodification"><a class="header" href="#modifyvariablestring-variablemodification">modifyVariable(String, VariableModification)</a></h3>
<p>変数変更をプログラム的に追加します。</p>
<h3 id="build"><a class="header" href="#build">build()</a></h3>
<p>トランスフォーマーをビルドして返します。このメソッドは:</p>
<ol>
<li>すべてのフッククラスをスキャン</li>
<li>アノテーションを抽出</li>
<li>プログラマティック変換を追加</li>
<li>内部トランスフォーマーマップを作成</li>
<li>使用可能なトランスフォーマーを返す</li>
</ol>
<h2 id="ベストプラクティス-5"><a class="header" href="#ベストプラクティス-5">ベストプラクティス</a></h2>
<ol>
<li><strong>一度だけビルド</strong>: 初期化時にトランスフォーマーを作成</li>
<li><strong>再利用</strong>: 複数の変換に同じトランスフォーマーを使用</li>
<li><strong>パターンを組み合わせる</strong>: アノテーションとプログラマティックAPIを混在</li>
<li><strong>構成を文書化</strong>: 特定の変換が適用される理由をコメント</li>
</ol>
<h2 id="パフォーマンスのヒント"><a class="header" href="#パフォーマンスのヒント">パフォーマンスのヒント</a></h2>
<pre><code class="language-java">// 良い: 一度だけビルド
BytekinTransformer transformer = new BytekinTransformer.Builder(Hooks.class).build();

for (String className : classes) {
    byte[] transformed = transformer.transform(className, bytecode);
}

// 悪い: 複数回ビルド
for (String className : classes) {
    BytekinTransformer transformer = new BytekinTransformer.Builder(Hooks.class).build();
    byte[] transformed = transformer.transform(className, bytecode);
}
</code></pre>
<h2 id="次のステップ-15"><a class="header" href="#次のステップ-15">次のステップ</a></h2>
<ul>
<li><a href="./advanced-usage.html">高度な使用方法</a>を学習</li>
<li><a href="./best-practices.html">ベストプラクティス</a>をレビュー</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="カスタムトランスフォーマー"><a class="header" href="#カスタムトランスフォーマー">カスタムトランスフォーマー</a></h1>
<p>アノテーション以外にも、bytekinは高度なユースケースのためにカスタムトランスフォーマーを作成できます。</p>
<h2 id="カスタムトランスフォーマーの作成"><a class="header" href="#カスタムトランスフォーマーの作成">カスタムトランスフォーマーの作成</a></h2>
<p>カスタムロジックを実装して変換システムを拡張できます:</p>
<pre><code class="language-java">public class CustomTransformer implements IBytekinMethodTransformer {
    @Override
    public byte[] transform(byte[] bytecode) {
        // カスタム変換ロジック
        return bytecode;
    }
}
</code></pre>
<h2 id="高度なカスタマイゼーション"><a class="header" href="#高度なカスタマイゼーション">高度なカスタマイゼーション</a></h2>
<p>より複雑なシナリオの場合、ASMビジターパターンを直接使用します:</p>
<pre><code class="language-java">public class AdvancedCustomTransformer extends ClassVisitor {
    public AdvancedCustomTransformer(ClassVisitor cv) {
        super(ASM9, cv);
    }

    @Override
    public MethodVisitor visitMethod(int access, String name, String descriptor,
                                     String signature, String[] exceptions) {
        MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);

        // カスタムメソッドビジターを返す
        return new MethodVisitor(ASM9, mv) {
            @Override
            public void visitCode() {
                // カスタムメソッド計装
                super.visitCode();
            }
        };
    }
}
</code></pre>
<h2 id="カスタムと組み込み変換の組み合わせ"><a class="header" href="#カスタムと組み込み変換の組み合わせ">カスタムと組み込み変換の組み合わせ</a></h2>
<p>カスタムトランスフォーマーとbytekinの組み込み機能を混在させます:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(BuiltInHooks.class)
    .build();

// 後でカスタム変換を適用
byte[] original = getClassBytecode("com.example.MyClass");
byte[] withBuiltIn = transformer.transform("com.example.MyClass", original);
byte[] withCustom = applyCustom(withBuiltIn);
</code></pre>
<h2 id="パフォーマンスの考慮事項-2"><a class="header" href="#パフォーマンスの考慮事項-2">パフォーマンスの考慮事項</a></h2>
<ul>
<li>カスタムトランスフォーマーを効率的に保つ</li>
<li>可能な場合は変換結果をキャッシュ</li>
<li>ホットスポットのためにカスタムコードをプロファイル</li>
</ul>
<h2 id="次のステップ-16"><a class="header" href="#次のステップ-16">次のステップ</a></h2>
<ul>
<li><a href="./advanced-usage.html">高度な使用方法</a>をレビュー</li>
<li><a href="./best-practices.html">ベストプラクティス</a>をチェック</li>
<li><a href="./examples.html">例</a>を探索</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apiリファレンス"><a class="header" href="#apiリファレンス">APIリファレンス</a></h1>
<p>このセクションではbytekinの詳細なAPIドキュメントを提供します。</p>
<h2 id="コアクラス"><a class="header" href="#コアクラス">コアクラス</a></h2>
<h3 id="bytekintransformer"><a class="header" href="#bytekintransformer">BytekinTransformer</a></h3>
<p>バイトコード変換のメインエントリーポイント。</p>
<pre><code class="language-java">public class BytekinTransformer {
    public byte[] transform(String className, byte[] bytes, int api);

    public static class Builder {
        public Builder(Class&lt;?&gt;... classes);
        public Builder mapping(IMappingProvider mapping);
        public Builder inject(String className, Injection injection);
        public Builder invoke(String className, Invocation invocation);
        public Builder redirect(String className, RedirectData redirect);
        public Builder modifyConstant(String className, ConstantModification modification);
        public Builder modifyVariable(String className, VariableModification modification);
        public BytekinTransformer build();
    }
}
</code></pre>
<h3 id="callbackinfo-2"><a class="header" href="#callbackinfo-2">CallbackInfo</a></h3>
<p>フックメソッド内で変換動作を制御します。</p>
<pre><code class="language-java">public class CallbackInfo {
    public boolean cancelled;
    public Object returnValue;
    public Object[] modifyArgs;

    public static CallbackInfo empty();
}
</code></pre>
<h2 id="アノテーション-1"><a class="header" href="#アノテーション-1">アノテーション</a></h2>
<h3 id="modifyclass"><a class="header" href="#modifyclass">@ModifyClass</a></h3>
<p>バイトコード変換のフックコンテナとしてクラスをマークします。</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ModifyClass {
    String className();
}
</code></pre>
<h3 id="inject"><a class="header" href="#inject">@Inject</a></h3>
<p>メソッドの特定の箇所にコードをインジェクトします。</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Inject {
    String methodName();
    String methodDesc();
    At at();
}
</code></pre>
<h3 id="invoke"><a class="header" href="#invoke">@Invoke</a></h3>
<p>メソッド呼び出しをインターセプトします。</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Invoke {
    String targetMethodName();
    String targetMethodDesc();
    String invokeMethodName();
    String invokeMethodDesc();
    Shift shift();
}
</code></pre>
<h3 id="redirect"><a class="header" href="#redirect">@Redirect</a></h3>
<p>メソッド呼び出しを別のターゲットにリダイレクトします。</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Redirect {
    String targetMethodName();
    String targetMethodDesc();
    String redirectMethodName();
    String redirectMethodDesc();
}
</code></pre>
<h3 id="modifyconstant"><a class="header" href="#modifyconstant">@ModifyConstant</a></h3>
<p>バイトコード内の定数値を変更します。</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ModifyConstant {
    String methodName();
    Object oldValue();
    Object newValue();
}
</code></pre>
<h3 id="modifyvariable"><a class="header" href="#modifyvariable">@ModifyVariable</a></h3>
<p>ローカル変数の値を変更します。</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ModifyVariable {
    String methodName();
    int variableIndex();
}
</code></pre>
<h2 id="列挙型"><a class="header" href="#列挙型">列挙型</a></h2>
<h3 id="at"><a class="header" href="#at">At</a></h3>
<p>コードをインジェクトする場所を指定します。</p>
<pre><code class="language-java">public enum At {
    HEAD,      // メソッド本体の前
    RETURN,    // return文の前
    TAIL       // メソッドの終わり
}
</code></pre>
<h3 id="shift"><a class="header" href="#shift">Shift</a></h3>
<p>メソッド呼び出しに対する相対的なタイミングを指定します。</p>
<pre><code class="language-java">public enum Shift {
    BEFORE,    // 呼び出しの前
    AFTER      // 呼び出しの後
}
</code></pre>
<h2 id="インターフェース"><a class="header" href="#インターフェース">インターフェース</a></h2>
<h3 id="imappingprovider"><a class="header" href="#imappingprovider">IMappingProvider</a></h3>
<p>クラス名とメソッド名をマッピングします。</p>
<pre><code class="language-java">public interface IMappingProvider {
    String getClassName(String name);
    String getMethodName(String className, String methodName, String descriptor);
    String getFieldName(String className, String fieldName);
}
</code></pre>
<h2 id="データクラス"><a class="header" href="#データクラス">データクラス</a></h2>
<h3 id="injection-1"><a class="header" href="#injection-1">Injection</a></h3>
<p>インジェクション変換を表します。</p>
<pre><code class="language-java">public class Injection {
    // コンストラクタとメソッド
}
</code></pre>
<h3 id="invocation-1"><a class="header" href="#invocation-1">Invocation</a></h3>
<p>インボケーション変換を表します。</p>
<pre><code class="language-java">public class Invocation {
    // コンストラクタとメソッド
}
</code></pre>
<h3 id="redirectdata"><a class="header" href="#redirectdata">RedirectData</a></h3>
<p>リダイレクト変換を表します。</p>
<pre><code class="language-java">public class RedirectData {
    // コンストラクタとメソッド
}
</code></pre>
<h3 id="constantmodification"><a class="header" href="#constantmodification">ConstantModification</a></h3>
<p>定数変更変換を表します。</p>
<pre><code class="language-java">public class ConstantModification {
    // コンストラクタとメソッド
}
</code></pre>
<h3 id="variablemodification"><a class="header" href="#variablemodification">VariableModification</a></h3>
<p>変数変更変換を表します。</p>
<pre><code class="language-java">public class VariableModification {
    // コンストラクタとメソッド
}
</code></pre>
<h2 id="一般的な例外"><a class="header" href="#一般的な例外">一般的な例外</a></h2>
<h3 id="verifyerror"><a class="header" href="#verifyerror">VerifyError</a></h3>
<p>変換されたバイトコードが無効な場合にスローされます。</p>
<h3 id="classnotfoundexception"><a class="header" href="#classnotfoundexception">ClassNotFoundException</a></h3>
<p>ターゲットクラスが見つからない場合にスローされます。</p>
<h3 id="classformatexception"><a class="header" href="#classformatexception">ClassFormatException</a></h3>
<p>バイトコード形式が無効な場合にスローされます。</p>
<h2 id="ユーティリティクラス"><a class="header" href="#ユーティリティクラス">ユーティリティクラス</a></h2>
<h3 id="descriptorparser"><a class="header" href="#descriptorparser">DescriptorParser</a></h3>
<p>メソッドディスクリプタの解析と検証のためのユーティリティ。</p>
<h3 id="bytecodemanipulator"><a class="header" href="#bytecodemanipulator">BytecodeManipulator</a></h3>
<p>低レベルのバイトコード操作ユーティリティ。</p>
<h2 id="スレッディング"><a class="header" href="#スレッディング">スレッディング</a></h2>
<p>すべてのpublicメソッドは<strong>初期化後はスレッドセーフ</strong>です:</p>
<ul>
<li><code>BytekinTransformer.transform()</code>は複数のスレッドから呼び出し可能</li>
<li><code>Builder</code>は設定中は<strong>スレッドセーフではない</strong></li>
<li><code>CallbackInfo</code>は各フック呼び出しにローカル</li>
</ul>
<h2 id="パフォーマンス特性"><a class="header" href="#パフォーマンス特性">パフォーマンス特性</a></h2>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>複雑さ</th></tr></thead><tbody>
<tr><td>Builder.build()</td><td>O(n) n = フックメソッド数</td></tr>
<tr><td>transform()</td><td>O(m) m = バイトコードサイズ</td></tr>
<tr><td>フックの実行</td><td>平均O(1)</td></tr>
</tbody></table>
</div>
<h2 id="次のステップ-17"><a class="header" href="#次のステップ-17">次のステップ</a></h2>
<ul>
<li><a href="./annotations.html">アノテーション</a>を詳しく確認する</li>
<li><a href="./classes-interfaces.html">クラスとインターフェース</a>を確認する</li>
<li><a href="./examples.html">例</a>を探索する</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="アノテーションリファレンス"><a class="header" href="#アノテーションリファレンス">アノテーションリファレンス</a></h1>
<p>bytekinアノテーションの完全なリファレンスです。</p>
<h2 id="modifyclass-1"><a class="header" href="#modifyclass-1">@ModifyClass</a></h2>
<h3 id="目的"><a class="header" href="#目的">目的</a></h3>
<p>バイトコード変換のためのフックメソッドを含むクラスをマークします。</p>
<h3 id="使用方法"><a class="header" href="#使用方法">使用方法</a></h3>
<pre><code class="language-java">@ModifyClass("com.example.TargetClass")
public class MyHooks {
    // ここにフックメソッド
}
</code></pre>
<h3 id="パラメータ"><a class="header" href="#パラメータ">パラメータ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>パラメータ</th><th>型</th><th>必須</th><th>説明</th></tr></thead><tbody>
<tr><td>className</td><td>String</td><td>はい</td><td>ターゲットクラスの完全修飾名</td></tr>
</tbody></table>
</div>
<h3 id="スコープ"><a class="header" href="#スコープ">スコープ</a></h3>
<p>クラス型にのみ適用されます。</p>
<h2 id="inject-1"><a class="header" href="#inject-1">@Inject</a></h2>
<h3 id="目的-1"><a class="header" href="#目的-1">目的</a></h3>
<p>メソッドの特定の位置にコードをインジェクトします。</p>
<h3 id="使用方法-1"><a class="header" href="#使用方法-1">使用方法</a></h3>
<pre><code class="language-java">@Inject(
    methodName = "myMethod",
    methodDesc = "(I)Ljava/lang/String;",
    at = At.HEAD
)
public static CallbackInfo hook(int param) { }
</code></pre>
<h3 id="パラメータ-1"><a class="header" href="#パラメータ-1">パラメータ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>パラメータ</th><th>型</th><th>必須</th><th>説明</th></tr></thead><tbody>
<tr><td>methodName</td><td>String</td><td>はい</td><td>ターゲットメソッド名</td></tr>
<tr><td>methodDesc</td><td>String</td><td>はい</td><td>メソッドディスクリプタ(JVM形式)</td></tr>
<tr><td>at</td><td>At</td><td>はい</td><td>コードをインジェクトする位置</td></tr>
</tbody></table>
</div>
<h3 id="スコープ-1"><a class="header" href="#スコープ-1">スコープ</a></h3>
<p>メソッドにのみ適用されます。</p>
<h3 id="戻り値の型"><a class="header" href="#戻り値の型">戻り値の型</a></h3>
<p><code>CallbackInfo</code>を返す必要があります。</p>
<h2 id="invoke-1"><a class="header" href="#invoke-1">@Invoke</a></h2>
<h3 id="目的-2"><a class="header" href="#目的-2">目的</a></h3>
<p>メソッド呼び出しをインターセプトします。</p>
<h3 id="使用方法-2"><a class="header" href="#使用方法-2">使用方法</a></h3>
<pre><code class="language-java">@Invoke(
    targetMethodName = "parentMethod",
    targetMethodDesc = "()V",
    invokeMethodName = "childMethod",
    invokeMethodDesc = "(I)V",
    shift = Shift.BEFORE
)
public static CallbackInfo hook() { }
</code></pre>
<h3 id="パラメータ-2"><a class="header" href="#パラメータ-2">パラメータ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>パラメータ</th><th>型</th><th>必須</th><th>説明</th></tr></thead><tbody>
<tr><td>targetMethodName</td><td>String</td><td>はい</td><td>呼び出しを含むメソッド</td></tr>
<tr><td>targetMethodDesc</td><td>String</td><td>はい</td><td>ターゲットメソッドのディスクリプタ</td></tr>
<tr><td>invokeMethodName</td><td>String</td><td>はい</td><td>呼び出されるメソッドの名前</td></tr>
<tr><td>invokeMethodDesc</td><td>String</td><td>はい</td><td>呼び出されるメソッドのディスクリプタ</td></tr>
<tr><td>shift</td><td>Shift</td><td>はい</td><td>呼び出しの前か後か</td></tr>
</tbody></table>
</div>
<h3 id="スコープ-2"><a class="header" href="#スコープ-2">スコープ</a></h3>
<p>メソッドにのみ適用されます。</p>
<h2 id="redirect-1"><a class="header" href="#redirect-1">@Redirect</a></h2>
<h3 id="目的-3"><a class="header" href="#目的-3">目的</a></h3>
<p>メソッド呼び出しを別のターゲットにリダイレクトします。</p>
<h3 id="使用方法-3"><a class="header" href="#使用方法-3">使用方法</a></h3>
<pre><code class="language-java">@Redirect(
    targetMethodName = "oldMethod",
    targetMethodDesc = "()V",
    redirectMethodName = "newMethod",
    redirectMethodDesc = "()V"
)
public static void hook() { }
</code></pre>
<h3 id="パラメータ-3"><a class="header" href="#パラメータ-3">パラメータ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>パラメータ</th><th>型</th><th>必須</th><th>説明</th></tr></thead><tbody>
<tr><td>targetMethodName</td><td>String</td><td>はい</td><td>呼び出しを含むメソッド</td></tr>
<tr><td>targetMethodDesc</td><td>String</td><td>はい</td><td>ターゲットメソッドのディスクリプタ</td></tr>
<tr><td>redirectMethodName</td><td>String</td><td>はい</td><td>リダイレクトメソッドの名前</td></tr>
<tr><td>redirectMethodDesc</td><td>String</td><td>はい</td><td>リダイレクトメソッドのディスクリプタ</td></tr>
</tbody></table>
</div>
<h2 id="modifyconstant-1"><a class="header" href="#modifyconstant-1">@ModifyConstant</a></h2>
<h3 id="目的-4"><a class="header" href="#目的-4">目的</a></h3>
<p>バイトコード内の定数値を変更します。</p>
<h3 id="使用方法-4"><a class="header" href="#使用方法-4">使用方法</a></h3>
<pre><code class="language-java">@ModifyConstant(
    methodName = "getConfig",
    oldValue = "dev",
    newValue = "prod"
)
public static CallbackInfo hook() { }
</code></pre>
<h3 id="パラメータ-4"><a class="header" href="#パラメータ-4">パラメータ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>パラメータ</th><th>型</th><th>必須</th><th>説明</th></tr></thead><tbody>
<tr><td>methodName</td><td>String</td><td>はい</td><td>定数を含むメソッド</td></tr>
<tr><td>oldValue</td><td>Object</td><td>はい</td><td>元の定数値</td></tr>
<tr><td>newValue</td><td>Object</td><td>はい</td><td>新しい定数値</td></tr>
</tbody></table>
</div>
<h2 id="modifyvariable-1"><a class="header" href="#modifyvariable-1">@ModifyVariable</a></h2>
<h3 id="目的-5"><a class="header" href="#目的-5">目的</a></h3>
<p>ローカル変数の値を変更します。</p>
<h3 id="使用方法-5"><a class="header" href="#使用方法-5">使用方法</a></h3>
<pre><code class="language-java">@ModifyVariable(
    methodName = "process",
    variableIndex = 1
)
public static void hook(String param) { }
</code></pre>
<h3 id="パラメータ-5"><a class="header" href="#パラメータ-5">パラメータ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>パラメータ</th><th>型</th><th>必須</th><th>説明</th></tr></thead><tbody>
<tr><td>methodName</td><td>String</td><td>はい</td><td>ターゲットメソッド名</td></tr>
<tr><td>variableIndex</td><td>int</td><td>はい</td><td>ローカル変数スロットのインデックス</td></tr>
</tbody></table>
</div>
<h2 id="列挙型-at"><a class="header" href="#列挙型-at">列挙型: At</a></h2>
<h3 id="値"><a class="header" href="#値">値</a></h3>
<div class="table-wrapper"><table><thead><tr><th>値</th><th>説明</th></tr></thead><tbody>
<tr><td>HEAD</td><td>メソッドの開始位置、すべてのコードの前</td></tr>
<tr><td>RETURN</td><td>各return文の前</td></tr>
<tr><td>TAIL</td><td>メソッドの終了位置</td></tr>
</tbody></table>
</div>
<h2 id="列挙型-shift"><a class="header" href="#列挙型-shift">列挙型: Shift</a></h2>
<h3 id="値-1"><a class="header" href="#値-1">値</a></h3>
<div class="table-wrapper"><table><thead><tr><th>値</th><th>説明</th></tr></thead><tbody>
<tr><td>BEFORE</td><td>メソッド呼び出しの前にフックを実行</td></tr>
<tr><td>AFTER</td><td>メソッド呼び出しの後にフックを実行</td></tr>
</tbody></table>
</div>
<h2 id="次のステップ-18"><a class="header" href="#次のステップ-18">次のステップ</a></h2>
<ul>
<li><a href="./classes-interfaces.html">クラスとインターフェース</a>をレビュー</li>
<li><a href="./api-reference.html">APIリファレンス</a>をチェック</li>
<li><a href="./examples.html">例</a>を探索</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="クラスとインターフェース"><a class="header" href="#クラスとインターフェース">クラスとインターフェース</a></h1>
<p>bytekinのクラスとインターフェースのリファレンスドキュメント。</p>
<h2 id="コアクラス-1"><a class="header" href="#コアクラス-1">コアクラス</a></h2>
<h3 id="bytekintransformer-1"><a class="header" href="#bytekintransformer-1">BytekinTransformer</a></h3>
<p>バイトコード操作のためのメイントランスフォーマークラス。</p>
<p><strong>メソッド:</strong></p>
<ul>
<li><code>byte[] transform(String className, byte[] bytes, int api)</code> - クラスのバイトコードを変換</li>
<li><code>byte[] transform(String className, byte[] bytes)</code> - 変換（デフォルトAPI）</li>
</ul>
<p><strong>ビルダー:</strong></p>
<ul>
<li><code>new BytekinTransformer.Builder(Class&lt;?&gt;... classes)</code> - ビルダーを作成</li>
</ul>
<h3 id="callbackinfo-3"><a class="header" href="#callbackinfo-3">CallbackInfo</a></h3>
<p>変換動作を制御するためのデータ構造。</p>
<p><strong>フィールド:</strong></p>
<ul>
<li><code>boolean cancelled</code> - 元のコード実行をスキップ</li>
<li><code>Object returnValue</code> - カスタム戻り値</li>
<li><code>Object[] modifyArgs</code> - 変更されたメソッド引数</li>
</ul>
<p><strong>メソッド:</strong></p>
<ul>
<li><code>static CallbackInfo empty()</code> - 空のコールバックを作成</li>
<li><code>CallbackInfo(boolean cancelled, Object returnValue, Object[] modifyArgs)</code> - コンストラクタ</li>
</ul>
<h2 id="ビルダークラス"><a class="header" href="#ビルダークラス">ビルダークラス</a></h2>
<h3 id="bytekintransformerbuilder"><a class="header" href="#bytekintransformerbuilder">BytekinTransformer.Builder</a></h3>
<p>トランスフォーマーを構築するための流暢なビルダー。</p>
<p><strong>コンストラクタ:</strong></p>
<ul>
<li><code>Builder(Class&lt;?&gt;... classes)</code> - フッククラスで初期化</li>
</ul>
<p><strong>メソッド:</strong></p>
<ul>
<li><code>Builder mapping(IMappingProvider)</code> - マッピングプロバイダーを設定</li>
<li><code>Builder inject(String, Injection)</code> - インジェクションを追加</li>
<li><code>Builder invoke(String, Invocation)</code> - インボケーションを追加</li>
<li><code>Builder redirect(String, RedirectData)</code> - リダイレクトを追加</li>
<li><code>Builder modifyConstant(String, ConstantModification)</code> - 定数変更を追加</li>
<li><code>Builder modifyVariable(String, VariableModification)</code> - 変数変更を追加</li>
<li><code>BytekinTransformer build()</code> - トランスフォーマーをビルド</li>
</ul>
<h2 id="データクラス-1"><a class="header" href="#データクラス-1">データクラス</a></h2>
<h3 id="injection-2"><a class="header" href="#injection-2">Injection</a></h3>
<p>インジェクションポイントを表します。</p>
<p><strong>目的:</strong> インジェクション設定データを格納。</p>
<h3 id="invocation-2"><a class="header" href="#invocation-2">Invocation</a></h3>
<p>インボケーションポイントを表します。</p>
<p><strong>目的:</strong> インボケーション設定データを格納。</p>
<h3 id="redirectdata-1"><a class="header" href="#redirectdata-1">RedirectData</a></h3>
<p>リダイレクトターゲットを表します。</p>
<p><strong>目的:</strong> リダイレクト設定データを格納。</p>
<h3 id="constantmodification-1"><a class="header" href="#constantmodification-1">ConstantModification</a></h3>
<p>定数の変更を表します。</p>
<p><strong>目的:</strong> 定数変更データを格納。</p>
<h3 id="variablemodification-1"><a class="header" href="#variablemodification-1">VariableModification</a></h3>
<p>変数の変更を表します。</p>
<p><strong>目的:</strong> 変数変更データを格納。</p>
<h2 id="インターフェース-1"><a class="header" href="#インターフェース-1">インターフェース</a></h2>
<h3 id="imappingprovider-1"><a class="header" href="#imappingprovider-1">IMappingProvider</a></h3>
<p>名前マッピングのためのインターフェース。</p>
<p><strong>メソッド:</strong></p>
<ul>
<li><code>String getClassName(String name)</code> - クラス名をマップ</li>
<li><code>String getMethodName(String className, String methodName, String descriptor)</code> - メソッド名をマップ</li>
<li><code>String getFieldName(String className, String fieldName)</code> - フィールド名をマップ</li>
</ul>
<h3 id="実装例"><a class="header" href="#実装例">実装例</a></h3>
<p><strong>EmptyMappingProvider</strong> - 何もしないマッピング（変更されない名前を返す）</p>
<p><strong>カスタムマッピング:</strong></p>
<pre><code class="language-java">public class CustomMapping implements IMappingProvider {
    @Override
    public String getClassName(String name) {
        // カスタムマッピングロジック
        return name;
    }

    @Override
    public String getMethodName(String className, String methodName, String descriptor) {
        // カスタムマッピングロジック
        return methodName;
    }

    @Override
    public String getFieldName(String className, String fieldName) {
        // カスタムマッピングロジック
        return fieldName;
    }
}
</code></pre>
<h2 id="ユーティリティクラス-1"><a class="header" href="#ユーティリティクラス-1">ユーティリティクラス</a></h2>
<h3 id="descriptorparser-1"><a class="header" href="#descriptorparser-1">DescriptorParser</a></h3>
<p>メソッドディスクリプタを解析して検証します。</p>
<p><strong>メソッド:</strong></p>
<ul>
<li><code>static String parseDescriptor(String desc)</code> - ディスクリプタ形式を解析</li>
</ul>
<h3 id="bytecodemanipulator-1"><a class="header" href="#bytecodemanipulator-1">BytecodeManipulator</a></h3>
<p>低レベルのバイトコードユーティリティ。</p>
<p><strong>目的:</strong> バイトコード操作のための内部ユーティリティ。</p>
<h2 id="継承階層"><a class="header" href="#継承階層">継承階層</a></h2>
<pre><code>Object
├── BytekinTransformer
│   └── BytekinTransformer.Builder
├── CallbackInfo
├── Injection
├── Invocation
├── RedirectData
├── ConstantModification
└── VariableModification
</code></pre>
<h2 id="インターフェースの実装"><a class="header" href="#インターフェースの実装">インターフェースの実装</a></h2>
<pre><code>IMappingProvider
├── EmptyMappingProvider
└── （カスタム実装）
</code></pre>
<h2 id="次のステップ-19"><a class="header" href="#次のステップ-19">次のステップ</a></h2>
<ul>
<li><a href="./api-reference.html">APIリファレンス</a>を確認する</li>
<li><a href="./annotations.html">アノテーション</a>を確認する</li>
<li><a href="./examples.html">例</a>を探索する</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="例-3"><a class="header" href="#例-3">例</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="例---基本的な使用方法"><a class="header" href="#例---基本的な使用方法">例 - 基本的な使用方法</a></h1>
<p>このセクションには、一般的なbytekinのユースケースの完全で動作する例が含まれています。</p>
<h2 id="例1-ログの追加"><a class="header" href="#例1-ログの追加">例1: ログの追加</a></h2>
<h3 id="問題"><a class="header" href="#問題">問題</a></h3>
<p>ソースコードを変更せずにメソッドにログを追加する。</p>
<h3 id="解決策"><a class="header" href="#解決策">解決策</a></h3>
<p><strong>ターゲットクラス:</strong></p>
<pre><code class="language-java">package com.example;

public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}
</code></pre>
<p><strong>フッククラス:</strong></p>
<pre><code class="language-java">package com.example;

import io.github.brqnko.bytekin.injection.*;
import io.github.brqnko.bytekin.data.CallbackInfo;

@ModifyClass("com.example.Calculator")
public class CalculatorLoggingHooks {

    @Inject(
        methodName = "add",
        methodDesc = "(II)I",
        at = At.HEAD
    )
    public static CallbackInfo logAddition(int a, int b) {
        System.out.println("Adding: " + a + " + " + b);
        return CallbackInfo.empty();
    }
}
</code></pre>
<p><strong>使用方法:</strong></p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        BytekinTransformer transformer = new BytekinTransformer.Builder(
            CalculatorLoggingHooks.class
        ).build();

        byte[] original = getClassBytecode("com.example.Calculator");
        byte[] transformed = transformer.transform("com.example.Calculator", original);

        Calculator calc = loadTransformed(transformed);
        int result = calc.add(5, 3);
        // 出力:
        // Adding: 5 + 3
        // 8
    }
}
</code></pre>
<h2 id="例2-パラメータ検証"><a class="header" href="#例2-パラメータ検証">例2: パラメータ検証</a></h2>
<h3 id="問題-1"><a class="header" href="#問題-1">問題</a></h3>
<p>実行前にメソッドパラメータを検証する。</p>
<h3 id="解決策-1"><a class="header" href="#解決策-1">解決策</a></h3>
<p><strong>フッククラス:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.UserService")
public class UserValidationHooks {

    @Inject(
        methodName = "createUser",
        methodDesc = "(Ljava/lang/String;I)V",
        at = At.HEAD
    )
    public static CallbackInfo validateUser(String name, int age, CallbackInfo ci) {
        if (name == null || name.isEmpty()) {
            System.out.println("ERROR: Name cannot be empty");
            ci.cancelled = true;
            return ci;
        }

        if (age &lt; 18) {
            System.out.println("ERROR: User must be 18 or older");
            ci.cancelled = true;
            return ci;
        }

        System.out.println("Valid user: " + name + ", age " + age);
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="例3-キャッシング"><a class="header" href="#例3-キャッシング">例3: キャッシング</a></h2>
<h3 id="問題-2"><a class="header" href="#問題-2">問題</a></h3>
<p>キャッシングを実装するためにメソッド呼び出しをインターセプトする。</p>
<h3 id="解決策-2"><a class="header" href="#解決策-2">解決策</a></h3>
<p><strong>フッククラス:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.DataRepository")
public class CachingHooks {
    private static final Map&lt;String, Object&gt; cache = new ConcurrentHashMap&lt;&gt;();

    @Invoke(
        targetMethodName = "fetch",
        targetMethodDesc = "(Ljava/lang/String;)Ljava/lang/Object;",
        invokeMethodName = "queryDatabase",
        invokeMethodDesc = "(Ljava/lang/String;)Ljava/lang/Object;",
        shift = Shift.BEFORE
    )
    public static CallbackInfo checkCache(String key, CallbackInfo ci) {
        Object cached = cache.get(key);
        if (cached != null) {
            System.out.println("Cache hit for: " + key);
            ci.cancelled = true;
            ci.returnValue = cached;
        } else {
            System.out.println("Cache miss for: " + key);
        }
        return ci;
    }
}
</code></pre>
<h2 id="例4-セキュリティ---認証チェック"><a class="header" href="#例4-セキュリティ---認証チェック">例4: セキュリティ - 認証チェック</a></h2>
<h3 id="問題-3"><a class="header" href="#問題-3">問題</a></h3>
<p>すべての機密メソッドに認証が必要であることを確認する。</p>
<h3 id="解決策-3"><a class="header" href="#解決策-3">解決策</a></h3>
<p><strong>フッククラス:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.PaymentService")
public class AuthenticationHooks {

    @Inject(
        methodName = "transfer",
        methodDesc = "(Ljava/lang/String;J)Z",
        at = At.HEAD
    )
    public static CallbackInfo checkAuthentication(String account, long amount, CallbackInfo ci) {
        if (!isUserAuthenticated()) {
            System.out.println("ERROR: Authentication required");
            ci.cancelled = true;
            ci.returnValue = false;
            return ci;
        }

        System.out.println("Authenticated transfer: " + amount);
        return CallbackInfo.empty();
    }

    private static boolean isUserAuthenticated() {
        // 認証状態を確認
        return true;
    }
}
</code></pre>
<h2 id="例5-監視---メソッド呼び出しカウンター"><a class="header" href="#例5-監視---メソッド呼び出しカウンター">例5: 監視 - メソッド呼び出しカウンター</a></h2>
<h3 id="問題-4"><a class="header" href="#問題-4">問題</a></h3>
<p>特定のメソッドが何回呼び出されたかをカウントする。</p>
<h3 id="解決策-4"><a class="header" href="#解決策-4">解決策</a></h3>
<p><strong>フッククラス:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.UserService")
public class MonitoringHooks {
    private static final AtomicInteger callCount = new AtomicInteger(0);

    @Inject(
        methodName = "getUser",
        methodDesc = "(I)Lcom/example/User;",
        at = At.HEAD
    )
    public static CallbackInfo countCalls(int userId) {
        int count = callCount.incrementAndGet();
        if (count % 100 == 0) {
            System.out.println("getUser() called " + count + " times");
        }
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="例6-戻り値の変換"><a class="header" href="#例6-戻り値の変換">例6: 戻り値の変換</a></h2>
<h3 id="問題-5"><a class="header" href="#問題-5">問題</a></h3>
<p>メソッドの戻り値を変更する。</p>
<h3 id="解決策-5"><a class="header" href="#解決策-5">解決策</a></h3>
<p><strong>フッククラス:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.PriceCalculator")
public class PriceHooks {

    @Inject(
        methodName = "getPrice",
        methodDesc = "()D",
        at = At.RETURN
    )
    public static CallbackInfo applyDiscount(CallbackInfo ci) {
        double originalPrice = (double) ci.returnValue;
        double discounted = originalPrice * 0.9;  // 10%割引
        ci.returnValue = discounted;
        return ci;
    }
}
</code></pre>
<h2 id="invokeの例"><a class="header" href="#invokeの例">Invokeの例</a></h2>
<h3 id="例-メソッド呼び出しのインターセプト"><a class="header" href="#例-メソッド呼び出しのインターセプト">例: メソッド呼び出しのインターセプト</a></h3>
<p><strong>フッククラス:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.DataProcessor")
public class ProcessorHooks {

    @Invoke(
        targetMethodName = "process",
        targetMethodDesc = "(Ljava/lang/String;)Ljava/lang/String;",
        invokeMethodName = "validate",
        invokeMethodDesc = "(Ljava/lang/String;)Ljava/lang/String;",
        shift = Shift.BEFORE
    )
    public static CallbackInfo sanitizeBeforeValidation(String data, CallbackInfo ci) {
        String sanitized = data.trim().toLowerCase();
        ci.modifyArgs = new Object[]{sanitized};
        return ci;
    }
}
</code></pre>
<h2 id="組み合わせ例-包括的な変換"><a class="header" href="#組み合わせ例-包括的な変換">組み合わせ例: 包括的な変換</a></h2>
<p><strong>完全なフッククラス:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.UserRepository")
public class ComprehensiveHooks {

    @Inject(
        methodName = "save",
        methodDesc = "(Lcom/example/User;)V",
        at = At.HEAD
    )
    public static CallbackInfo validateBeforeSave(Object user, CallbackInfo ci) {
        // 入力を検証
        if (user == null) {
            System.out.println("ERROR: Cannot save null user");
            ci.cancelled = true;
        }
        return ci;
    }

    @Invoke(
        targetMethodName = "save",
        targetMethodDesc = "(Lcom/example/User;)V",
        invokeMethodName = "validateUser",
        invokeMethodDesc = "(Lcom/example/User;)Z",
        shift = Shift.BEFORE
    )
    public static CallbackInfo modifyValidation(Object user, CallbackInfo ci) {
        // 検証を強化
        System.out.println("Validating user...");
        return ci;
    }

    @Inject(
        methodName = "save",
        methodDesc = "(Lcom/example/User;)V",
        at = At.RETURN
    )
    public static CallbackInfo logSuccess(Object user) {
        System.out.println("User saved successfully");
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="次のステップ-20"><a class="header" href="#次のステップ-20">次のステップ</a></h2>
<ul>
<li><a href="./examples-advanced.html">高度な例</a>を確認する</li>
<li><a href="./best-practices.html">ベストプラクティス</a>を確認する</li>
<li>さらなる<a href="./features.html">機能</a>を探索する</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高度な例"><a class="header" href="#高度な例">高度な例</a></h1>
<p>bytekinの高度なユースケースとパターン。</p>
<h2 id="例1-カスタムclassloader"><a class="header" href="#例1-カスタムclassloader">例1: カスタムClassLoader</a></h2>
<p>変換を適用するカスタムClassLoaderを実装:</p>
<pre><code class="language-java">public class TransformingClassLoader extends ClassLoader {
    private final BytekinTransformer transformer;
    private final ClassLoader parent;

    public TransformingClassLoader(BytekinTransformer transformer, ClassLoader parent) {
        super(parent);
        this.transformer = transformer;
        this.parent = parent;
    }

    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        try {
            byte[] classBytes = loadBytesFromClasspath(name);
            byte[] transformed = transformer.transform(name, classBytes);
            return defineClass(name, transformed, 0, transformed.length);
        } catch (IOException e) {
            throw new ClassNotFoundException("Cannot find " + name, e);
        }
    }

    private byte[] loadBytesFromClasspath(String className) throws IOException {
        String path = className.replace('.', '/') + ".class";
        try (InputStream is = parent.getResourceAsStream(path)) {
            return is.readAllBytes();
        }
    }
}

// 使用方法
BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class).build();
ClassLoader loader = new TransformingClassLoader(transformer, ClassLoader.getSystemClassLoader());
Class&lt;?&gt; clazz = loader.loadClass("com.example.MyClass");
</code></pre>
<h2 id="例2-javaエージェント"><a class="header" href="#例2-javaエージェント">例2: Javaエージェント</a></h2>
<p>バイトコード変換のためのJavaエージェントを作成:</p>
<pre><code class="language-java">public class BytekinAgent {
    public static void premain(String agentArgs, Instrumentation inst) {
        BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class).build();
        inst.addTransformer((loader, className, klass, pd, bytecode) -&gt; {
            return transformer.transform(className, bytecode);
        });
    }
}
</code></pre>
<p>起動: <code>java -javaagent:bytekin-agent.jar MyApplication</code></p>
<h2 id="例3-アスペクト指向プログラミングaop"><a class="header" href="#例3-アスペクト指向プログラミングaop">例3: アスペクト指向プログラミング（AOP）</a></h2>
<p>横断的関心事を実装:</p>
<pre><code class="language-java">@ModifyClass("com.example.UserService")
public class AuditingAspect {

    @Inject(methodName = "save", methodDesc = "(Lcom/example/User;)V", at = At.HEAD)
    public static CallbackInfo auditBefore(Object user) {
        System.out.println("Audit: save() started");
        return CallbackInfo.empty();
    }

    @Inject(methodName = "delete", methodDesc = "(I)V", at = At.HEAD)
    public static CallbackInfo auditDelete(int id) {
        System.out.println("Audit: delete(" + id + ") started");
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="例4-遅延初期化"><a class="header" href="#例4-遅延初期化">例4: 遅延初期化</a></h2>
<p>遅延ローディングパターンを実装:</p>
<pre><code class="language-java">@ModifyClass("com.example.Repository")
public class LazyLoadingHooks {
    private static Object resource;

    @Inject(methodName = "initialize", methodDesc = "()V", at = At.HEAD)
    public static CallbackInfo lazyInit(CallbackInfo ci) {
        if (resource == null) {
            synchronized (LazyLoadingHooks.class) {
                if (resource == null) {
                    resource = loadExpensiveResource();
                }
            }
        }
        ci.cancelled = true;
        return ci;
    }

    private static Object loadExpensiveResource() {
        // 高コストな初期化
        return new Object();
    }
}
</code></pre>
<h2 id="例5-動的設定"><a class="header" href="#例5-動的設定">例5: 動的設定</a></h2>
<p>設定に基づいて動作を変更:</p>
<pre><code class="language-java">@ModifyClass("com.example.Service")
public class DynamicConfigHooks {
    private static final Properties config = new Properties();

    static {
        try {
            config.load(new FileInputStream("config.properties"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Inject(methodName = "process", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
    public static CallbackInfo checkConfig(String input, CallbackInfo ci) {
        boolean enabled = Boolean.parseBoolean(config.getProperty("feature.enabled", "false"));
        if (!enabled) {
            ci.cancelled = true;
        }
        return ci;
    }
}
</code></pre>
<h2 id="例6-多層変換"><a class="header" href="#例6-多層変換">例6: 多層変換</a></h2>
<p>複数のトランスフォーマーを順次適用:</p>
<pre><code class="language-java">public class MultiLayerTransformation {
    public static void main(String[] args) {
        BytekinTransformer logging = new BytekinTransformer.Builder(LoggingHooks.class).build();
        BytekinTransformer security = new BytekinTransformer.Builder(SecurityHooks.class).build();
        BytekinTransformer caching = new BytekinTransformer.Builder(CachingHooks.class).build();

        byte[] original = getClassBytecode("com.example.Service");

        // 層ごとに適用
        byte[] withLogging = logging.transform("com.example.Service", original);
        byte[] withSecurity = security.transform("com.example.Service", withLogging);
        byte[] withCaching = caching.transform("com.example.Service", withSecurity);

        Class&lt;?&gt; transformed = loadClass(withCaching);
    }
}
</code></pre>
<h2 id="例7-パフォーマンスプロファイリング"><a class="header" href="#例7-パフォーマンスプロファイリング">例7: パフォーマンスプロファイリング</a></h2>
<p>ソース変更なしでプロファイリングを追加:</p>
<pre><code class="language-java">@ModifyClass("com.example.CriticalPath")
public class ProfilingHooks {
    private static final ThreadLocal&lt;Long&gt; timer = ThreadLocal.withInitial(() -&gt; 0L);

    @Inject(methodName = "compute", methodDesc = "()Ljava/lang/Object;", at = At.HEAD)
    public static CallbackInfo startProfiling() {
        timer.set(System.nanoTime());
        return CallbackInfo.empty();
    }

    @Inject(methodName = "compute", methodDesc = "()Ljava/lang/Object;", at = At.RETURN)
    public static CallbackInfo endProfiling() {
        long duration = System.nanoTime() - timer.get();
        System.out.println("Duration: " + (duration / 1_000_000.0) + "ms");
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="例8-レジリエンスパターン"><a class="header" href="#例8-レジリエンスパターン">例8: レジリエンスパターン</a></h2>
<p>リトライロジックを追加:</p>
<pre><code class="language-java">@ModifyClass("com.example.HttpClient")
public class ResilienceHooks {
    private static final int MAX_RETRIES = 3;

    @Inject(methodName = "request", methodDesc = "(Ljava/lang/String;)Ljava/lang/String;",
            at = At.HEAD)
    public static CallbackInfo addRetry(String url, CallbackInfo ci) {
        String result = null;
        int attempt = 0;

        while (attempt &lt; MAX_RETRIES) {
            try {
                result = executeRequest(url);
                break;
            } catch (Exception e) {
                attempt++;
                if (attempt &gt;= MAX_RETRIES) throw e;
            }
        }

        ci.cancelled = true;
        ci.returnValue = result;
        return ci;
    }

    private static String executeRequest(String url) throws Exception {
        // HTTPリクエストを実行
        return "";
    }
}
</code></pre>
<h2 id="例9-可観測性"><a class="header" href="#例9-可観測性">例9: 可観測性</a></h2>
<p>メトリクスを収集:</p>
<pre><code class="language-java">@ModifyClass("com.example.DataStore")
public class ObservabilityHooks {
    private static final AtomicLong callCount = new AtomicLong(0);
    private static final AtomicLong errorCount = new AtomicLong(0);

    @Inject(methodName = "query", methodDesc = "(Ljava/lang/String;)Ljava/util/List;",
            at = At.HEAD)
    public static CallbackInfo trackCall(String query) {
        callCount.incrementAndGet();
        return CallbackInfo.empty();
    }

    @Invoke(
        targetMethodName = "query",
        targetMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
        invokeMethodName = "throwException",
        invokeMethodDesc = "()V",
        shift = Shift.BEFORE
    )
    public static CallbackInfo trackError() {
        errorCount.incrementAndGet();
        return CallbackInfo.empty();
    }

    public static void printMetrics() {
        System.out.println("Calls: " + callCount.get());
        System.out.println("Errors: " + errorCount.get());
    }
}
</code></pre>
<h2 id="例10-移行戦略"><a class="header" href="#例10-移行戦略">例10: 移行戦略</a></h2>
<p>古いAPIから新しいAPIへ段階的に移行:</p>
<pre><code class="language-java">@ModifyClass("com.example.Application")
public class MigrationHooks {
    private static final boolean USE_NEW_API = true;

    @Redirect(
        targetMethodName = "main",
        targetMethodDesc = "([Ljava/lang/String;)V",
        redirectMethodName = "oldSearch",
        redirectMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
        from = "search",
        to = USE_NEW_API ? "newSearch" : "oldSearch"
    )
    public static void migrateAPI() {
        // 徐々に新しい実装にルーティング
    }
}
</code></pre>
<h2 id="次のステップ-21"><a class="header" href="#次のステップ-21">次のステップ</a></h2>
<ul>
<li><a href="./best-practices.html">ベストプラクティス</a>を確認する</li>
<li><a href="./troubleshooting.html">トラブルシューティング</a>を確認する</li>
<li><a href="./advanced-usage.html">高度な使用方法</a>を探索する</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ベストプラクティス-6"><a class="header" href="#ベストプラクティス-6">ベストプラクティス</a></h1>
<p>このガイドは、bytekinを効果的かつ安全に使用するためのベストプラクティスをカバーしています。</p>
<h2 id="設計原則"><a class="header" href="#設計原則">設計原則</a></h2>
<h3 id="1-フックをシンプルに保つ"><a class="header" href="#1-フックをシンプルに保つ">1. フックをシンプルに保つ</a></h3>
<p>フックメソッドは集中的でシンプルに保ちます:</p>
<p><strong>良い:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "()V", at = At.HEAD)
public static CallbackInfo log() {
    System.out.println("Starting process");
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>避けるべき:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "()V", at = At.HEAD)
public static CallbackInfo complexLogic() {
    // 複数のデータベース呼び出し
    // 複雑な計算
    // ファイルI/O操作
    // これはフックには多すぎます!
    return CallbackInfo.empty();
}
</code></pre>
<h3 id="2-複雑なロジックを抽出"><a class="header" href="#2-複雑なロジックを抽出">2. 複雑なロジックを抽出</a></h3>
<p>複雑なロジックは別のメソッドに移動:</p>
<pre><code class="language-java">@Inject(methodName = "validate", methodDesc = "(Ljava/lang/String;)Z", at = At.HEAD)
public static CallbackInfo onValidate(String input, CallbackInfo ci) {
    if (!isValidInput(input)) {
        ci.cancelled = true;
        ci.returnValue = false;
    }
    return ci;
}

private static boolean isValidInput(String input) {
    // ここに複雑な検証ロジック
    return !input.isEmpty() &amp;&amp; input.length() &lt; 256;
}
</code></pre>
<h2 id="パフォーマンスガイドライン"><a class="header" href="#パフォーマンスガイドライン">パフォーマンスガイドライン</a></h2>
<h3 id="1-フックオーバーヘッドを最小化"><a class="header" href="#1-フックオーバーヘッドを最小化">1. フックオーバーヘッドを最小化</a></h3>
<p>フックは頻繁に実行されます。高速に保ちます:</p>
<p><strong>良い:</strong></p>
<pre><code class="language-java">@Inject(methodName = "getData", methodDesc = "()Ljava/lang/Object;", at = At.HEAD)
public static CallbackInfo checkCache() {
    if (cacheHit()) {
        // 高速なキャッシュルックアップ
        return new CallbackInfo(true, getFromCache(), null);
    }
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>避けるべき:</strong></p>
<pre><code class="language-java">@Inject(methodName = "getData", methodDesc = "()Ljava/lang/Object;", at = At.HEAD)
public static CallbackInfo expensiveCheck() {
    // データベース全体をスキャン
    List&lt;Item&gt; results = database.queryAll();
    // 結果を処理
    // ...これは遅すぎます!
    return CallbackInfo.empty();
}
</code></pre>
<h3 id="2-builderを再利用"><a class="header" href="#2-builderを再利用">2. Builderを再利用</a></h3>
<p>トランスフォーマーを1回ビルドして再利用:</p>
<p><strong>良い:</strong></p>
<pre><code class="language-java">// 初期化コード内
BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
    .build();

// トランスフォーマーを複数回使用
byte[] transformed1 = transformer.transform("com.example.Class1", bytes1);
byte[] transformed2 = transformer.transform("com.example.Class2", bytes2);
</code></pre>
<p><strong>避けるべき:</strong></p>
<pre><code class="language-java">// ループ内でこれをしないでください!
for (String className : classNames) {
    // 各クラスごとにトランスフォーマーを作成するのは無駄
    BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
        .build();
    byte[] transformed = transformer.transform(className, bytes);
}
</code></pre>
<h2 id="エラーハンドリング"><a class="header" href="#エラーハンドリング">エラーハンドリング</a></h2>
<h3 id="1-フック内で例外を処理"><a class="header" href="#1-フック内で例外を処理">1. フック内で例外を処理</a></h3>
<p>フック内の例外は変換を壊す可能性があります:</p>
<p><strong>良い:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "()V", at = At.HEAD)
public static CallbackInfo safeLogging() {
    try {
        System.out.println("Processing started");
    } catch (Exception e) {
        // 優雅に処理し、伝播させない
        e.printStackTrace();
    }
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>避けるべき:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "()V", at = At.HEAD)
public static CallbackInfo unsafeLogging() {
    // これがスローされると、変換が壊れます!
    Path path = Paths.get("/invalid/path");
    Files.writeString(path, "log");
    return CallbackInfo.empty();
}
</code></pre>
<h3 id="2-戻り値を検証"><a class="header" href="#2-戻り値を検証">2. 戻り値を検証</a></h3>
<p>CallbackInfoを変更する場合、型が正しいことを確認:</p>
<p><strong>良い:</strong></p>
<pre><code class="language-java">@Inject(methodName = "getValue", methodDesc = "()I", at = At.HEAD)
public static CallbackInfo returnCustomValue() {
    CallbackInfo ci = new CallbackInfo();
    ci.cancelled = true;
    ci.returnValue = 42;  // Integerは戻り値型と一致
    return ci;
}
</code></pre>
<p><strong>避けるべき:</strong></p>
<pre><code class="language-java">@Inject(methodName = "getValue", methodDesc = "()I", at = At.HEAD)
public static CallbackInfo wrongType() {
    CallbackInfo ci = new CallbackInfo();
    ci.cancelled = true;
    ci.returnValue = "42";  // Stringはint戻り値型と一致しない!
    return ci;
}
</code></pre>
<h2 id="ドキュメント"><a class="header" href="#ドキュメント">ドキュメント</a></h2>
<h3 id="1-変換をドキュメント化"><a class="header" href="#1-変換をドキュメント化">1. 変換をドキュメント化</a></h3>
<p>各フックが何をするかを明確にドキュメント化:</p>
<pre><code class="language-java">/**
 * すべてのデータアクセスメソッドに認証チェックを追加。
 * ユーザーが認証されていない場合、メソッドをキャンセルしてfalseを返す。
 */
@ModifyClass("com.example.DataStore")
public class DataStoreHooks {

    /**
     * 読み取り操作の開始時に認証チェックをインジェクト。
     *
     * @param ci CallbackInfo - 認証されていない場合cancelled=trueを設定
     */
    @Inject(methodName = "read", methodDesc = "()Ljava/lang/Object;", at = At.HEAD)
    public static CallbackInfo ensureAuthenticated(CallbackInfo ci) {
        if (!isAuthenticated()) {
            ci.cancelled = true;
            ci.returnValue = null;
        }
        return ci;
    }
}
</code></pre>
<h3 id="2-パラメータをドキュメント化"><a class="header" href="#2-パラメータをドキュメント化">2. パラメータをドキュメント化</a></h3>
<p>どのパラメータがメソッド引数に対応するかを明確に示す:</p>
<pre><code class="language-java">/**
 * 処理前にユーザー入力をサニタイズ。
 *
 * @param userId ユーザーID（ターゲットメソッドの第1引数）
 * @param action 要求されたアクション（第2引数）
 */
@Inject(methodName = "execute", methodDesc = "(Ljava/lang/String;Ljava/lang/String;)V",
        at = At.HEAD)
public static CallbackInfo sanitizeInput(String userId, String action) {
    // userIdとactionはターゲットメソッドのパラメータから
    return CallbackInfo.empty();
}
</code></pre>
<h2 id="テスト"><a class="header" href="#テスト">テスト</a></h2>
<h3 id="1-変換をテスト"><a class="header" href="#1-変換をテスト">1. 変換をテスト</a></h3>
<p>常に変換をテスト:</p>
<pre><code class="language-java">public class TransformationTest {
    @Test
    public void testInjectionWorks() {
        BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
            .build();

        byte[] original = getClassBytecode("com.example.Target");
        byte[] transformed = transformer.transform("com.example.Target", original);

        // 変換されたクラスをロードしてテスト
        Class&lt;?&gt; clazz = loadFromBytecode(transformed);
        Object instance = clazz.newInstance();

        // 変換が適用されたことを確認
        assertNotNull(instance);
    }
}
</code></pre>
<h3 id="2-リグレッションがないことを確認"><a class="header" href="#2-リグレッションがないことを確認">2. リグレッションがないことを確認</a></h3>
<p>元の動作が保持されていることを確認:</p>
<pre><code class="language-java">@Test
public void testOriginalBehaviorPreserved() {
    // 変換なしでテスト
    Calculator calc1 = new Calculator();
    int result1 = calc1.add(3, 4);

    // 変換ありでテスト
    byte[] transformed = applyTransformation(Calculator.class);
    Calculator calc2 = loadTransformed(transformed);
    int result2 = calc2.add(3, 4);

    // 結果は同じであるべき
    assertEquals(result1, result2);
}
</code></pre>
<h2 id="互換性"><a class="header" href="#互換性">互換性</a></h2>
<h3 id="1-バージョン互換性"><a class="header" href="#1-バージョン互換性">1. バージョン互換性</a></h3>
<p>サポートされているJavaバージョンをドキュメント化:</p>
<pre><code class="language-java">/**
 * これらのフックはJava 8+で動作
 * バージョン間で互換性のある標準メソッドディスクリプタを使用
 */
@ModifyClass("com.example.Service")
public class CompatibleHooks {
    // ...
}
</code></pre>
<h3 id="2-ライブラリ互換性"><a class="header" href="#2-ライブラリ互換性">2. ライブラリ互換性</a></h3>
<p>他のバイトコードツールとの非互換性を確認:</p>
<pre><code class="language-java">// 他のバイトコード操作との競合をドキュメント化
// 例: Spring、Mockito、AspectJなど
</code></pre>
<h2 id="セキュリティ"><a class="header" href="#セキュリティ">セキュリティ</a></h2>
<h3 id="1-入力検証"><a class="header" href="#1-入力検証">1. 入力検証</a></h3>
<p>フック内で常に入力を検証:</p>
<pre><code class="language-java">@Inject(methodName = "processFile", methodDesc = "(Ljava/lang/String;)V",
        at = At.HEAD)
public static CallbackInfo validatePath(String path, CallbackInfo ci) {
    if (path != null &amp;&amp; isPathTraversal(path)) {
        // ディレクトリトラバーサル攻撃を防ぐ
        ci.cancelled = true;
    }
    return ci;
}

private static boolean isPathTraversal(String path) {
    return path.contains("..") || path.startsWith("/");
}
</code></pre>
<h3 id="2-機密データの露出を避ける"><a class="header" href="#2-機密データの露出を避ける">2. 機密データの露出を避ける</a></h3>
<p>機密情報をログに記録したり露出させたりしない:</p>
<p><strong>良い:</strong></p>
<pre><code class="language-java">@Inject(methodName = "login", methodDesc = "(Ljava/lang/String;Ljava/lang/String;)Z",
        at = At.HEAD)
public static CallbackInfo logAttempt(String user) {
    System.out.println("Login attempt by: " + user);
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>避けるべき:</strong></p>
<pre><code class="language-java">@Inject(methodName = "login", methodDesc = "(Ljava/lang/String;Ljava/lang/String;)Z",
        at = At.HEAD)
public static CallbackInfo logAttempt(String user, String password) {
    // パスワードをログに記録しないでください!
    System.out.println("Login attempt: " + user + " / " + password);
    return CallbackInfo.empty();
}
</code></pre>
<h2 id="デバッグのヒント"><a class="header" href="#デバッグのヒント">デバッグのヒント</a></h2>
<h3 id="1-バイトコード検査"><a class="header" href="#1-バイトコード検査">1. バイトコード検査</a></h3>
<p>生成されたバイトコードを検査して変換を確認:</p>
<pre><code class="language-bash"># javapを使用して変換されたクラスを検査
javap -c TransformedClass.class

# インジェクトされたメソッド呼び出しを探す
</code></pre>
<h3 id="2-ログを追加"><a class="header" href="#2-ログを追加">2. ログを追加</a></h3>
<p>ログを使用して変換の実行を追跡:</p>
<pre><code class="language-java">@Inject(methodName = "critical", methodDesc = "()V", at = At.HEAD)
public static CallbackInfo logEntry() {
    System.out.println("[DEBUG] Entering critical method");
    System.out.println("[DEBUG] Stack trace: " + Arrays.toString(Thread.currentThread().getStackTrace()));
    return CallbackInfo.empty();
}
</code></pre>
<h2 id="メンテナンス"><a class="header" href="#メンテナンス">メンテナンス</a></h2>
<h3 id="1-フックのバージョン管理"><a class="header" href="#1-フックのバージョン管理">1. フックのバージョン管理</a></h3>
<p>フックのバージョンを追跡:</p>
<pre><code class="language-java">/**
 * バージョン2.0の変換フック
 *
 * v1.0からの変更点:
 * - 認証チェックを追加
 * - キャッシング戦略を最適化
 * - レガシーコードのnullポインタ問題を修正
 */
@ModifyClass("com.example.Service")
public class ServiceHooksV2 {
    // ...
}
</code></pre>
<h3 id="2-記録を保持"><a class="header" href="#2-記録を保持">2. 記録を保持</a></h3>
<p>各変換が存在する理由をドキュメント化:</p>
<pre><code>変換: Calculator.add()のログ記録
作成日: 2025-01-15
理由: デバッグビルドのパフォーマンス監視
ステータス: アクティブ
注記: プロファイリングフェーズ後に削除可能
</code></pre>
<h2 id="よくある落とし穴"><a class="header" href="#よくある落とし穴">よくある落とし穴</a></h2>
<h3 id="1-間違ったメソッドディスクリプタ"><a class="header" href="#1-間違ったメソッドディスクリプタ">1. 間違ったメソッドディスクリプタ</a></h3>
<p>❌ <strong>誤り:</strong></p>
<pre><code class="language-java">@Inject(methodName = "add", methodDesc = "(I I)I", at = At.HEAD)  // ディスクリプタ内のスペース!
</code></pre>
<p>✅ <strong>正しい:</strong></p>
<pre><code class="language-java">@Inject(methodName = "add", methodDesc = "(II)I", at = At.HEAD)
</code></pre>
<h3 id="2-型の不一致"><a class="header" href="#2-型の不一致">2. 型の不一致</a></h3>
<p>❌ <strong>誤り:</strong></p>
<pre><code class="language-java">@Invoke(..., invokeMethodDesc = "(I)V", shift = Shift.BEFORE)
public static CallbackInfo hook(String param) {  // 型の不一致!
}
</code></pre>
<p>✅ <strong>正しい:</strong></p>
<pre><code class="language-java">@Invoke(..., invokeMethodDesc = "(I)V", shift = Shift.BEFORE)
public static CallbackInfo hook(int param) {  // 正しい型
}
</code></pre>
<h3 id="3-不変データの変更"><a class="header" href="#3-不変データの変更">3. 不変データの変更</a></h3>
<p>❌ <strong>誤り:</strong></p>
<pre><code class="language-java">@ModifyVariable(methodName = "process", variableIndex = 1)
public static void modify(String str) {
    str = str.toUpperCase();  // Stringは不変、機能しない!
}
</code></pre>
<p>✅ <strong>正しい:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
public static CallbackInfo modifyByReplacing(String str, CallbackInfo ci) {
    ci.modifyArgs = new Object[]{str.toUpperCase()};
    return ci;
}
</code></pre>
<h2 id="次のステップ-22"><a class="header" href="#次のステップ-22">次のステップ</a></h2>
<ul>
<li><a href="./api-reference.html">APIリファレンス</a>を確認する</li>
<li><a href="./examples.html">例</a>を確認する</li>
<li>コミュニティに参加してパターンを共有する</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq---よくある質問"><a class="header" href="#faq---よくある質問">FAQ - よくある質問</a></h1>
<h2 id="一般的な質問"><a class="header" href="#一般的な質問">一般的な質問</a></h2>
<h3 id="bytekinとは何ですか"><a class="header" href="#bytekinとは何ですか">bytekinとは何ですか?</a></h3>
<p>bytekinはASM上に構築された軽量なJavaバイトコード変換フレームワークです。ソースコードに触れることなく、バイトコードレベルでJavaクラスを変更できます。</p>
<h3 id="なぜバイトコード変換が必要なのですか"><a class="header" href="#なぜバイトコード変換が必要なのですか">なぜバイトコード変換が必要なのですか?</a></h3>
<p>一般的なユースケース:</p>
<ul>
<li>ソースコードを変更せずにログを追加</li>
<li>横断的関心事の実装</li>
<li>テストとモック</li>
<li>パフォーマンスプロファイリング</li>
<li>セキュリティ強化</li>
</ul>
<h3 id="bytekinは他のツールとどう違いますか"><a class="header" href="#bytekinは他のツールとどう違いますか">bytekinは他のツールとどう違いますか?</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ツール</th><th>サイズ</th><th>複雑さ</th><th>ユースケース</th></tr></thead><tbody>
<tr><td>bytekin</td><td>小</td><td>シンプル</td><td>直接的なバイトコード操作</td></tr>
<tr><td>Spring AOP</td><td>大</td><td>複雑</td><td>エンタープライズフレームワーク</td></tr>
<tr><td>Mockito</td><td>中</td><td>中</td><td>テスト/モック</td></tr>
<tr><td>Aspect</td><td>中</td><td>複雑</td><td>アスペクト指向プログラミング</td></tr>
</tbody></table>
</div>
<h3 id="bytekinは本番環境対応ですか"><a class="header" href="#bytekinは本番環境対応ですか">bytekinは本番環境対応ですか?</a></h3>
<p>はい、bytekinは本番環境での使用を目的として設計されています。最小限の依存関係（ASMのみ）で、徹底的にテストされています。</p>
<h2 id="技術的な質問"><a class="header" href="#技術的な質問">技術的な質問</a></h2>
<h3 id="bytekinはどのjavaバージョンをサポートしていますか"><a class="header" href="#bytekinはどのjavaバージョンをサポートしていますか">bytekinはどのJavaバージョンをサポートしていますか?</a></h3>
<p>bytekinは<strong>Java 8以降</strong>が必要です。</p>
<h3 id="bytekinをspring-bootと一緒に使用できますか"><a class="header" href="#bytekinをspring-bootと一緒に使用できますか">bytekinをSpring Bootと一緒に使用できますか?</a></h3>
<p>はい! bytekinはSpring Bootと並行して動作できます。通常、カスタム<code>ClassLoader</code>セットアップ中またはビルド時に変換を適用します。</p>
<h3 id="bytekinは難読化されたコードで動作しますか"><a class="header" href="#bytekinは難読化されたコードで動作しますか">bytekinは難読化されたコードで動作しますか?</a></h3>
<p>はい、マッピングで! 難読化されたクラス名とメソッド名を処理するためにマッピングシステムを使用します。</p>
<h3 id="複数の変換を組み合わせることはできますか"><a class="header" href="#複数の変換を組み合わせることはできますか">複数の変換を組み合わせることはできますか?</a></h3>
<p>はい! 同じクラスに複数の<code>@Inject</code>、<code>@Invoke</code>、その他のアノテーションを使用できます。すべてが適用されます。</p>
<h2 id="使用方法に関する質問"><a class="header" href="#使用方法に関する質問">使用方法に関する質問</a></h2>
<h3 id="メソッドのメソッドディスクリプタを見つけるにはどうすればよいですか"><a class="header" href="#メソッドのメソッドディスクリプタを見つけるにはどうすればよいですか">メソッドのメソッドディスクリプタを見つけるにはどうすればよいですか?</a></h3>
<p><code>javap</code>を使用:</p>
<pre><code class="language-bash">javap -c MyClass.class
</code></pre>
<p>メソッドシグネチャを確認し、JVMディスクリプタ形式に変換します:</p>
<ul>
<li><code>int add(int a, int b)</code> → <code>(II)I</code></li>
<li><code>String process(String s)</code> → <code>(Ljava/lang/String;)Ljava/lang/String;</code></li>
</ul>
<h3 id="injectとinvokeの違いは何ですか"><a class="header" href="#injectとinvokeの違いは何ですか">InjectとInvokeの違いは何ですか?</a></h3>
<ul>
<li><strong>Inject</strong>: メソッドの特定の箇所にコードを挿入</li>
<li><strong>Invoke</strong>: メソッド内のメソッド呼び出しをインターセプトし、必要に応じて引数を変更</li>
</ul>
<h3 id="メソッドの実行をキャンセルできますか"><a class="header" href="#メソッドの実行をキャンセルできますか">メソッドの実行をキャンセルできますか?</a></h3>
<p>はい、フックメソッドで<code>ci.cancelled = true</code>を設定します。ただし、これは特定の変換タイプでのみ機能します。</p>
<h3 id="メソッド引数を変更するにはどうすればよいですか"><a class="header" href="#メソッド引数を変更するにはどうすればよいですか">メソッド引数を変更するにはどうすればよいですか?</a></h3>
<p><code>CallbackInfo.modifyArgs</code>を使用:</p>
<pre><code class="language-java">ci.modifyArgs = new Object[]{ modifiedArg1, modifiedArg2 };
</code></pre>
<h3 id="フックメソッドから静的フィールドにアクセスできますか"><a class="header" href="#フックメソッドから静的フィールドにアクセスできますか">フックメソッドから静的フィールドにアクセスできますか?</a></h3>
<p>はい、フッククラスから静的フィールドを参照できます:</p>
<pre><code class="language-java">@Inject(...)
public static CallbackInfo hook() {
    // 静的フィールドにアクセス
    if (cacheEnabled) {
        // ...
    }
}
</code></pre>
<h2 id="パフォーマンスに関する質問"><a class="header" href="#パフォーマンスに関する質問">パフォーマンスに関する質問</a></h2>
<h3 id="bytekinを使用するオーバーヘッドは何ですか"><a class="header" href="#bytekinを使用するオーバーヘッドは何ですか">bytekinを使用するオーバーヘッドは何ですか?</a></h3>
<ul>
<li><strong>変換時間</strong>: 最小限、クラスロード時に1回のみ発生</li>
<li><strong>ランタイムオーバーヘッド</strong>: ゼロ! 変換されたバイトコードは手書きのコードと同じ速度で実行</li>
</ul>
<h3 id="各変換ごとにトランスフォーマーを再ビルドする必要がありますか"><a class="header" href="#各変換ごとにトランスフォーマーを再ビルドする必要がありますか">各変換ごとにトランスフォーマーを再ビルドする必要がありますか?</a></h3>
<p>いいえ! 1回ビルドして再利用:</p>
<pre><code class="language-java">// 良い
BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class).build();
for (String className : classNames) {
    byte[] transformed = transformer.transform(className, bytecode);
}

// 悪い
for (String className : classNames) {
    BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class).build();
    byte[] transformed = transformer.transform(className, bytecode);
}
</code></pre>
<h3 id="バイトコード変換は起動時間にどれだけ影響しますか"><a class="header" href="#バイトコード変換は起動時間にどれだけ影響しますか">バイトコード変換は起動時間にどれだけ影響しますか?</a></h3>
<p>変換がシンプルで、必要なクラスにのみ適用される場合、影響は最小限です。</p>
<h2 id="トラブルシューティングの質問"><a class="header" href="#トラブルシューティングの質問">トラブルシューティングの質問</a></h2>
<h3 id="変換が適用されていません"><a class="header" href="#変換が適用されていません">変換が適用されていません</a></h3>
<p>一般的な原因:</p>
<ol>
<li><strong>間違ったクラス名</strong>: <code>@ModifyClass</code>の値が正確に一致することを確認</li>
<li><strong>間違ったメソッドディスクリプタ</strong>: <code>methodDesc</code>パラメータを確認</li>
<li><strong>クラスが読み込まれていない</strong>: 変換前にクラスがロードされることを確認</li>
</ol>
<h3 id="classcastexceptionが発生します"><a class="header" href="#classcastexceptionが発生します">ClassCastExceptionが発生します</a></h3>
<p>これは通常、以下を意味します:</p>
<ol>
<li><code>CallbackInfo.returnValue</code>の型不一致</li>
<li>フックメソッドシグネチャの間違った型</li>
<li>互換性のない型への引数の変更</li>
</ol>
<h3 id="フックメソッドが呼び出されていません"><a class="header" href="#フックメソッドが呼び出されていません">フックメソッドが呼び出されていません</a></h3>
<p>確認事項:</p>
<ol>
<li>フッククラスがBuilderに渡されていますか?</li>
<li>メソッド名とディスクリプタは正しいですか?</li>
<li>ターゲットクラス名は正しいですか?</li>
</ol>
<h3 id="javalangverifyerror"><a class="header" href="#javalangverifyerror">java.lang.VerifyError</a></h3>
<p>これは変換されたバイトコードが無効であることを意味します。一般的な原因:</p>
<ol>
<li>不正なバイトコード変更</li>
<li>型の不一致</li>
<li>無効なメソッドシグネチャ</li>
</ol>
<h3 id="変換後のパフォーマンス低下"><a class="header" href="#変換後のパフォーマンス低下">変換後のパフォーマンス低下</a></h3>
<p>変換が遅い場合:</p>
<ol>
<li>フックメソッドを簡素化</li>
<li>フック内の高コストな操作を避ける</li>
<li>条件ロジックを使用して不要な作業をスキップ</li>
<li>JVMプロファイラーでプロファイル</li>
</ol>
<h2 id="高度な質問"><a class="header" href="#高度な質問">高度な質問</a></h2>
<h3 id="カスタムトランスフォーマーを作成できますか"><a class="header" href="#カスタムトランスフォーマーを作成できますか">カスタムトランスフォーマーを作成できますか?</a></h3>
<p>はい! トランスフォーマークラスを拡張するか、アノテーションの代わりにプログラマティックAPIを使用できます。</p>
<h3 id="bytekinはメソッドのオーバーロードをサポートしていますか"><a class="header" href="#bytekinはメソッドのオーバーロードをサポートしていますか">bytekinはメソッドのオーバーロードをサポートしていますか?</a></h3>
<p>はい、パラメータ型と戻り値型を含む完全なメソッドディスクリプタを使用することでサポートしています。</p>
<h3 id="同じクラスを複数回変換できますか"><a class="header" href="#同じクラスを複数回変換できますか">同じクラスを複数回変換できますか?</a></h3>
<p>はい、異なる変換を順次適用できます。</p>
<h3 id="bytekinはスレッドセーフですか"><a class="header" href="#bytekinはスレッドセーフですか">bytekinはスレッドセーフですか?</a></h3>
<p>ビルド後、<code>BytekinTransformer.transform()</code>はスレッドセーフで、複数のスレッドから同時に呼び出すことができます。</p>
<h3 id="bytekinをjavaエージェントと一緒に使用できますか"><a class="header" href="#bytekinをjavaエージェントと一緒に使用できますか">bytekinをJavaエージェントと一緒に使用できますか?</a></h3>
<p>はい! bytekinはJavaエージェントとうまく動作します。エージェントの<code>transform()</code>メソッド内で使用します。</p>
<h2 id="移行とアップグレードに関する質問"><a class="header" href="#移行とアップグレードに関する質問">移行とアップグレードに関する質問</a></h2>
<h3 id="他のバイトコードツールから移行するにはどうすればよいですか"><a class="header" href="#他のバイトコードツールから移行するにはどうすればよいですか">他のバイトコードツールから移行するにはどうすればよいですか?</a></h3>
<p>概念は似ています:</p>
<ol>
<li>ターゲットクラスを定義</li>
<li>変換アノテーション付きフックメソッドを作成</li>
<li>トランスフォーマーをビルド</li>
<li>変換を適用</li>
</ol>
<h3 id="コードを変更せずにbytekinをアップグレードできますか"><a class="header" href="#コードを変更せずにbytekinをアップグレードできますか">コードを変更せずにbytekinをアップグレードできますか?</a></h3>
<p>はい、bytekinは下位互換性を維持しています。アップグレード前に常にリリースノートを確認してください。</p>
<h2 id="ライセンスと法的質問"><a class="header" href="#ライセンスと法的質問">ライセンスと法的質問</a></h2>
<h3 id="bytekinはどのライセンスの下にありますか"><a class="header" href="#bytekinはどのライセンスの下にありますか">bytekinはどのライセンスの下にありますか?</a></h3>
<p>bytekinは<strong>Apache License 2.0</strong>の下でライセンスされています。</p>
<h3 id="bytekinを商用プロジェクトで使用できますか"><a class="header" href="#bytekinを商用プロジェクトで使用できますか">bytekinを商用プロジェクトで使用できますか?</a></h3>
<p>はい! Apache 2.0は商用利用を許可しています。</p>
<h3 id="bytekinを使用する場合コードをオープンソース化する必要がありますか"><a class="header" href="#bytekinを使用する場合コードをオープンソース化する必要がありますか">bytekinを使用する場合、コードをオープンソース化する必要がありますか?</a></h3>
<p>いいえ、Apache 2.0はコードのオープンソース化を要求しません。ライセンス通知を含めるだけです。</p>
<h2 id="コミュニティに関する質問"><a class="header" href="#コミュニティに関する質問">コミュニティに関する質問</a></h2>
<h3 id="バグを報告するにはどうすればよいですか"><a class="header" href="#バグを報告するにはどうすればよいですか">バグを報告するにはどうすればよいですか?</a></h3>
<p><a href="https://github.com/brqnko/bytekin/issues">GitHub Issues</a>ページでバグを報告してください。</p>
<h3 id="どのように貢献できますか"><a class="header" href="#どのように貢献できますか">どのように貢献できますか?</a></h3>
<p>貢献は歓迎します! 貢献ガイドラインについてはGitHubリポジトリを参照してください。</p>
<h3 id="どこで助けを得ることができますか"><a class="header" href="#どこで助けを得ることができますか">どこで助けを得ることができますか?</a></h3>
<ul>
<li><a href="./introduction.html">ドキュメント</a>を確認</li>
<li><a href="https://github.com/brqnko/bytekin/issues">GitHub Issues</a>を検索</li>
<li><a href="./examples.html">例</a>を確認</li>
</ul>
<h2 id="まだ質問がありますか"><a class="header" href="#まだ質問がありますか">まだ質問がありますか?</a></h2>
<p>質問がここで回答されていない場合:</p>
<ol>
<li><a href="./api-reference.html">APIリファレンス</a>を確認</li>
<li><a href="./best-practices.html">ベストプラクティス</a>を確認</li>
<li><a href="./examples.html">例</a>を確認</li>
<li>GitHubでissueを開く</li>
</ol>
<h2 id="次のステップ-23"><a class="header" href="#次のステップ-23">次のステップ</a></h2>
<ul>
<li><a href="./examples.html">例</a>を探索する</li>
<li><a href="./best-practices.html">ベストプラクティス</a>を確認する</li>
<li><a href="./troubleshooting.html">トラブルシューティング</a>を確認する</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="トラブルシューティングガイド"><a class="header" href="#トラブルシューティングガイド">トラブルシューティングガイド</a></h1>
<p>このガイドは、bytekin使用時の一般的な問題を解決するのに役立ちます。</p>
<h2 id="変換が適用されない"><a class="header" href="#変換が適用されない">変換が適用されない</a></h2>
<h3 id="症状"><a class="header" href="#症状">症状</a></h3>
<ul>
<li>フックメソッドが呼び出されない</li>
<li>元のコードが変更なしで実行される</li>
<li>フック内のブレークポイントが到達されない</li>
</ul>
<h3 id="原因と解決策"><a class="header" href="#原因と解決策">原因と解決策</a></h3>
<h4 id="1-不正なクラス名"><a class="header" href="#1-不正なクラス名">1. 不正なクラス名</a></h4>
<p><code>@ModifyClass</code>の値はバイトコードのクラス名と正確に一致する必要があります。</p>
<p><strong>問題:</strong></p>
<pre><code class="language-java">@ModifyClass("Calculator")  // 誤り!
public class CalcHooks { }
</code></pre>
<p><strong>解決策:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.Calculator")  // 正しい
public class CalcHooks { }
</code></pre>
<p><strong>確認方法:</strong></p>
<pre><code class="language-bash"># JAR内のすべてのクラスをリスト
jar tf myapp.jar | grep -i calculator
</code></pre>
<h4 id="2-間違ったメソッドディスクリプタ"><a class="header" href="#2-間違ったメソッドディスクリプタ">2. 間違ったメソッドディスクリプタ</a></h4>
<p><code>methodDesc</code>はバイトコード内のメソッドシグネチャと正確に一致する必要があります。</p>
<p><strong>問題:</strong></p>
<pre><code class="language-java">// バイトコード内のメソッド: public int add(int a, int b)
@Inject(methodName = "add", methodDesc = "(int, int)int", at = At.HEAD)  // 誤り!
public static CallbackInfo hook() { }
</code></pre>
<p><strong>解決策:</strong></p>
<pre><code class="language-java">@Inject(methodName = "add", methodDesc = "(II)I", at = At.HEAD)  // 正しい
public static CallbackInfo hook() { }
</code></pre>
<p><strong>正しいディスクリプタの見つけ方:</strong></p>
<pre><code class="language-bash"># javapを使用してメソッドシグネチャを確認
javap -c com.example.Calculator | grep -A 5 "public int add"
</code></pre>
<h4 id="3-フッククラスがbuilderに渡されていない"><a class="header" href="#3-フッククラスがbuilderに渡されていない">3. フッククラスがBuilderに渡されていない</a></h4>
<p>フッククラスはBuilderに渡す必要があります。</p>
<p><strong>問題:</strong></p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder()
    .build();  // フックはどこ?
</code></pre>
<p><strong>解決策:</strong></p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
    .build();  // フッククラスを渡す
</code></pre>
<h4 id="4-クラスがまだロードされていない"><a class="header" href="#4-クラスがまだロードされていない">4. クラスがまだロードされていない</a></h4>
<p>変換は、JVMがクラスをロードする前に適用する必要があります。</p>
<p><strong>問題:</strong></p>
<pre><code class="language-java">// クラスがすでにロード済み
Class&lt;?&gt; clazz = Class.forName("com.example.MyClass");

// 今変換しようとしている - 遅すぎる!
byte[] transformed = transformer.transform("com.example.MyClass", bytecode);
</code></pre>
<p><strong>解決策:</strong></p>
<ul>
<li>ロード中に変換を適用するカスタム<code>ClassLoader</code>を使用</li>
<li>またはクラスロードをインターセプトするJava instrumentation/agentsを使用</li>
</ul>
<h2 id="型不一致エラー"><a class="header" href="#型不一致エラー">型不一致エラー</a></h2>
<h3 id="症状-1"><a class="header" href="#症状-1">症状</a></h3>
<ul>
<li><code>java.lang.ClassCastException</code></li>
<li>メソッドから誤った値が返される</li>
<li>型の非互換性エラー</li>
</ul>
<h3 id="一般的な原因"><a class="header" href="#一般的な原因">一般的な原因</a></h3>
<h4 id="1-callbackinfoの間違った戻り値型"><a class="header" href="#1-callbackinfoの間違った戻り値型">1. CallbackInfoの間違った戻り値型</a></h4>
<p><strong>問題:</strong></p>
<pre><code class="language-java">@Inject(methodName = "getCount", methodDesc = "()I", at = At.HEAD)
public static CallbackInfo wrongReturn() {
    CallbackInfo ci = new CallbackInfo();
    ci.cancelled = true;
    ci.returnValue = "42";  // intの代わりにString!
    return ci;
}
</code></pre>
<p><strong>解決策:</strong></p>
<pre><code class="language-java">@Inject(methodName = "getCount", methodDesc = "()I", at = At.HEAD)
public static CallbackInfo correctReturn() {
    CallbackInfo ci = new CallbackInfo();
    ci.cancelled = true;
    ci.returnValue = 42;  // 正しい: int
    return ci;
}
</code></pre>
<h4 id="2-フックメソッドの間違ったパラメータ型"><a class="header" href="#2-フックメソッドの間違ったパラメータ型">2. フックメソッドの間違ったパラメータ型</a></h4>
<p><strong>問題:</strong></p>
<pre><code class="language-java">// ターゲットメソッド: void process(int count, String name)
@Inject(methodName = "process", methodDesc = "(ILjava/lang/String;)V", at = At.HEAD)
public static CallbackInfo wrongParams(String name, int count) {  // 逆!
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>解決策:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "(ILjava/lang/String;)V", at = At.HEAD)
public static CallbackInfo correctParams(int count, String name) {  // 正しい順序
    return CallbackInfo.empty();
}
</code></pre>
<h4 id="3-引数を間違った型に変更"><a class="header" href="#3-引数を間違った型に変更">3. 引数を間違った型に変更</a></h4>
<p><strong>問題:</strong></p>
<pre><code class="language-java">@Invoke(..., shift = Shift.BEFORE)
public static CallbackInfo wrongArgType() {
    CallbackInfo ci = new CallbackInfo();
    ci.modifyArgs = new Object[]{"100"};  // intの代わりにString
    return ci;
}
</code></pre>
<p><strong>解決策:</strong></p>
<pre><code class="language-java">@Invoke(..., shift = Shift.BEFORE)
public static CallbackInfo correctArgType() {
    CallbackInfo ci = new CallbackInfo();
    ci.modifyArgs = new Object[]{100};  // 正しい: int
    return ci;
}
</code></pre>
<h2 id="ヌルポインタ例外"><a class="header" href="#ヌルポインタ例外">ヌルポインタ例外</a></h2>
<h3 id="症状-2"><a class="header" href="#症状-2">症状</a></h3>
<ul>
<li>変換中のNPE</li>
<li>変換されたメソッド呼び出し時のNPE</li>
<li>バイトコードから発生するスタックトレース</li>
</ul>
<h3 id="原因と解決策-1"><a class="header" href="#原因と解決策-1">原因と解決策</a></h3>
<h4 id="1-インジェクションからnullを返す"><a class="header" href="#1-インジェクションからnullを返す">1. インジェクションからnullを返す</a></h4>
<p><strong>問題:</strong></p>
<pre><code class="language-java">@Inject(methodName = "getValue", methodDesc = "()Ljava/lang/String;", at = At.HEAD)
public static CallbackInfo returnNull() {
    CallbackInfo ci = new CallbackInfo();
    ci.cancelled = true;
    ci.returnValue = null;  // オブジェクトには有効だが、期待されていない可能性
    return ci;
}
</code></pre>
<p><strong>解決策:</strong></p>
<ul>
<li>nullが返される可能性があることを文書化</li>
<li>または代わりにデフォルト値を返す:</li>
</ul>
<pre><code class="language-java">ci.returnValue = "";  // nullの代わりに空文字列
</code></pre>
<h4 id="2-フック内でnullパラメータにアクセス"><a class="header" href="#2-フック内でnullパラメータにアクセス">2. フック内でnullパラメータにアクセス</a></h4>
<p><strong>問題:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
public static CallbackInfo unsafeAccess(String input) {
    System.out.println(input.length());  // inputがnullの場合NPE!
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>解決策:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
public static CallbackInfo safeAccess(String input) {
    if (input != null) {
        System.out.println(input.length());
    }
    return CallbackInfo.empty();
}
</code></pre>
<h2 id="パフォーマンスの問題"><a class="header" href="#パフォーマンスの問題">パフォーマンスの問題</a></h2>
<h3 id="症状-3"><a class="header" href="#症状-3">症状</a></h3>
<ul>
<li>アプリケーションの起動が遅い</li>
<li>メモリ使用量が多い</li>
<li>応答時間が低下</li>
</ul>
<h3 id="原因と解決策-2"><a class="header" href="#原因と解決策-2">原因と解決策</a></h3>
<h4 id="1-複雑なフックメソッド"><a class="header" href="#1-複雑なフックメソッド">1. 複雑なフックメソッド</a></h4>
<p><strong>問題:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "()V", at = At.HEAD)
public static CallbackInfo slowHook() {
    // データベースクエリ
    List&lt;Item&gt; items = database.queryAll();
    // ファイルI/O
    Files.write(Paths.get("log.txt"), data);
    // 高コストな計算
    // ...
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>解決策:</strong></p>
<ul>
<li>フックをシンプルで高速に保つ</li>
<li>高コストな作業をバックグラウンドスレッドに延期</li>
<li>リソースの遅延初期化を使用</li>
</ul>
<h4 id="2-トランスフォーマーの繰り返しビルド"><a class="header" href="#2-トランスフォーマーの繰り返しビルド">2. トランスフォーマーの繰り返しビルド</a></h4>
<p><strong>問題:</strong></p>
<pre><code class="language-java">for (String className : classNames) {
    // 各クラスごとに新しいトランスフォーマーを作成!
    BytekinTransformer transformer = new BytekinTransformer.Builder(Hooks.class)
        .build();
    transformer.transform(className, bytecode);
}
</code></pre>
<p><strong>解決策:</strong></p>
<pre><code class="language-java">// 1回ビルドして、何度も再利用
BytekinTransformer transformer = new BytekinTransformer.Builder(Hooks.class)
    .build();

for (String className : classNames) {
    transformer.transform(className, bytecode);
}
</code></pre>
<h4 id="3-不要なクラスの変換"><a class="header" href="#3-不要なクラスの変換">3. 不要なクラスの変換</a></h4>
<p><strong>問題:</strong></p>
<pre><code class="language-java">// 必要ない場合でも、すべてのクラスに変換を適用
for (String className : allClasses) {
    byte[] transformed = transformer.transform(className, bytecode);
}
</code></pre>
<p><strong>解決策:</strong></p>
<ul>
<li>必要な特定のクラスのみを変換</li>
<li>フィルタリング/命名パターンを使用</li>
<li>ホットスポットを特定するためにプロファイル</li>
</ul>
<h2 id="バイトコード検証エラー"><a class="header" href="#バイトコード検証エラー">バイトコード検証エラー</a></h2>
<h3 id="症状-4"><a class="header" href="#症状-4">症状</a></h3>
<ul>
<li>クラスロード時の<code>java.lang.VerifyError</code></li>
<li>「Illegal type at offset X」エラー</li>
<li>スタックトレースが解釈困難</li>
</ul>
<h3 id="一般的な原因-1"><a class="header" href="#一般的な原因-1">一般的な原因</a></h3>
<h4 id="1-無効なバイトコード変更"><a class="header" href="#1-無効なバイトコード変更">1. 無効なバイトコード変更</a></h4>
<p>これは通常、変換が無効なバイトコードを作成したことを意味します。</p>
<p><strong>デバッグ方法:</strong></p>
<ol>
<li><code>javap</code>を使用して変換されたバイトコードを検査</li>
<li>異常な命令シーケンスを探す</li>
<li>戻り値型が一致することを確認</li>
</ol>
<h4 id="2-不正なメソッドディスクリプタ"><a class="header" href="#2-不正なメソッドディスクリプタ">2. 不正なメソッドディスクリプタ</a></h4>
<p>不正なディスクリプタは検証失敗を引き起こす可能性があります。</p>
<p><strong>解決策:</strong></p>
<ul>
<li>すべてのメソッドディスクリプタを再確認</li>
<li>確認のためにオンラインディスクリプタコンバータを使用</li>
<li><code>javap</code>出力と比較</li>
</ul>
<h2 id="メソッドが見つからない"><a class="header" href="#メソッドが見つからない">メソッドが見つからない</a></h2>
<h3 id="症状-5"><a class="header" href="#症状-5">症状</a></h3>
<ul>
<li>特定のメソッドが変換されていない</li>
<li>オーバーロードされたメソッドが問題を引き起こす</li>
<li>コンストラクタ変換が失敗</li>
</ul>
<h3 id="原因と解決策-3"><a class="header" href="#原因と解決策-3">原因と解決策</a></h3>
<h4 id="1-オーバーロードされたメソッド"><a class="header" href="#1-オーバーロードされたメソッド">1. オーバーロードされたメソッド</a></h4>
<p>オーバーロードされたメソッドは完全なディスクリプタで区別する必要があります。</p>
<p><strong>問題:</strong></p>
<pre><code class="language-java">// クラスに複数のadd()メソッドがある
// add(int, int) と add(double, double)

@Inject(methodName = "add", methodDesc = "(II)I", at = At.HEAD)  // intバージョンのみに一致
public static CallbackInfo hook() { }
</code></pre>
<p><strong>解決策:</strong></p>
<ul>
<li>パラメータと戻り値型を含む完全なディスクリプタを使用</li>
<li>ディスクリプタが自動的にオーバーロードを区別</li>
</ul>
<h4 id="2-プライベートまたは内部メソッド"><a class="header" href="#2-プライベートまたは内部メソッド">2. プライベートまたは内部メソッド</a></h4>
<p>一部のプライベートメソッドはアクセスできない可能性があります。</p>
<p><strong>問題:</strong></p>
<pre><code class="language-java">@Inject(methodName = "internalMethod", methodDesc = "()V", at = At.HEAD)  // プライベートメソッド
public static CallbackInfo hook() { }
</code></pre>
<p><strong>解決策:</strong></p>
<ul>
<li>メソッドが合成またはブリッジメソッドでないことを確認</li>
<li>メソッド名とディスクリプタが正確に正しいことを確認</li>
</ul>
<h2 id="変換されたクラスをロードできない"><a class="header" href="#変換されたクラスをロードできない">変換されたクラスをロードできない</a></h2>
<h3 id="症状-6"><a class="header" href="#症状-6">症状</a></h3>
<ul>
<li>変換後のClassNotFoundException</li>
<li>クラスが見つからないようだ</li>
<li>カスタムClassLoaderの問題</li>
</ul>
<h3 id="原因と解決策-4"><a class="header" href="#原因と解決策-4">原因と解決策</a></h3>
<h4 id="1-不正なclassloaderセットアップ"><a class="header" href="#1-不正なclassloaderセットアップ">1. 不正なClassLoaderセットアップ</a></h4>
<p><strong>問題:</strong></p>
<pre><code class="language-java">// デフォルトのクラスローダーで変換されたバイトコードを使用しようとしている
byte[] transformed = transformer.transform("com.example.MyClass", bytecode);
Class&lt;?&gt; clazz = Class.forName("com.example.MyClass");  // 変換されたバイトコードを使用しない!
</code></pre>
<p><strong>解決策:</strong></p>
<ul>
<li>変換されたバイトコードを使用するカスタムClassLoaderを作成</li>
<li>またはinstrumentation/agentsを使用してロードをインターセプト</li>
</ul>
<h4 id="2-バイトコードの破損"><a class="header" href="#2-バイトコードの破損">2. バイトコードの破損</a></h4>
<p>変換が無効なバイトコードを生成した可能性があります。</p>
<p><strong>解決策:</strong></p>
<ul>
<li>変換がバイトコードを破損していないことを確認</li>
<li>バイトコードのサイズ/整合性を確認</li>
<li>バイトコード検査ツールを使用</li>
</ul>
<h2 id="デバッグのヒント-1"><a class="header" href="#デバッグのヒント-1">デバッグのヒント</a></h2>
<h3 id="1-詳細な出力を有効にする"><a class="header" href="#1-詳細な出力を有効にする">1. 詳細な出力を有効にする</a></h3>
<pre><code class="language-java">// フックにデバッグログを追加
@Inject(methodName = "process", methodDesc = "()V", at = At.HEAD)
public static CallbackInfo debug() {
    System.out.println("[DEBUG] Hook executed");
    System.out.println("[DEBUG] Stack: " + Arrays.toString(Thread.currentThread().getStackTrace()));
    return CallbackInfo.empty();
}
</code></pre>
<h3 id="2-バイトコードを検査"><a class="header" href="#2-バイトコードを検査">2. バイトコードを検査</a></h3>
<pre><code class="language-bash"># 変換されたバイトコードを表示
javap -c -private TransformedClass.class

# インジェクトされた呼び出しを探す
</code></pre>
<h3 id="3-バイトコードビューアを使用"><a class="header" href="#3-バイトコードビューアを使用">3. バイトコードビューアを使用</a></h3>
<p>Bytecode ViewerやIDEAプラグインなどのツールがバイトコードの可視化に役立ちます。</p>
<h3 id="4-パフォーマンスをプロファイル"><a class="header" href="#4-パフォーマンスをプロファイル">4. パフォーマンスをプロファイル</a></h3>
<pre><code class="language-bash"># JProfilerまたはYourKitを使用してボトルネックを特定
# メモリ使用量とCPU時間を監視
</code></pre>
<h2 id="よくある質問"><a class="header" href="#よくある質問">よくある質問</a></h2>
<p><strong>Q: ブートストラップクラスを変換できますか?</strong>
A: 標準のクラスローダーでは簡単ではありません。instrumentation APIでJavaエージェントを使用してください。</p>
<p><strong>Q: 変換はシリアライゼーションに影響しますか?</strong>
A: 変換されたクラスは異なるバイトコードを持ちますが、フィールドを変更しなければ同じシリアライゼーション形式です。</p>
<p><strong>Q: bytekinをSpring Bootで使用できますか?</strong>
A: はい、ただしカスタムクラスロードを設定するか、エージェントを使用する必要があります。</p>
<h2 id="ヘルプを得る"><a class="header" href="#ヘルプを得る">ヘルプを得る</a></h2>
<ol>
<li>このトラブルシューティングガイドを確認</li>
<li><a href="./best-practices.html">ベストプラクティス</a>を確認</li>
<li><a href="./examples.html">例</a>を確認</li>
<li><a href="https://github.com/brqnko/bytekin/issues">GitHub</a>でissueを開く</li>
</ol>
<h2 id="次のステップ-24"><a class="header" href="#次のステップ-24">次のステップ</a></h2>
<ul>
<li><a href="./best-practices.html">ベストプラクティス</a>を確認する</li>
<li><a href="./examples.html">例</a>を確認する</li>
<li>GitHubでissueを報告する</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
