<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>bytekin documentation (English)</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">bytekin documentation (English)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-bytekin"><a class="header" href="#introduction-to-bytekin">Introduction to bytekin</a></h1>
<h2 id="what-is-bytekin"><a class="header" href="#what-is-bytekin">What is bytekin?</a></h2>
<p><strong>bytekin</strong> is a lightweight, easy-to-use Java bytecode transformation framework built on top of <a href="https://asm.ow2.io/">ASM</a>. It allows developers to programmatically modify Java classes at the bytecode level, enabling powerful code injection, method interception, and transformation capabilities.</p>
<p>bytekin is designed to be:</p>
<ul>
<li><strong>Simple</strong>: Intuitive annotation-based API</li>
<li><strong>Lightweight</strong>: Minimal dependencies (only ASM)</li>
<li><strong>Flexible</strong>: Multiple transformation strategies</li>
<li><strong>Powerful</strong>: Support for complex bytecode manipulations</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Inject</strong>: Insert custom code at specific points in methods (head, return, etc.)</li>
<li><strong>Invoke</strong>: Intercept method calls and modify their behavior</li>
<li><strong>Redirect</strong>: Change method call targets</li>
<li><strong>Constant Modification</strong>: Modify constant values in bytecode</li>
<li><strong>Variable Modification</strong>: Manipulate local variables</li>
<li><strong>Mapping Support</strong>: Transform class and method names automatically</li>
<li><strong>Builder Pattern</strong>: Fluent API for constructing transformers</li>
</ul>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p>bytekin is ideal for scenarios where you need to:</p>
<ol>
<li><strong>Add logging or monitoring</strong> to existing classes without modifying source code</li>
<li><strong>Implement AOP (Aspect-Oriented Programming)</strong> without framework overhead</li>
<li><strong>Add security checks</strong> at runtime</li>
<li><strong>Modify third-party library behavior</strong> at the bytecode level</li>
<li><strong>Implement mocking or stubbing</strong> for testing</li>
<li><strong>Instrument code</strong> for profiling or analytics</li>
<li><strong>Apply cross-cutting concerns</strong> to multiple classes</li>
</ol>
<h2 id="why-bytekin"><a class="header" href="#why-bytekin">Why bytekin?</a></h2>
<p>Unlike full-featured frameworks, bytekin is:</p>
<ul>
<li><strong>Minimal</strong>: Only depends on ASM, no heavy dependencies</li>
<li><strong>Direct</strong>: Works with bytecode directly without reflection overhead</li>
<li><strong>Flexible</strong>: Supports both annotation-based and programmatic approaches</li>
<li><strong>Fast</strong>: Efficient bytecode manipulation at JVM load time</li>
</ul>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>The bytekin project is organized into several modules:</p>
<ul>
<li><strong>Transformation Engine</strong>: Core bytecode manipulation logic</li>
<li><strong>Injection System</strong>: Method injection capabilities</li>
<li><strong>Mapping System</strong>: Class and method name mapping support</li>
<li><strong>Utilities</strong>: Helper classes for bytecode manipulation</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="./getting-started.html">Get Started</a> with your first transformation</li>
<li><a href="./core-concepts.html">Learn the Core Concepts</a> behind bytecode manipulation</li>
<li><a href="./features.html">Explore All Features</a> available in bytekin</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-bytekin"><a class="header" href="#getting-started-with-bytekin">Getting Started with bytekin</a></h1>
<p>This section will guide you through setting up bytekin and creating your first bytecode transformation.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Java 8 or higher</li>
<li>Basic understanding of Java</li>
<li>Maven or Gradle (for dependency management)</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="maven"><a class="header" href="#maven">Maven</a></h3>
<p>Add the following to your <code>pom.xml</code>:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.github.brqnko.bytekin&lt;/groupId&gt;
    &lt;artifactId&gt;bytekin&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="gradle"><a class="header" href="#gradle">Gradle</a></h3>
<p>Add the following to your <code>build.gradle</code>:</p>
<pre><code class="language-gradle">dependencies {
    implementation 'io.github.brqnko.bytekin:bytekin:1.0'
}
</code></pre>
<h2 id="your-first-transformation"><a class="header" href="#your-first-transformation">Your First Transformation</a></h2>
<h3 id="step-1-create-a-hook-class"><a class="header" href="#step-1-create-a-hook-class">Step 1: Create a Hook Class</a></h3>
<p>Create a class with the <code>@ModifyClass</code> annotation that defines how you want to transform a target class:</p>
<pre><code class="language-java">import io.github.brqnko.bytekin.injection.ModifyClass;
import io.github.brqnko.bytekin.injection.Inject;
import io.github.brqnko.bytekin.injection.At;
import io.github.brqnko.bytekin.data.CallbackInfo;

@ModifyClass("com.example.Calculator")
public class CalculatorHooks {

    @Inject(methodName = "add", methodDesc = "(II)I", at = At.HEAD)
    public static CallbackInfo onAddHead(int a, int b) {
        System.out.println("Adding " + a + " + " + b);
        return CallbackInfo.empty();
    }
}
</code></pre>
<h3 id="step-2-create-the-transformer"><a class="header" href="#step-2-create-the-transformer">Step 2: Create the Transformer</a></h3>
<p>Instantiate a <code>BytekinTransformer</code> with your hook class:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(CalculatorHooks.class)
    .build();
</code></pre>
<h3 id="step-3-transform-your-classes"><a class="header" href="#step-3-transform-your-classes">Step 3: Transform Your Classes</a></h3>
<p>Apply the transformation to the target class bytecode:</p>
<pre><code class="language-java">byte[] originalBytecode = loadClassBytecode("com.example.Calculator");
byte[] transformedBytecode = transformer.transform("com.example.Calculator", originalBytecode);
</code></pre>
<h3 id="step-4-use-the-transformed-class"><a class="header" href="#step-4-use-the-transformed-class">Step 4: Use the Transformed Class</a></h3>
<p>Load the transformed bytecode into your JVM using a custom <code>ClassLoader</code>:</p>
<pre><code class="language-java">ClassLoader loader = new ByteArrayClassLoader(transformedBytecode);
Class&lt;?&gt; transformedClass = loader.loadClass("com.example.Calculator");
</code></pre>
<h2 id="result"><a class="header" href="#result">Result</a></h2>
<p>The transformed class will have logging added to the <code>add</code> method:</p>
<pre><code class="language-java">// Original code
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}

// Transformed code
public class Calculator {
    public int add(int a, int b) {
        System.out.println("Adding " + a + " + " + b);  // Injected!
        return a + b;
    }
}
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li>Learn about <a href="./core-concepts.html">Core Concepts</a></li>
<li>Explore all <a href="./features.html">Features</a></li>
<li>Check out <a href="./examples.html">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-guide"><a class="header" href="#installation-guide">Installation Guide</a></h1>
<h2 id="using-maven"><a class="header" href="#using-maven">Using Maven</a></h2>
<h3 id="1-add-dependency"><a class="header" href="#1-add-dependency">1. Add Dependency</a></h3>
<p>Edit your <code>pom.xml</code> file and add the following dependency:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.github.brqnko.bytekin&lt;/groupId&gt;
    &lt;artifactId&gt;bytekin&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="2-update-your-project"><a class="header" href="#2-update-your-project">2. Update Your Project</a></h3>
<p>Run Maven to download dependencies:</p>
<pre><code class="language-bash">mvn clean install
</code></pre>
<h2 id="using-gradle"><a class="header" href="#using-gradle">Using Gradle</a></h2>
<h3 id="1-add-dependency-1"><a class="header" href="#1-add-dependency-1">1. Add Dependency</a></h3>
<p>Edit your <code>build.gradle</code> file and add:</p>
<pre><code class="language-gradle">dependencies {
    implementation 'io.github.brqnko.bytekin:bytekin:1.0'
}
</code></pre>
<h3 id="2-sync-your-project"><a class="header" href="#2-sync-your-project">2. Sync Your Project</a></h3>
<p>For Android Studio or IntelliJ IDEA, you can sync Gradle manually. For command line:</p>
<pre><code class="language-bash">./gradlew build
</code></pre>
<h2 id="dependency-requirements"><a class="header" href="#dependency-requirements">Dependency Requirements</a></h2>
<p>bytekin has minimal dependencies:</p>
<div class="table-wrapper"><table><thead><tr><th>Dependency</th><th>Version</th><th>Purpose</th></tr></thead><tbody>
<tr><td>ASM</td><td>9.7.1+</td><td>Bytecode manipulation library</td></tr>
<tr><td>Java</td><td>8+</td><td>Runtime environment</td></tr>
</tbody></table>
</div>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>After installation, verify that bytekin is correctly set up by running a simple test:</p>
<pre><code class="language-java">import io.github.brqnko.bytekin.transformer.BytekinTransformer;

public class ByitekVer {
    public static void main(String[] args) {
        BytekinTransformer transformer = new BytekinTransformer.Builder()
            .build();
        System.out.println("bytekin is ready to use!");
    }
}
</code></pre>
<h2 id="troubleshooting-installation"><a class="header" href="#troubleshooting-installation">Troubleshooting Installation</a></h2>
<h3 id="maven-dependency-not-found"><a class="header" href="#maven-dependency-not-found">Maven: Dependency not found</a></h3>
<ul>
<li>Ensure you're connected to the internet</li>
<li>Try running <code>mvn clean</code> and then <code>mvn install</code> again</li>
<li>Check if the repository is accessible</li>
</ul>
<h3 id="gradle-build-fails"><a class="header" href="#gradle-build-fails">Gradle: Build fails</a></h3>
<ul>
<li>Run <code>./gradlew clean</code> first</li>
<li>Check your Gradle wrapper version</li>
<li>Verify Java version compatibility</li>
</ul>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li><a href="./first-transformation.html">Your First Transformation</a></li>
<li><a href="./core-concepts.html">Core Concepts</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-transformation-1"><a class="header" href="#your-first-transformation-1">Your First Transformation</a></h1>
<p>In this guide, we'll create a complete example demonstrating a simple bytecode transformation.</p>
<h2 id="example-adding-logging-to-a-calculator"><a class="header" href="#example-adding-logging-to-a-calculator">Example: Adding Logging to a Calculator</a></h2>
<h3 id="step-1-create-the-target-class"><a class="header" href="#step-1-create-the-target-class">Step 1: Create the Target Class</a></h3>
<p>First, let's create a simple calculator class that we'll transform:</p>
<pre><code class="language-java">package com.example;

public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public int subtract(int a, int b) {
        return a - b;
    }

    public int multiply(int a, int b) {
        return a * b;
    }
}
</code></pre>
<h3 id="step-2-create-hook-methods"><a class="header" href="#step-2-create-hook-methods">Step 2: Create Hook Methods</a></h3>
<p>Create a class annotated with <code>@ModifyClass</code> that defines what you want to inject:</p>
<pre><code class="language-java">package com.example;

import io.github.brqnko.bytekin.injection.ModifyClass;
import io.github.brqnko.bytekin.injection.Inject;
import io.github.brqnko.bytekin.injection.At;
import io.github.brqnko.bytekin.data.CallbackInfo;

@ModifyClass("com.example.Calculator")
public class CalculatorHooks {

    @Inject(
        methodName = "add",
        methodDesc = "(II)I",
        at = At.HEAD
    )
    public static CallbackInfo logAdd(int a, int b) {
        System.out.println("Computing: " + a + " + " + b);
        return CallbackInfo.empty();
    }

    @Inject(
        methodName = "multiply",
        methodDesc = "(II)I",
        at = At.HEAD
    )
    public static CallbackInfo logMultiply(int a, int b) {
        System.out.println("Computing: " + a + " * " + b);
        return CallbackInfo.empty();
    }
}
</code></pre>
<h3 id="step-3-build-the-transformer"><a class="header" href="#step-3-build-the-transformer">Step 3: Build the Transformer</a></h3>
<pre><code class="language-java">package com.example;

import io.github.brqnko.bytekin.transformer.BytekinTransformer;

public class TransformerSetup {
    public static BytekinTransformer createTransformer() {
        return new BytekinTransformer.Builder(CalculatorHooks.class)
            .build();
    }
}
</code></pre>
<h3 id="step-4-apply-the-transformation"><a class="header" href="#step-4-apply-the-transformation">Step 4: Apply the Transformation</a></h3>
<pre><code class="language-java">package com.example;

import io.github.brqnko.bytekin.transformer.BytekinTransformer;

public class Main {
    public static void main(String[] args) {
        // Get original bytecode
        byte[] originalBytecode = getClassBytecode("com.example.Calculator");

        // Create transformer
        BytekinTransformer transformer = TransformerSetup.createTransformer();

        // Apply transformation
        byte[] transformedBytecode = transformer.transform(
            "com.example.Calculator",
            originalBytecode
        );

        // Load transformed class
        Calculator calc = loadTransformedClass(transformedBytecode);

        // Use the transformed class
        int result = calc.add(5, 3);
        // Output: "Computing: 5 + 3" then "8"

        result = calc.multiply(4, 7);
        // Output: "Computing: 4 * 7" then "28"
    }

    // Helper to get class bytecode (pseudo code)
    static byte[] getClassBytecode(String className) {
        // Implementation depends on your classloader setup
        return new byte[]{};
    }

    // Helper to load transformed class (pseudo code)
    static Calculator loadTransformedClass(byte[] bytecode) {
        // Load using custom ClassLoader
        return null;
    }
}
</code></pre>
<h2 id="what-happened"><a class="header" href="#what-happened">What Happened?</a></h2>
<p>The transformation process:</p>
<ol>
<li><strong>Scanned</strong> <code>CalculatorHooks</code> for methods with <code>@Inject</code> annotation</li>
<li><strong>Found</strong> injections targeting <code>com.example.Calculator</code></li>
<li><strong>Modified</strong> the Calculator class bytecode to call our hook methods</li>
<li><strong>Inserted</strong> the logging code at the head of specified methods</li>
</ol>
<h2 id="before-and-after"><a class="header" href="#before-and-after">Before and After</a></h2>
<p><strong>Before Transformation:</strong></p>
<pre><code class="language-java">public int add(int a, int b) {
    return a + b;
}
</code></pre>
<p><strong>After Transformation:</strong></p>
<pre><code class="language-java">public int add(int a, int b) {
    // Injected code
    com.example.CalculatorHooks.logAdd(a, b);
    // Original code
    return a + b;
}
</code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li>Explore other injection points with <a href="./inject.html#at-enum">At enum</a></li>
<li>Learn about <a href="./invoke.html">Invoke transformations</a></li>
<li>Check out more <a href="./examples.html">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>This section explains the fundamental concepts behind bytekin and bytecode transformation.</p>
<h2 id="what-is-bytecode"><a class="header" href="#what-is-bytecode">What is Bytecode?</a></h2>
<p>Java source code is compiled into <strong>bytecode</strong> - a platform-independent intermediate representation that runs on the Java Virtual Machine (JVM). Unlike source code, bytecode is not human-readable but is standardized and can be manipulated programmatically.</p>
<h3 id="bytecode-structure"><a class="header" href="#bytecode-structure">Bytecode Structure</a></h3>
<p>Java bytecode consists of:</p>
<ul>
<li><strong>Constant Pool</strong>: String literals, method references, field references</li>
<li><strong>Methods</strong>: Compiled methods with instruction sequences</li>
<li><strong>Fields</strong>: Class properties</li>
<li><strong>Attributes</strong>: Metadata like line numbers, local variables, exceptions</li>
</ul>
<h2 id="what-is-bytecode-transformation"><a class="header" href="#what-is-bytecode-transformation">What is Bytecode Transformation?</a></h2>
<p><strong>Bytecode transformation</strong> is the process of reading, analyzing, and modifying bytecode after compilation but before class loading. This allows you to alter class behavior without modifying source code.</p>
<h3 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h3>
<ol>
<li><strong>Runtime Monitoring</strong>: Add logging without changing source</li>
<li><strong>Cross-Cutting Concerns</strong>: Apply behavior to multiple classes</li>
<li><strong>Testing</strong>: Mock or stub methods</li>
<li><strong>Security</strong>: Inject security checks</li>
<li><strong>Performance</strong>: Add profiling instrumentation</li>
</ol>
<h2 id="how-bytekin-fits-in"><a class="header" href="#how-bytekin-fits-in">How bytekin Fits In</a></h2>
<p>bytekin simplifies bytecode transformation by:</p>
<ol>
<li><strong>Abstracting ASM Complexity</strong>: Provides a clean API over raw ASM</li>
<li><strong>Annotation-Based Configuration</strong>: Use Java annotations to define transformations</li>
<li><strong>Multiple Strategies</strong>: Support for injections, method interception, and redirects</li>
<li><strong>Mapping Support</strong>: Handle obfuscated or renamed classes</li>
<li><strong>Flexible Builder Pattern</strong>: Programmatically compose transformations</li>
</ol>
<h2 id="the-transformation-pipeline"><a class="header" href="#the-transformation-pipeline">The Transformation Pipeline</a></h2>
<pre><code>Target Class Bytecode
        ↓
   BytekinTransformer
        ↓
  Scan Hook Classes
        ↓
  Apply Transformations
        ↓
   Modified Bytecode
</code></pre>
<h2 id="key-components"><a class="header" href="#key-components">Key Components</a></h2>
<h3 id="hook-classes"><a class="header" href="#hook-classes">Hook Classes</a></h3>
<p>Classes annotated with <code>@ModifyClass</code> that define how to transform target classes. They contain methods with transformation annotations.</p>
<h3 id="transformers"><a class="header" href="#transformers">Transformers</a></h3>
<p>Objects that apply transformations to bytecode. bytekin provides <code>BytekinTransformer</code> which handles the entire transformation process.</p>
<h3 id="annotations"><a class="header" href="#annotations">Annotations</a></h3>
<p>Special markers in Java code that define transformation behavior:</p>
<ul>
<li><code>@ModifyClass</code>: Mark the target class</li>
<li><code>@Inject</code>: Insert code at specific points</li>
<li><code>@Invoke</code>: Intercept method calls</li>
<li>And more...</li>
</ul>
<h3 id="callbackinfo"><a class="header" href="#callbackinfo">CallbackInfo</a></h3>
<p>A data structure that controls transformation behavior:</p>
<ul>
<li><code>cancelled</code>: Whether to skip original code</li>
<li><code>returnValue</code>: Custom return value</li>
<li><code>modifyArgs</code>: Modified method arguments</li>
</ul>
<h2 id="important-concepts"><a class="header" href="#important-concepts">Important Concepts</a></h2>
<h3 id="method-descriptors"><a class="header" href="#method-descriptors">Method Descriptors</a></h3>
<p>Method descriptors describe method signatures in JVM format:</p>
<pre><code>(ParameterTypes)ReturnType
</code></pre>
<p>Examples:</p>
<ul>
<li><code>(II)I</code> - Takes two ints, returns int</li>
<li><code>(Ljava/lang/String;)V</code> - Takes String, returns void</li>
<li><code>()Ljava/lang/String;</code> - Takes nothing, returns String</li>
</ul>
<h3 id="class-names"><a class="header" href="#class-names">Class Names</a></h3>
<p>In bytekin, class names use dot notation:</p>
<ul>
<li>Java notation: <code>java.lang.String</code></li>
<li>Internal notation: <code>java/lang/String</code></li>
<li>bytekin uses Java notation</li>
</ul>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li><a href="./how-it-works.html">Learn about How bytekin Works</a></li>
<li><a href="./features.html">Explore All Features</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytecode-basics"><a class="header" href="#bytecode-basics">Bytecode Basics</a></h1>
<h2 id="what-is-java-bytecode"><a class="header" href="#what-is-java-bytecode">What is Java Bytecode?</a></h2>
<p>Java source code (<code>.java</code> files) is compiled into Java bytecode (contained in <code>.class</code> files). This bytecode is a platform-independent intermediate language that the Java Virtual Machine (JVM) understands.</p>
<h3 id="source-code-vs-bytecode"><a class="header" href="#source-code-vs-bytecode">Source Code vs Bytecode</a></h3>
<p><strong>Java Source Code:</strong></p>
<pre><code class="language-java">public class Example {
    public void greet(String name) {
        System.out.println("Hello, " + name);
    }
}
</code></pre>
<p><strong>Compiled Bytecode (Conceptual):</strong></p>
<pre><code>aload_0
aload_1
invokedynamic &lt;concat&gt;
getstatic System.out
swap
invokevirtual println
return
</code></pre>
<p>The bytecode version is more verbose and operating-system independent.</p>
<h2 id="why-is-bytecode-important"><a class="header" href="#why-is-bytecode-important">Why is Bytecode Important?</a></h2>
<ol>
<li><strong>Platform Independence</strong>: Works on any system with a JVM</li>
<li><strong>Runtime Flexibility</strong>: Can be transformed before loading</li>
<li><strong>Security</strong>: JVM can verify bytecode correctness</li>
<li><strong>Optimization</strong>: JVM can JIT-compile to native code</li>
<li><strong>Introspection</strong>: Tools can analyze bytecode without source code</li>
</ol>
<h2 id="reading-bytecode"><a class="header" href="#reading-bytecode">Reading Bytecode</a></h2>
<h3 id="tools-for-inspection"><a class="header" href="#tools-for-inspection">Tools for Inspection</a></h3>
<ul>
<li><strong>javap</strong>: Built-in Java disassembler</li>
<li><strong>Bytecode Viewer</strong>: GUI tool for inspecting bytecode</li>
<li><strong>ASM Tree View</strong>: Plugin for IDE visualization</li>
</ul>
<h3 id="example-using-javap"><a class="header" href="#example-using-javap">Example: Using javap</a></h3>
<pre><code class="language-bash">javap -c Example.class
</code></pre>
<p>Output shows the bytecode instructions for each method.</p>
<h2 id="common-bytecode-instructions"><a class="header" href="#common-bytecode-instructions">Common Bytecode Instructions</a></h2>
<p>Some frequently encountered bytecode instructions:</p>
<div class="table-wrapper"><table><thead><tr><th>Instruction</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>aload</code></td><td>Load object reference</td></tr>
<tr><td><code>iload</code></td><td>Load integer</td></tr>
<tr><td><code>invoke*</code></td><td>Call methods (static, virtual, etc)</td></tr>
<tr><td><code>return</code></td><td>Return from method</td></tr>
<tr><td><code>getstatic</code></td><td>Read static field</td></tr>
<tr><td><code>putstatic</code></td><td>Write static field</td></tr>
<tr><td><code>new</code></td><td>Create new object</td></tr>
</tbody></table>
</div>
<h2 id="method-descriptors-signatures"><a class="header" href="#method-descriptors-signatures">Method Descriptors (Signatures)</a></h2>
<p>Bytecode uses a special notation for method signatures:</p>
<pre><code>(ParameterTypes)ReturnType
</code></pre>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h3>
<ul>
<li><code>Z</code> - boolean</li>
<li><code>B</code> - byte</li>
<li><code>C</code> - char</li>
<li><code>S</code> - short</li>
<li><code>I</code> - int</li>
<li><code>J</code> - long</li>
<li><code>F</code> - float</li>
<li><code>D</code> - double</li>
<li><code>V</code> - void</li>
</ul>
<h3 id="object-types"><a class="header" href="#object-types">Object Types</a></h3>
<ul>
<li><code>Ljava/lang/String;</code> - String class</li>
<li><code>L...classname...;</code> - Any class</li>
</ul>
<h3 id="array-types"><a class="header" href="#array-types">Array Types</a></h3>
<ul>
<li><code>[I</code> - int array</li>
<li><code>[Ljava/lang/String;</code> - String array</li>
</ul>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<ul>
<li><code>(II)I</code> - Adds two integers: <code>int method(int a, int b) { return ...; }</code></li>
<li><code>(Ljava/lang/String;)V</code> - Takes string, returns nothing: <code>void method(String s) { ... }</code></li>
<li><code>()Ljava/lang/String;</code> - No parameters, returns string: <code>String method() { ... }</code></li>
<li><code>([Ljava/lang/String;)V</code> - Takes string array: <code>void method(String[] args) { ... }</code></li>
</ul>
<h2 id="class-references"><a class="header" href="#class-references">Class References</a></h2>
<p>Classes are referenced using their fully qualified names with <code>/</code> separators:</p>
<ul>
<li><code>java/lang/String</code></li>
<li><code>java/util/ArrayList</code></li>
<li><code>com/mycompany/MyClass</code></li>
</ul>
<p>In bytekin, we typically use the standard Java notation with dots:</p>
<ul>
<li><code>java.lang.String</code></li>
<li><code>java.util.ArrayList</code></li>
<li><code>com.mycompany.MyClass</code></li>
</ul>
<h2 id="the-class-file-format"><a class="header" href="#the-class-file-format">The Class File Format</a></h2>
<p>A compiled <code>.class</code> file contains:</p>
<ol>
<li><strong>Magic Number</strong>: Identifies it as a class file (<code>0xCAFEBABE</code>)</li>
<li><strong>Version</strong>: Java version information</li>
<li><strong>Constant Pool</strong>: Strings, method names, field names, type information</li>
<li><strong>Access Flags</strong>: public, final, abstract, etc.</li>
<li><strong>This Class</strong>: Class name</li>
<li><strong>Super Class</strong>: Parent class</li>
<li><strong>Interfaces</strong>: Implemented interfaces</li>
<li><strong>Fields</strong>: Class member variables</li>
<li><strong>Methods</strong>: Methods with their bytecode</li>
<li><strong>Attributes</strong>: Additional metadata</li>
</ol>
<h2 id="important-notes"><a class="header" href="#important-notes">Important Notes</a></h2>
<ul>
<li>Bytecode is <strong>not</strong> human-readable but is <strong>systematic and analyzable</strong></li>
<li><strong>Every Java source construct</strong> maps to bytecode</li>
<li><strong>Bytecode is verifiable</strong> - JVM checks correctness before execution</li>
<li><strong>Bytecode can be manipulated</strong> programmatically without source code</li>
</ul>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li>Learn how <a href="./how-it-works.html">bytekin Works</a></li>
<li>Understand <a href="./core-concepts.html">Core Concepts</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-bytekin-works"><a class="header" href="#how-bytekin-works">How bytekin Works</a></h1>
<p>This document explains the internal mechanisms of bytekin and how it transforms bytecode.</p>
<h2 id="the-transformation-process"><a class="header" href="#the-transformation-process">The Transformation Process</a></h2>
<h3 id="step-1-initialization"><a class="header" href="#step-1-initialization">Step 1: Initialization</a></h3>
<pre><code>Define Hook Classes
        ↓
Create BytekinTransformer.Builder
        ↓
Pass hook classes to Builder
</code></pre>
<p>Example:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(
    CalculatorHooks.class,
    StringHooks.class
).build();
</code></pre>
<h3 id="step-2-analysis"><a class="header" href="#step-2-analysis">Step 2: Analysis</a></h3>
<p>When <code>build()</code> is called, bytekin:</p>
<ol>
<li>Scans hook classes for annotations</li>
<li>Extracts transformation rules</li>
<li>Validates method signatures</li>
<li>Prepares transformation strategy</li>
<li>Creates BytekinClassTransformer instances</li>
</ol>
<pre><code>Builder.build()
    ↓
Scan @ModifyClass annotations
    ↓
Extract @Inject, @Invoke, etc.
    ↓
Create transformers map
    ↓
Return BytekinTransformer
</code></pre>
<h3 id="step-3-transformation"><a class="header" href="#step-3-transformation">Step 3: Transformation</a></h3>
<p>When <code>transform()</code> is called:</p>
<pre><code class="language-java">byte[] transformed = transformer.transform("com.example.Calculator", bytecode);
</code></pre>
<p>bytekin:</p>
<ol>
<li>Looks up the target class</li>
<li>Finds matching transformer</li>
<li>Uses ASM to parse bytecode</li>
<li>Applies all registered transformations</li>
<li>Returns modified bytecode</li>
</ol>
<pre><code>Target Bytecode
    ↓
ASM ClassReader
    ↓
BytekinClassVisitor
    ↓
Apply Injections
    ↓
Apply Invocations
    ↓
Apply Redirects
    ↓
Apply Constant Modifications
    ↓
Apply Variable Modifications
    ↓
ASM ClassWriter
    ↓
Modified Bytecode
</code></pre>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<h3 id="core-components"><a class="header" href="#core-components">Core Components</a></h3>
<pre><code>┌─────────────────────────────────────┐
│   BytekinTransformer (Main API)     │
└──────────────┬──────────────────────┘
               │
        ┌──────┴──────┐
        ↓             ↓
    Builder      transform()
        │             │
        └──────┬──────┘
               ↓
   ┌───────────────────────────┐
   │  BytekinClassTransformer  │
   └───────────┬───────────────┘
               ↓
   ┌───────────────────────────┐
   │   BytekinClassVisitor     │
   │  (ASM ClassVisitor)       │
   └───────────┬───────────────┘
               ↓
   ┌───────────────────────────┐
   │  BytekinMethodVisitor     │
   │  (ASM MethodVisitor)      │
   └───────────────────────────┘
</code></pre>
<h3 id="visitor-pattern"><a class="header" href="#visitor-pattern">Visitor Pattern</a></h3>
<p>bytekin uses the <strong>Visitor Pattern</strong> (from ASM):</p>
<pre><code>┌─ ClassVisitor
│   └─ Method Visitor
│       └─ Code Visitor
│           └─ Instruction Handlers
</code></pre>
<p>As ASM parses bytecode, it calls methods on visitors to notify them of each element (class, method, field, instruction, etc.).</p>
<h2 id="transformation-types"><a class="header" href="#transformation-types">Transformation Types</a></h2>
<h3 id="1-injection-code-insertion"><a class="header" href="#1-injection-code-insertion">1. Injection (Code Insertion)</a></h3>
<p><strong>Goal</strong>: Insert code at specific method points</p>
<pre><code>Method Bytecode
    ↓
Find injection point
    ↓
Insert call to hook method
    ↓
Continue with original code
</code></pre>
<p>Example locations:</p>
<ul>
<li><code>At.HEAD</code>: Before method body</li>
<li><code>At.RETURN</code>: Before return statements</li>
<li><code>At.TAIL</code>: At method end</li>
</ul>
<h3 id="2-invocation-method-call-interception"><a class="header" href="#2-invocation-method-call-interception">2. Invocation (Method Call Interception)</a></h3>
<p><strong>Goal</strong>: Intercept method calls within a method</p>
<pre><code>Method Bytecode
    ↓
Find target method invocation
    ↓
Call hook method with same arguments
    ↓
Optionally modify arguments
    ↓
Make method call (or skip it)
</code></pre>
<h3 id="3-redirect-call-target-change"><a class="header" href="#3-redirect-call-target-change">3. Redirect (Call Target Change)</a></h3>
<p><strong>Goal</strong>: Change which method is called</p>
<pre><code>Method Call to A()
    ↓
Intercept call
    ↓
Redirect to B()
</code></pre>
<h3 id="4-constant-modification"><a class="header" href="#4-constant-modification">4. Constant Modification</a></h3>
<p><strong>Goal</strong>: Change constant values</p>
<pre><code>Load Constant X
    ↓
Replace with Constant Y
</code></pre>
<h3 id="5-variable-modification"><a class="header" href="#5-variable-modification">5. Variable Modification</a></h3>
<p><strong>Goal</strong>: Modify local variable values</p>
<pre><code>Local Variable at index N
    ↓
Load from slot
    ↓
Apply modification
    ↓
Store back
</code></pre>
<h2 id="key-data-structures"><a class="header" href="#key-data-structures">Key Data Structures</a></h2>
<h3 id="injection"><a class="header" href="#injection">Injection</a></h3>
<p>Represents a code injection:</p>
<ul>
<li><strong>Target Method</strong>: Which method to inject into</li>
<li><strong>Hook Method</strong>: Which hook method to call</li>
<li><strong>Location</strong>: Where to inject (HEAD, RETURN, etc.)</li>
<li><strong>Parameters</strong>: What parameters to pass</li>
</ul>
<h3 id="invocation"><a class="header" href="#invocation">Invocation</a></h3>
<p>Represents a method call interception:</p>
<ul>
<li><strong>Target Method</strong>: Which method calls the target</li>
<li><strong>Target Call</strong>: Which call to intercept</li>
<li><strong>Hook Method</strong>: Which hook to call</li>
<li><strong>Shift</strong>: Before or after the call</li>
</ul>
<h3 id="callbackinfo-1"><a class="header" href="#callbackinfo-1">CallbackInfo</a></h3>
<p>Controls injection behavior:</p>
<pre><code class="language-java">public class CallbackInfo {
    public boolean cancelled;      // Cancel execution?
    public Object returnValue;     // Custom return?
    public Object[] modifyArgs;    // Modified arguments?
}
</code></pre>
<h2 id="mapping-system"><a class="header" href="#mapping-system">Mapping System</a></h2>
<p>bytekin supports class/method name mappings for obfuscated code:</p>
<pre><code>Original Name     Mapped Name
     ↓                  ↓
  a.class  ────→  com.example.Calculator
  b(II)I   ────→  add(II)I
</code></pre>
<p>Mappings are applied during transformation:</p>
<pre><code>Hook class references "com.example.Calculator"
    ↓
Apply mapping
    ↓
Look for mapped name in bytecode
    ↓
Transform accordingly
</code></pre>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<ul>
<li><strong>BytekinTransformer</strong>: Thread-safe after <code>build()</code></li>
<li><strong>Builder</strong>: Not thread-safe during configuration</li>
<li><strong>transform()</strong>: Can be called concurrently from multiple threads</li>
</ul>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="efficiency"><a class="header" href="#efficiency">Efficiency</a></h3>
<ul>
<li><strong>One-time cost</strong>: Building transformers</li>
<li><strong>Transform time</strong>: Proportional to bytecode size</li>
<li><strong>Runtime overhead</strong>: Only injected code is executed</li>
</ul>
<h3 id="optimization-tips"><a class="header" href="#optimization-tips">Optimization Tips</a></h3>
<ol>
<li>Build transformers once, reuse them</li>
<li>Use transformation early in classloading</li>
<li>Minimize hook method complexity</li>
<li>Profile to identify bottlenecks</li>
</ol>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li>Explore <a href="./features.html">Features</a></li>
<li>Learn about <a href="./advanced-usage.html">Advanced Usage</a></li>
<li>Check out <a href="./examples.html">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features-overview"><a class="header" href="#features-overview">Features Overview</a></h1>
<p>bytekin provides several powerful transformation features to manipulate Java bytecode. This section provides an overview of each feature.</p>
<h2 id="available-features"><a class="header" href="#available-features">Available Features</a></h2>
<h3 id="1-inject---code-insertion"><a class="header" href="#1-inject---code-insertion">1. Inject - Code Insertion</a></h3>
<p>Insert custom code at specific points in methods without modifying source code.</p>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Add logging statements</li>
<li>Implement cross-cutting concerns</li>
<li>Add security checks</li>
<li>Validate parameters</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">@Inject(methodName = "calculate", methodDesc = "(II)I", at = At.HEAD)
public static CallbackInfo logStart(int a, int b) {
    System.out.println("Starting calculation");
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>Learn More:</strong> <a href="./inject.html">Inject Transformation</a></p>
<h3 id="2-invoke---method-call-interception"><a class="header" href="#2-invoke---method-call-interception">2. Invoke - Method Call Interception</a></h3>
<p>Intercept method calls and optionally modify arguments or return values.</p>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Intercept specific method calls</li>
<li>Modify method arguments</li>
<li>Mock or stub methods</li>
<li>Add pre/post processing</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">@Invoke(
    targetMethodName = "process",
    targetMethodDesc = "(Ljava/lang/String;)V",
    invokeMethodName = "validate",
    invokeMethodDesc = "(Ljava/lang/String;)V",
    shift = Shift.BEFORE
)
public static CallbackInfo validateBefore(String input) {
    return new CallbackInfo(false, null, new Object[]{input.trim()});
}
</code></pre>
<p><strong>Learn More:</strong> <a href="./invoke.html">Invoke Transformation</a></p>
<h3 id="3-redirect---method-call-redirection"><a class="header" href="#3-redirect---method-call-redirection">3. Redirect - Method Call Redirection</a></h3>
<p>Change which method is called at runtime.</p>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Redirect calls to alternative implementations</li>
<li>Mock method behavior</li>
<li>Implement method forwarding</li>
<li>Change behavior based on conditions</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">@Redirect(
    targetMethodName = "oldMethod",
    targetMethodDesc = "(I)V",
    redirectMethodName = "newMethod",
    redirectMethodDesc = "(I)V"
)
public static void redirectCall(int value) {
    System.out.println("Redirected to new method: " + value);
}
</code></pre>
<p><strong>Learn More:</strong> <a href="./redirect.html">Redirect Transformation</a></p>
<h3 id="4-constant-modification-1"><a class="header" href="#4-constant-modification-1">4. Constant Modification</a></h3>
<p>Modify constant values embedded in bytecode.</p>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Change hardcoded configuration values</li>
<li>Modify string literals</li>
<li>Change numeric constants</li>
<li>Patch constants at runtime</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">@ModifyConstant(
    methodName = "getVersion",
    oldValue = "1.0",
    newValue = "2.0"
)
public static CallbackInfo updateVersion() {
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>Learn More:</strong> <a href="./constant-modification.html">Constant Modification</a></p>
<h3 id="5-variable-modification-1"><a class="header" href="#5-variable-modification-1">5. Variable Modification</a></h3>
<p>Modify local variable values within methods.</p>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Sanitize inputs</li>
<li>Transform data</li>
<li>Debug variable values</li>
<li>Implement custom logic</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">@ModifyVariable(
    methodName = "process",
    variableIndex = 1
)
public static void transformVariable(int original) {
    // Transformation logic
}
</code></pre>
<p><strong>Learn More:</strong> <a href="./variable-modification.html">Variable Modification</a></p>
<h2 id="combining-features"><a class="header" href="#combining-features">Combining Features</a></h2>
<p>You can use multiple features together for complex transformations:</p>
<pre><code class="language-java">@ModifyClass("com.example.Service")
public class ServiceHooks {
    
    // Inject logging
    @Inject(methodName = "handle", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
    public static CallbackInfo logStart(String input) {
        System.out.println("Processing: " + input);
        return CallbackInfo.empty();
    }
    
    // Intercept internal calls
    @Invoke(
        targetMethodName = "handle",
        targetMethodDesc = "(Ljava/lang/String;)V",
        invokeMethodName = "validate",
        invokeMethodDesc = "(Ljava/lang/String;)V",
        shift = Shift.BEFORE
    )
    public static CallbackInfo validateInput(String input) {
        return new CallbackInfo(false, null, new Object[]{sanitize(input)});
    }
    
    private static String sanitize(String input) {
        return input.trim().toLowerCase();
    }
}
</code></pre>
<h2 id="choosing-the-right-feature"><a class="header" href="#choosing-the-right-feature">Choosing the Right Feature</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Purpose</th><th>Complexity</th></tr></thead><tbody>
<tr><td>Inject</td><td>Insert code at method points</td><td>Low</td></tr>
<tr><td>Invoke</td><td>Intercept specific calls</td><td>Medium</td></tr>
<tr><td>Redirect</td><td>Change call target</td><td>Medium</td></tr>
<tr><td>Constant Modification</td><td>Change hardcoded values</td><td>Low</td></tr>
<tr><td>Variable Modification</td><td>Transform local variables</td><td>High</td></tr>
</tbody></table>
</div>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<ul>
<li>Learn about <a href="./inject.html">Inject</a> transformation</li>
<li>Explore <a href="./invoke.html">Invoke</a> interception</li>
<li>Check <a href="./examples.html">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inject-transformation"><a class="header" href="#inject-transformation">Inject Transformation</a></h1>
<p>The <code>@Inject</code> annotation allows you to insert custom code at specific points in target methods.</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.Calculator")
public class CalculatorHooks {

    @Inject(
        methodName = "add",
        methodDesc = "(II)I",
        at = At.HEAD
    )
    public static CallbackInfo onAddStart(int a, int b) {
        System.out.println("Adding: " + a + " + " + b);
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="annotation-parameters"><a class="header" href="#annotation-parameters">Annotation Parameters</a></h2>
<h3 id="methodname-required"><a class="header" href="#methodname-required">methodName (required)</a></h3>
<p>The name of the target method to inject into.</p>
<pre><code class="language-java">methodName = "add"
</code></pre>
<h3 id="methoddesc-required"><a class="header" href="#methoddesc-required">methodDesc (required)</a></h3>
<p>The JVM descriptor of the target method signature.</p>
<pre><code class="language-java">methodDesc = "(II)I"  // int add(int a, int b)
</code></pre>
<p>See <a href="./bytecode-basics.html#method-descriptors-signatures">Method Descriptors</a> for details.</p>
<h3 id="at-required"><a class="header" href="#at-required">at (required)</a></h3>
<p>Where to inject the code within the method.</p>
<h2 id="at-enum---injection-points"><a class="header" href="#at-enum---injection-points">At Enum - Injection Points</a></h2>
<h3 id="athead"><a class="header" href="#athead">At.HEAD</a></h3>
<p>Inject at the very beginning of the method, before any existing code.</p>
<pre><code class="language-java">@Inject(methodName = "calculate", methodDesc = "()I", at = At.HEAD)
public static CallbackInfo atMethodStart() {
    System.out.println("Method started");
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>Result:</strong></p>
<pre><code class="language-java">public int calculate() {
    System.out.println("Method started");  // Injected
    // Original code here
}
</code></pre>
<h3 id="atreturn"><a class="header" href="#atreturn">At.RETURN</a></h3>
<p>Inject before every return statement in the method.</p>
<pre><code class="language-java">@Inject(methodName = "getValue", methodDesc = "()I", at = At.RETURN)
public static CallbackInfo beforeReturn(CallbackInfo ci) {
    System.out.println("Returning: " + ci.returnValue);
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>Result:</strong></p>
<pre><code class="language-java">public int getValue() {
    if (condition) {
        System.out.println("Returning: " + value);  // Injected
        return value;
    }
    
    System.out.println("Returning: " + defaultValue);  // Injected
    return defaultValue;
}
</code></pre>
<h3 id="attail"><a class="header" href="#attail">At.TAIL</a></h3>
<p>Inject at the very end of the method, after all code but before implicit return.</p>
<pre><code class="language-java">@Inject(methodName = "cleanup", methodDesc = "()V", at = At.TAIL)
public static CallbackInfo atMethodEnd() {
    System.out.println("Cleanup complete");
    return CallbackInfo.empty();
}
</code></pre>
<h2 id="hook-method-parameters"><a class="header" href="#hook-method-parameters">Hook Method Parameters</a></h2>
<p>Hook methods receive the same parameters as the target method, plus <code>CallbackInfo</code>:</p>
<pre><code class="language-java">// Target method:
public String process(String input, int count) { ... }

// Hook method:
@Inject(methodName = "process", methodDesc = "(Ljava/lang/String;I)Ljava/lang/String;", at = At.HEAD)
public static CallbackInfo processHook(String input, int count, CallbackInfo ci) {
    // Can access parameters
    return CallbackInfo.empty();
}
</code></pre>
<h2 id="callbackinfo---controlling-behavior"><a class="header" href="#callbackinfo---controlling-behavior">CallbackInfo - Controlling Behavior</a></h2>
<p>The <code>CallbackInfo</code> object allows you to control how the injection behaves:</p>
<pre><code class="language-java">public class CallbackInfo {
    public boolean cancelled;      // Skip original code?
    public Object returnValue;     // Return custom value?
}
</code></pre>
<h3 id="cancelling-execution"><a class="header" href="#cancelling-execution">Cancelling Execution</a></h3>
<p>Skip the original method and return early:</p>
<pre><code class="language-java">@Inject(methodName = "authenticate", methodDesc = "(Ljava/lang/String;)Z", at = At.HEAD)
public static CallbackInfo checkPermission(String user, CallbackInfo ci) {
    if (!user.equals("admin")) {
        ci.cancelled = true;
        ci.returnValue = false;  // Return false without running original code
    }
    return ci;
}
</code></pre>
<h3 id="custom-return-values"><a class="header" href="#custom-return-values">Custom Return Values</a></h3>
<p>Return a custom value instead of the original result:</p>
<pre><code class="language-java">@Inject(methodName = "getCached", methodDesc = "()Ljava/lang/Object;", at = At.HEAD)
public static CallbackInfo useCachedValue(CallbackInfo ci) {
    Object cached = getFromCache();
    if (cached != null) {
        ci.cancelled = true;
        ci.returnValue = cached;
    }
    return ci;
}
</code></pre>
<h2 id="multiple-injections"><a class="header" href="#multiple-injections">Multiple Injections</a></h2>
<p>You can inject into the same method multiple times:</p>
<pre><code class="language-java">@ModifyClass("com.example.Service")
public class ServiceHooks {

    @Inject(methodName = "handle", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
    public static CallbackInfo logStart(String input) {
        System.out.println("Start: " + input);
        return CallbackInfo.empty();
    }

    @Inject(methodName = "handle", methodDesc = "(Ljava/lang/String;)V", at = At.RETURN)
    public static CallbackInfo logEnd(String input) {
        System.out.println("End: " + input);
        return CallbackInfo.empty();
    }
}
</code></pre>
<p>Both injections will be applied.</p>
<h2 id="instance-methods-vs-static-methods"><a class="header" href="#instance-methods-vs-static-methods">Instance Methods vs Static Methods</a></h2>
<p>For instance methods, the first parameter is usually <code>this</code> (or the object instance):</p>
<pre><code class="language-java">// Target instance method:
public class Calculator {
    public int add(int a, int b) { return a + b; }
}

// Hook can receive 'this':
@Inject(methodName = "add", methodDesc = "(II)I", at = At.HEAD)
public static CallbackInfo onAdd(Calculator self, int a, int b) {
    System.out.println("Calculator instance: " + self);
    return CallbackInfo.empty();
}
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Keep hooks simple</strong>: Complex logic should be in separate methods</li>
<li><strong>Avoid exceptions</strong>: Handle exceptions within hook methods</li>
<li><strong>Use At.HEAD for guards</strong>: Check conditions early</li>
<li><strong>Be careful with At.RETURN</strong>: Multiple returns need handling</li>
<li><strong>Test thoroughly</strong>: Verify injections work correctly</li>
</ol>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>See <a href="./examples-basic.html#inject-examples">Examples - Inject</a> for complete working examples.</p>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<ul>
<li>Learn about <a href="./invoke.html">Invoke</a> for method interception</li>
<li>Explore <a href="./advanced-usage.html">Advanced Usage</a></li>
<li>Check <a href="./api-reference.html">API Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="invoke-transformation"><a class="header" href="#invoke-transformation">Invoke Transformation</a></h1>
<p>The <code>@Invoke</code> annotation allows you to intercept method calls and optionally modify their arguments before execution.</p>
<h2 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.DataProcessor")
public class ProcessorHooks {

    @Invoke(
        targetMethodName = "process",
        targetMethodDesc = "(Ljava/lang/String;)V",
        invokeMethodName = "validate",
        invokeMethodDesc = "(Ljava/lang/String;)V",
        shift = Shift.BEFORE
    )
    public static CallbackInfo validateBeforeProcess(String data) {
        if (data == null || data.isEmpty()) {
            return new CallbackInfo(true, null, new Object[]{"default"});
        }
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="annotation-parameters-1"><a class="header" href="#annotation-parameters-1">Annotation Parameters</a></h2>
<h3 id="targetmethodname-required"><a class="header" href="#targetmethodname-required">targetMethodName (required)</a></h3>
<p>The method name that contains the call to intercept.</p>
<pre><code class="language-java">targetMethodName = "process"
</code></pre>
<h3 id="targetmethoddesc-required"><a class="header" href="#targetmethoddesc-required">targetMethodDesc (required)</a></h3>
<p>The JVM descriptor of the method that contains the call.</p>
<pre><code class="language-java">targetMethodDesc = "(Ljava/lang/String;)V"
</code></pre>
<h3 id="invokemethodname-required"><a class="header" href="#invokemethodname-required">invokeMethodName (required)</a></h3>
<p>The name of the method being called (the one you want to intercept).</p>
<pre><code class="language-java">invokeMethodName = "helper"
</code></pre>
<h3 id="invokemethoddesc-required"><a class="header" href="#invokemethoddesc-required">invokeMethodDesc (required)</a></h3>
<p>The JVM descriptor of the method being called.</p>
<pre><code class="language-java">invokeMethodDesc = "(I)Ljava/lang/String;"
</code></pre>
<h3 id="shift-required"><a class="header" href="#shift-required">shift (required)</a></h3>
<p>When to execute the hook relative to the method call.</p>
<h2 id="shift-enum---timing"><a class="header" href="#shift-enum---timing">Shift Enum - Timing</a></h2>
<h3 id="shiftbefore"><a class="header" href="#shiftbefore">Shift.BEFORE</a></h3>
<p>Execute the hook <strong>before</strong> the method is called.</p>
<pre><code class="language-java">@Invoke(
    targetMethodName = "process",
    targetMethodDesc = "(Ljava/lang/String;)V",
    invokeMethodName = "validate",
    invokeMethodDesc = "(Ljava/lang/String;)V",
    shift = Shift.BEFORE
)
public static CallbackInfo beforeCall(String input) {
    System.out.println("Before calling validate");
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>Result:</strong></p>
<pre><code class="language-java">public void process(String input) {
    System.out.println("Before calling validate");  // Injected
    validate(input);
    // Rest of code
}
</code></pre>
<h3 id="shiftafter"><a class="header" href="#shiftafter">Shift.AFTER</a></h3>
<p>Execute the hook <strong>after</strong> the method is called.</p>
<pre><code class="language-java">@Invoke(
    targetMethodName = "process",
    targetMethodDesc = "(Ljava/lang/String;)V",
    invokeMethodName = "save",
    invokeMethodDesc = "()V",
    shift = Shift.AFTER
)
public static CallbackInfo afterCall() {
    System.out.println("After calling save");
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>Result:</strong></p>
<pre><code class="language-java">public void process(String input) {
    // Some code
    save();
    System.out.println("After calling save");  // Injected
}
</code></pre>
<h2 id="modifying-arguments"><a class="header" href="#modifying-arguments">Modifying Arguments</a></h2>
<p>Use <code>CallbackInfo</code> to change the arguments passed to the intercepted call:</p>
<pre><code class="language-java">@Invoke(
    targetMethodName = "processData",
    targetMethodDesc = "(Ljava/lang/String;I)V",
    invokeMethodName = "transform",
    invokeMethodDesc = "(Ljava/lang/String;I)V",
    shift = Shift.BEFORE
)
public static CallbackInfo sanitizeInput(String data, int count, CallbackInfo ci) {
    // Modify arguments
    String sanitized = data.trim().toLowerCase();
    int newCount = Math.max(0, count);
    
    ci.modifyArgs = new Object[]{sanitized, newCount};
    return ci;
}
</code></pre>
<p><strong>Result:</strong></p>
<pre><code class="language-java">public void processData(String data, int count) {
    // Original: transform(data, count);
    // After hook: transform(data.trim().toLowerCase(), max(0, count));
    transform(data, count);
}
</code></pre>
<h2 id="cancelling-method-calls"><a class="header" href="#cancelling-method-calls">Cancelling Method Calls</a></h2>
<p>Prevent the method from being called:</p>
<pre><code class="language-java">@Invoke(
    targetMethodName = "deleteFile",
    targetMethodDesc = "(Ljava/lang/String;)Z",
    invokeMethodName = "delete",
    invokeMethodDesc = "(Ljava/io/File;)Z",
    shift = Shift.BEFORE
)
public static CallbackInfo preventDeletion(File file, CallbackInfo ci) {
    if (isSystemFile(file)) {
        // Don't call delete(), return false
        ci.cancelled = true;
        ci.returnValue = false;
    }
    return ci;
}
</code></pre>
<h2 id="handling-return-values"><a class="header" href="#handling-return-values">Handling Return Values</a></h2>
<p>Access and modify return values (with <code>Shift.AFTER</code>):</p>
<pre><code class="language-java">@Invoke(
    targetMethodName = "getValue",
    targetMethodDesc = "()I",
    invokeMethodName = "compute",
    invokeMethodDesc = "()I",
    shift = Shift.AFTER
)
public static CallbackInfo modifyReturnValue(CallbackInfo ci) {
    // Access the return value
    int original = (int) ci.returnValue;
    
    // Modify it
    ci.returnValue = original * 2;
    
    return ci;
}
</code></pre>
<h2 id="complex-example"><a class="header" href="#complex-example">Complex Example</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.UserService")
public class UserServiceHooks {

    // Intercept login attempts
    @Invoke(
        targetMethodName = "authenticate",
        targetMethodDesc = "(Ljava/lang/String;Ljava/lang/String;)Z",
        invokeMethodName = "validateCredentials",
        invokeMethodDesc = "(Ljava/lang/String;Ljava/lang/String;)Z",
        shift = Shift.BEFORE
    )
    public static CallbackInfo logAuthAttempt(
        String username, String password, CallbackInfo ci
    ) {
        // Log the attempt
        System.out.println("Auth attempt for: " + username);
        
        // Block certain usernames
        if (username.equals("blocked")) {
            ci.cancelled = true;
            ci.returnValue = false;
        }
        
        return ci;
    }
}
</code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li><strong>Understand call flow</strong>: Know where the method is called</li>
<li><strong>Consider timing</strong>: <code>BEFORE</code> for input validation, <code>AFTER</code> for output transformation</li>
<li><strong>Test argument modification</strong>: Ensure types match</li>
<li><strong>Handle cancellation carefully</strong>: Ensure calling code handles cancelled calls</li>
<li><strong>Profile performance</strong>: Hooks are executed on every call</li>
</ol>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>Can only intercept explicit method calls, not virtual method invocations from bytecode</li>
<li>Cannot intercept calls to constructors directly</li>
<li>Performance impact is incurred for every call</li>
</ul>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p>See <a href="./examples-basic.html#invoke-examples">Examples - Invoke</a> for complete working examples.</p>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<ul>
<li>Learn about <a href="./redirect.html">Redirect</a> transformation</li>
<li>Explore <a href="./advanced-usage.html">Advanced Usage</a></li>
<li>Check <a href="./api-reference.html">API Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redirect-transformation"><a class="header" href="#redirect-transformation">Redirect Transformation</a></h1>
<p>The <code>@Redirect</code> annotation allows you to change which method is actually called at runtime.</p>
<h2 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.LegacyService")
public class LegacyServiceHooks {

    @Redirect(
        targetMethodName = "oldMethod",
        targetMethodDesc = "(I)V",
        redirectMethodName = "newMethod",
        redirectMethodDesc = "(I)V"
    )
    public static void redirectCall(int value) {
        System.out.println("Redirecting call with value: " + value);
    }
}
</code></pre>
<h2 id="annotation-parameters-2"><a class="header" href="#annotation-parameters-2">Annotation Parameters</a></h2>
<h3 id="targetmethodname-required-1"><a class="header" href="#targetmethodname-required-1">targetMethodName (required)</a></h3>
<p>The name of the method that contains the call to redirect.</p>
<pre><code class="language-java">targetMethodName = "process"
</code></pre>
<h3 id="targetmethoddesc-required-1"><a class="header" href="#targetmethoddesc-required-1">targetMethodDesc (required)</a></h3>
<p>The JVM descriptor of the target method.</p>
<pre><code class="language-java">targetMethodDesc = "(Ljava/lang/String;)V"
</code></pre>
<h3 id="redirectmethodname-required"><a class="header" href="#redirectmethodname-required">redirectMethodName (required)</a></h3>
<p>The name of the new method to call instead.</p>
<pre><code class="language-java">redirectMethodName = "newImplementation"
</code></pre>
<h3 id="redirectmethoddesc-required"><a class="header" href="#redirectmethoddesc-required">redirectMethodDesc (required)</a></h3>
<p>The JVM descriptor of the redirect method.</p>
<pre><code class="language-java">redirectMethodDesc = "(Ljava/lang/String;)V"
</code></pre>
<h2 id="how-redirect-works"><a class="header" href="#how-redirect-works">How Redirect Works</a></h2>
<p><strong>Before:</strong></p>
<pre><code class="language-java">public class LegacyAPI {
    public void oldMethod(int value) {
        // Old implementation
    }
}

public class Client {
    public void use() {
        api.oldMethod(42);  // Calls oldMethod
    }
}
</code></pre>
<p><strong>After Redirect:</strong></p>
<pre><code class="language-java">public class Client {
    public void use() {
        api.newMethod(42);  // Redirected to newMethod!
    }
}
</code></pre>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="migration-strategy"><a class="header" href="#migration-strategy">Migration Strategy</a></h3>
<p>Gradually migrate from old API to new API:</p>
<pre><code class="language-java">@ModifyClass("com.example.Application")
public class APIRedirection {

    @Redirect(
        targetMethodName = "main",
        targetMethodDesc = "([Ljava/lang/String;)V",
        redirectMethodName = "legacySearch",
        redirectMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
        from = "oldSearch",
        to = "modernSearch"
    )
    public static void upgradeSearch() {
        // Search calls are now routed to the modern implementation
    }
}
</code></pre>
<h3 id="mocking-for-tests"><a class="header" href="#mocking-for-tests">Mocking for Tests</a></h3>
<p>Replace real implementations with test doubles:</p>
<pre><code class="language-java">@ModifyClass("com.example.DataAccess")
public class TestRedirection {

    @Redirect(
        targetMethodName = "query",
        targetMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
        redirectMethodName = "fetchFromDatabase",
        redirectMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
        from = "realDB",
        to = "mockDB"
    )
    public static void useMockDatabase() {
        // All database calls use mocked implementation
    }
}
</code></pre>
<h3 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h3>
<p>Route to optimized implementations:</p>
<pre><code class="language-java">@ModifyClass("com.example.Processing")
public class PerformanceOptimization {

    @Redirect(
        targetMethodName = "processLargeList",
        targetMethodDesc = "(Ljava/util/List;)Ljava/util/List;",
        redirectMethodName = "slowImplementation",
        redirectMethodDesc = "(Ljava/util/List;)Ljava/util/List;",
        from = "bruteForce",
        to = "optimized"
    )
    public static void useOptimizedAlgorithm() {
        // Uses fast algorithm instead of slow one
    }
}
</code></pre>
<h2 id="differences-from-other-transformations"><a class="header" href="#differences-from-other-transformations">Differences from Other Transformations</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Inject</th><th>Invoke</th><th>Redirect</th></tr></thead><tbody>
<tr><td>What it does</td><td>Insert code</td><td>Intercept calls</td><td>Change target</td></tr>
<tr><td>Call happens</td><td>Yes</td><td>Yes</td><td>Yes, but different target</td></tr>
<tr><td>Can skip execution</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Use case</td><td>Add logging</td><td>Modify behavior</td><td>API migration</td></tr>
</tbody></table>
</div>
<h2 id="type-compatibility"><a class="header" href="#type-compatibility">Type Compatibility</a></h2>
<p>The redirect method must have compatible signature:</p>
<pre><code class="language-java">// Original call
search(String query);  // (Ljava/lang/String;)Ljava/util/List;

// Must redirect to compatible signature
newSearch(String query);  // (Ljava/lang/String;)Ljava/util/List;
</code></pre>
<p><strong>Type mismatch will cause issues:</strong></p>
<pre><code class="language-java">// WRONG - Different parameter types
@Redirect(..., from = "process(int)", to = "process(String)")
</code></pre>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<p>Redirect has minimal overhead compared to normal method calls since:</p>
<ol>
<li>It's a direct bytecode substitution</li>
<li>No wrapper or proxy is created</li>
<li>The JVM can inline and optimize as normal</li>
</ol>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<ul>
<li>Both methods must have compatible signatures</li>
<li>Cannot redirect to final methods</li>
<li>Cannot redirect constructor calls (use <code>@Invoke</code> instead)</li>
<li>Redirects are static - same target for all calls</li>
</ul>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>Ensure compatibility</strong>: Verify method signatures match exactly</li>
<li><strong>Document redirects</strong>: Leave comments explaining why</li>
<li><strong>Test redirects</strong>: Verify behavior after redirection</li>
<li><strong>Use for migration</strong>: Great for moving from old to new APIs</li>
<li><strong>Be cautious</strong>: Track all redirects to avoid confusion</li>
</ol>
<h2 id="advanced-pattern-conditional-redirect"><a class="header" href="#advanced-pattern-conditional-redirect">Advanced Pattern: Conditional Redirect</a></h2>
<p>While <code>@Redirect</code> is static, you can combine it with <code>@Invoke</code> for conditional behavior:</p>
<pre><code class="language-java">@Invoke(
    targetMethodName = "search",
    targetMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
    invokeMethodName = "getResults",
    invokeMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
    shift = Shift.BEFORE
)
public static CallbackInfo selectImplementation(String query, CallbackInfo ci) {
    if (query.length() &gt; 100) {
        // Use optimized search for large queries
        ci.returnValue = optimizedSearch(query);
        ci.cancelled = true;
    }
    return ci;
}
</code></pre>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<ul>
<li>Learn about <a href="./constant-modification.html">Constant Modification</a></li>
<li>Explore <a href="./advanced-usage.html">Advanced Usage</a></li>
<li>Check <a href="./examples.html">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constant-modification"><a class="header" href="#constant-modification">Constant Modification</a></h1>
<p>Modify hardcoded constant values in bytecode without recompiling source code.</p>
<h2 id="basic-usage-3"><a class="header" href="#basic-usage-3">Basic Usage</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.Config")
public class ConfigHooks {

    @ModifyConstant(
        methodName = "getVersion",
        oldValue = "1.0.0",
        newValue = "2.0.0"
    )
    public static CallbackInfo updateVersion() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="what-constants-can-be-modified"><a class="header" href="#what-constants-can-be-modified">What Constants Can Be Modified?</a></h2>
<ul>
<li>String literals</li>
<li>Numeric constants (int, long, float, double)</li>
<li>Boolean constants</li>
<li>Constants in the constant pool</li>
</ul>
<h2 id="string-constants"><a class="header" href="#string-constants">String Constants</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.App")
public class AppHooks {

    @ModifyConstant(
        methodName = "getAPIEndpoint",
        oldValue = "http://localhost:8080",
        newValue = "https://api.production.com"
    )
    public static CallbackInfo updateEndpoint() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<p><strong>Before:</strong></p>
<pre><code class="language-java">public String getAPIEndpoint() {
    return "http://localhost:8080";
}
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-java">public String getAPIEndpoint() {
    return "https://api.production.com";
}
</code></pre>
<h2 id="numeric-constants"><a class="header" href="#numeric-constants">Numeric Constants</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.Limits")
public class LimitsHooks {

    @ModifyConstant(
        methodName = "getMaxConnections",
        oldValue = 10,
        newValue = 100
    )
    public static CallbackInfo increaseLimit() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="multiple-constants-in-same-method"><a class="header" href="#multiple-constants-in-same-method">Multiple Constants in Same Method</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.Config")
public class ConfigHooks {

    @ModifyConstant(
        methodName = "initialize",
        oldValue = "DEBUG",
        newValue = "PRODUCTION"
    )
    public static CallbackInfo updateMode() {
        return CallbackInfo.empty();
    }

    @ModifyConstant(
        methodName = "initialize",
        oldValue = "localhost",
        newValue = "example.com"
    )
    public static CallbackInfo updateHost() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<p>Both modifications will be applied to the same method.</p>
<h2 id="use-cases-2"><a class="header" href="#use-cases-2">Use Cases</a></h2>
<h3 id="environment-configuration"><a class="header" href="#environment-configuration">Environment Configuration</a></h3>
<p>Change environment-specific values:</p>
<pre><code class="language-java">@ModifyClass("com.example.Environment")
public class EnvironmentHooks {

    @ModifyConstant(
        methodName = "getDatabaseURL",
        oldValue = "jdbc:mysql://dev.local:3306/db",
        newValue = "jdbc:mysql://prod.remote:3306/db"
    )
    public static CallbackInfo updateDatabase() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<h3 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h3>
<p>Enable/disable features without recompilation:</p>
<pre><code class="language-java">@ModifyClass("com.example.Features")
public class FeatureHooks {

    @ModifyConstant(
        methodName = "isNewFeatureEnabled",
        oldValue = false,
        newValue = true
    )
    public static CallbackInfo enableFeature() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<h3 id="api-versioning"><a class="header" href="#api-versioning">API Versioning</a></h3>
<p>Update API endpoints:</p>
<pre><code class="language-java">@ModifyClass("com.example.API")
public class APIHooks {

    @ModifyConstant(
        methodName = "getAPIVersion",
        oldValue = "v1",
        newValue = "v3"
    )
    public static CallbackInfo updateAPIVersion() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="performance-impact"><a class="header" href="#performance-impact">Performance Impact</a></h2>
<p>Constant modification has <strong>minimal runtime overhead</strong>:</p>
<ol>
<li>Changes occur during bytecode transformation (one-time)</li>
<li>Runtime performance is identical to recompiled code</li>
<li>JVM can optimize modified constants</li>
</ol>
<h2 id="limitations-2"><a class="header" href="#limitations-2">Limitations</a></h2>
<h3 id="cannot-modify"><a class="header" href="#cannot-modify">Cannot Modify</a></h3>
<ul>
<li>Local variable initializations (in some cases)</li>
<li>Constants created at runtime</li>
<li>Constants already optimized by JVM</li>
</ul>
<h3 id="type-matching"><a class="header" href="#type-matching">Type Matching</a></h3>
<p>The old value and new value must have compatible types:</p>
<pre><code class="language-java">// CORRECT
@ModifyConstant(
    methodName = "getCount",
    oldValue = 10,        // int
    newValue = 20         // int - compatible
)

// WRONG
@ModifyConstant(
    methodName = "getCount",
    oldValue = 10,        // int
    newValue = "20"       // String - incompatible!
)
</code></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<ol>
<li><strong>Use for configuration</strong>: Not for logic changes</li>
<li><strong>Document clearly</strong>: Explain why constants are modified</li>
<li><strong>Keep values consistent</strong>: Use the exact old value</li>
<li><strong>Test all paths</strong>: Verify code works with new values</li>
<li><strong>Avoid type changes</strong>: Keep types compatible</li>
</ol>
<h2 id="advanced-conditional-modification"><a class="header" href="#advanced-conditional-modification">Advanced: Conditional Modification</a></h2>
<p>Combine with other transformations for more control:</p>
<pre><code class="language-java">@ModifyClass("com.example.Service")
public class ServiceHooks {

    @Inject(
        methodName = "initialize",
        methodDesc = "()V",
        at = At.HEAD
    )
    public static CallbackInfo checkEnvironment() {
        String env = System.getProperty("environment");
        if ("production".equals(env)) {
            // Additional setup for production
        }
        return CallbackInfo.empty();
    }

    @ModifyConstant(
        methodName = "getTimeout",
        oldValue = 5000,
        newValue = 30000
    )
    public static CallbackInfo productionTimeout() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next Steps</a></h2>
<ul>
<li>Learn about <a href="./variable-modification.html">Variable Modification</a></li>
<li>Explore <a href="./advanced-usage.html">Advanced Usage</a></li>
<li>Check <a href="./examples.html">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variable-modification"><a class="header" href="#variable-modification">Variable Modification</a></h1>
<p>Modify local variable values within methods during bytecode transformation.</p>
<h2 id="basic-usage-4"><a class="header" href="#basic-usage-4">Basic Usage</a></h2>
<pre><code class="language-java">@ModifyClass("com.example.Processor")
public class ProcessorHooks {

    @ModifyVariable(
        methodName = "process",
        variableIndex = 1
    )
    public static void sanitizeInput(String original) {
        // Transformation logic
    }
}
</code></pre>
<h2 id="understanding-variable-indices"><a class="header" href="#understanding-variable-indices">Understanding Variable Indices</a></h2>
<p>Local variables in a method are stored in slots, indexed starting from 0:</p>
<h3 id="instance-methods"><a class="header" href="#instance-methods">Instance Methods</a></h3>
<pre><code class="language-java">public void process(String name, int count) {
    String result;
    // ...
}
</code></pre>
<p>Variable indices:</p>
<ul>
<li><code>0</code>: <code>this</code> (implicit)</li>
<li><code>1</code>: <code>name</code> (first parameter)</li>
<li><code>2</code>: <code>count</code> (second parameter)</li>
<li><code>3</code>: <code>result</code> (local variable)</li>
</ul>
<h3 id="static-methods"><a class="header" href="#static-methods">Static Methods</a></h3>
<pre><code class="language-java">public static void process(String name, int count) {
    String result;
    // ...
}
</code></pre>
<p>Variable indices:</p>
<ul>
<li><code>0</code>: <code>name</code> (first parameter)</li>
<li><code>1</code>: <code>count</code> (second parameter)</li>
<li><code>2</code>: <code>result</code> (local variable)</li>
</ul>
<h2 id="annotation-parameters-3"><a class="header" href="#annotation-parameters-3">Annotation Parameters</a></h2>
<h3 id="methodname-required-1"><a class="header" href="#methodname-required-1">methodName (required)</a></h3>
<p>The name of the target method.</p>
<pre><code class="language-java">methodName = "process"
</code></pre>
<h3 id="variableindex-required"><a class="header" href="#variableindex-required">variableIndex (required)</a></h3>
<p>The index of the local variable to modify.</p>
<pre><code class="language-java">variableIndex = 1
</code></pre>
<h2 id="modifying-parameters"><a class="header" href="#modifying-parameters">Modifying Parameters</a></h2>
<p>Transform method parameters:</p>
<pre><code class="language-java">@ModifyClass("com.example.UserService")
public class UserServiceHooks {

    @ModifyVariable(
        methodName = "createUser",
        variableIndex = 1  // First parameter: email
    )
    public static void normalizeEmail(String original) {
        // The original email will be normalized
        // e.g., "USER@EXAMPLE.COM" becomes "user@example.com"
    }
}
</code></pre>
<p><strong>Before:</strong></p>
<pre><code class="language-java">public void createUser(String email) {
    // email = "USER@EXAMPLE.COM"
    // ...
}
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-java">public void createUser(String email) {
    // email = "user@example.com" (normalized)
    // ...
}
</code></pre>
<h2 id="modifying-local-variables"><a class="header" href="#modifying-local-variables">Modifying Local Variables</a></h2>
<p>Transform variables created inside methods:</p>
<pre><code class="language-java">@ModifyClass("com.example.Calculator")
public class CalculatorHooks {

    @ModifyVariable(
        methodName = "calculateTotal",
        variableIndex = 2  // Local variable: total
    )
    public static void applyTaxToTotal(int original) {
        // total will be multiplied by 1.1 to apply tax
    }
}
</code></pre>
<h2 id="use-cases-3"><a class="header" href="#use-cases-3">Use Cases</a></h2>
<h3 id="input-sanitization"><a class="header" href="#input-sanitization">Input Sanitization</a></h3>
<p>Clean up method inputs:</p>
<pre><code class="language-java">@ModifyClass("com.example.WebService")
public class WebServiceHooks {

    @ModifyVariable(
        methodName = "handleRequest",
        variableIndex = 1  // request parameter
    )
    public static void sanitizeRequest(String original) {
        // Removes malicious characters
    }

    @ModifyVariable(
        methodName = "handleRequest",
        variableIndex = 2  // path parameter
    )
    public static void validatePath(String original) {
        // Ensures path doesn't escape root directory
    }
}
</code></pre>
<h3 id="data-transformation"><a class="header" href="#data-transformation">Data Transformation</a></h3>
<p>Convert data format:</p>
<pre><code class="language-java">@ModifyClass("com.example.DateProcessor")
public class DateProcessorHooks {

    @ModifyVariable(
        methodName = "processDate",
        variableIndex = 1  // date parameter
    )
    public static void convertToUTC(String original) {
        // Converts from local time to UTC
    }
}
</code></pre>
<h3 id="type-conversion"><a class="header" href="#type-conversion">Type Conversion</a></h3>
<p>Change data types:</p>
<pre><code class="language-java">@ModifyClass("com.example.Converter")
public class ConverterHooks {

    @ModifyVariable(
        methodName = "process",
        variableIndex = 1  // number parameter
    )
    public static void convertToPercentage(int original) {
        // Converts raw number to percentage
    }
}
</code></pre>
<h2 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h2>
<h3 id="multiple-variables"><a class="header" href="#multiple-variables">Multiple Variables</a></h3>
<p>Modify multiple variables in same method:</p>
<pre><code class="language-java">@ModifyClass("com.example.Transfer")
public class TransferHooks {

    @ModifyVariable(
        methodName = "transfer",
        variableIndex = 1  // from account
    )
    public static void validateFromAccount(String original) {
        // Validate source account
    }

    @ModifyVariable(
        methodName = "transfer",
        variableIndex = 2  // to account
    )
    public static void validateToAccount(String original) {
        // Validate destination account
    }

    @ModifyVariable(
        methodName = "transfer",
        variableIndex = 3  // amount
    )
    public static void validateAmount(long original) {
        // Ensure amount is positive
    }
}
</code></pre>
<p>All three modifications are applied to the same method.</p>
<h2 id="type-preservation"><a class="header" href="#type-preservation">Type Preservation</a></h2>
<p>Variable type is preserved during modification:</p>
<pre><code class="language-java">@ModifyClass("com.example.Data")
public class DataHooks {

    // Modifying String parameter
    @ModifyVariable(methodName = "processName", variableIndex = 1)
    public static void transformName(String original) { }

    // Modifying int parameter
    @ModifyVariable(methodName = "processCount", variableIndex = 1)
    public static void transformCount(int original) { }

    // Modifying List parameter
    @ModifyVariable(methodName = "processItems", variableIndex = 1)
    public static void transformItems(List&lt;?&gt; original) { }
}
</code></pre>
<p>Each hook receives the correct type automatically.</p>
<h2 id="limitations-3"><a class="header" href="#limitations-3">Limitations</a></h2>
<h3 id="cannot-modify-1"><a class="header" href="#cannot-modify-1">Cannot Modify</a></h3>
<ul>
<li>Variables that are never used</li>
<li>Variables whose values are optimized away by JVM</li>
<li>Variables modified after initialization in complex ways</li>
</ul>
<h3 id="challenges"><a class="header" href="#challenges">Challenges</a></h3>
<ol>
<li><strong>Index calculation</strong>: Must correctly identify variable indices</li>
<li><strong>Type safety</strong>: Parameter types must match</li>
<li><strong>Scope</strong>: Changes only within that method</li>
<li><strong>Debugging</strong>: Can be hard to trace modifications</li>
</ol>
<h2 id="finding-correct-variable-indices"><a class="header" href="#finding-correct-variable-indices">Finding Correct Variable Indices</a></h2>
<p>Use <code>javap</code> to inspect variable layout:</p>
<pre><code class="language-bash">javap -c -private MyClass.class | grep -A 50 "methodName"
</code></pre>
<p>Look for LocalVariableTable which shows variable positions.</p>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<ol>
<li><strong>Document indices</strong>: Clearly comment which variable at which index</li>
<li><strong>Keep transformations simple</strong>: Complex logic should be separate</li>
<li><strong>Preserve semantics</strong>: Ensure modified values make sense</li>
<li><strong>Test thoroughly</strong>: Verify behavior with modified variables</li>
<li><strong>Use inspectors</strong>: Verify indices are correct before applying</li>
</ol>
<h2 id="combining-with-other-features"><a class="header" href="#combining-with-other-features">Combining with Other Features</a></h2>
<p>Use variable modification with injections:</p>
<pre><code class="language-java">@ModifyClass("com.example.Service")
public class ServiceHooks {

    @Inject(
        methodName = "handle",
        methodDesc = "(Ljava/lang/String;)V",
        at = At.HEAD
    )
    public static CallbackInfo validateInput(String input) {
        if (input == null || input.isEmpty()) {
            return new CallbackInfo(true, null, null);
        }
        return CallbackInfo.empty();
    }

    @ModifyVariable(
        methodName = "handle",
        variableIndex = 1  // input parameter
    )
    public static void normalizeInput(String original) {
        // Also normalize the input
    }
}
</code></pre>
<h2 id="next-steps-12"><a class="header" href="#next-steps-12">Next Steps</a></h2>
<ul>
<li>Explore <a href="./advanced-usage.html">Advanced Usage</a></li>
<li>Learn about <a href="./mappings.html">Mappings</a></li>
<li>Check <a href="./examples.html">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h1>
<p>This section covers advanced patterns and techniques for using bytekin effectively.</p>
<h2 id="programmatic-api-non-annotation-based"><a class="header" href="#programmatic-api-non-annotation-based">Programmatic API (Non-Annotation Based)</a></h2>
<p>While annotations are convenient, you can also use the programmatic API:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder()
    .inject("com.example.Calculator", new Injection(
        "add",
        "(II)I",
        At.HEAD,
        Arrays.asList(Parameter.THIS, Parameter.INT, Parameter.INT)
    ))
    .build();
</code></pre>
<h2 id="multiple-hook-classes"><a class="header" href="#multiple-hook-classes">Multiple Hook Classes</a></h2>
<p>Organize hooks into multiple classes and pass them all:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(
    LoggingHooks.class,
    AuthenticationHooks.class,
    PerformanceHooks.class,
    SecurityHooks.class
).build();
</code></pre>
<h2 id="class-remapping"><a class="header" href="#class-remapping">Class Remapping</a></h2>
<p>Handle obfuscated code using mappings:</p>
<pre><code class="language-java">class MyMappingProvider implements IMappingProvider {
    @Override
    public String getClassName(String name) {
        // Map a.class to com.example.Calculator
        if ("a".equals(name)) return "com.example.Calculator";
        return name;
    }
    
    @Override
    public String getMethodName(String className, String methodName, String descriptor) {
        // Map b to add
        if ("com.example.Calculator".equals(className) &amp;&amp; "b".equals(methodName)) {
            return "add";
        }
        return methodName;
    }
    
    @Override
    public String getFieldName(String className, String fieldName) {
        return fieldName;
    }
}

BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
    .mapping(new MyMappingProvider())
    .build();
</code></pre>
<h2 id="chaining-transformations"><a class="header" href="#chaining-transformations">Chaining Transformations</a></h2>
<p>Apply multiple transformations to the same class:</p>
<pre><code class="language-java">byte[] original = getClassBytecode("com.example.Service");

// First transformation
byte[] step1 = transformer1.transform("com.example.Service", original);

// Second transformation
byte[] step2 = transformer2.transform("com.example.Service", step1);

// Load final result
Class&lt;?&gt; clazz = loadFromBytecode(step2);
</code></pre>
<h2 id="conditional-hook-logic"><a class="header" href="#conditional-hook-logic">Conditional Hook Logic</a></h2>
<p>Execute hooks based on conditions:</p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
public static CallbackInfo conditionalHook(String input, CallbackInfo ci) {
    // Only inject for certain inputs
    if (input.startsWith("test_")) {
        System.out.println("Test mode: " + input);
    }
    
    // Only inject for certain environments
    String env = System.getProperty("app.env", "dev");
    if ("prod".equals(env)) {
        // Different behavior for production
    }
    
    return ci;
}
</code></pre>
<h2 id="stateful-hooks"><a class="header" href="#stateful-hooks">Stateful Hooks</a></h2>
<p>Maintain state across hook invocations:</p>
<pre><code class="language-java">@ModifyClass("com.example.RequestHandler")
public class RequestHooks {
    private static final Map&lt;String, Integer&gt; callCounts = new ConcurrentHashMap&lt;&gt;();
    
    @Inject(methodName = "handle", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
    public static CallbackInfo trackCalls(String id, CallbackInfo ci) {
        int count = callCounts.getOrDefault(id, 0);
        callCounts.put(id, count + 1);
        
        if (count &gt; 100) {
            System.out.println("High call count for: " + id);
        }
        
        return ci;
    }
}
</code></pre>
<h2 id="combining-multiple-transformations"><a class="header" href="#combining-multiple-transformations">Combining Multiple Transformations</a></h2>
<p>Use different transformation types on the same method:</p>
<pre><code class="language-java">@ModifyClass("com.example.DataService")
public class ServiceHooks {
    
    // Log entry
    @Inject(methodName = "query", methodDesc = "(Ljava/lang/String;)Ljava/util/List;", 
            at = At.HEAD)
    public static CallbackInfo logEntry(String sql) {
        System.out.println("Query: " + sql);
        return CallbackInfo.empty();
    }
    
    // Intercept database calls
    @Invoke(
        targetMethodName = "query",
        targetMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
        invokeMethodName = "execute",
        invokeMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
        shift = Shift.BEFORE
    )
    public static CallbackInfo cacheLookup(String sql, CallbackInfo ci) {
        List&lt;?&gt; cached = getFromCache(sql);
        if (cached != null) {
            ci.cancelled = true;
            ci.returnValue = cached;
        }
        return ci;
    }
    
    // Modify constant database URL
    @ModifyConstant(methodName = "getConnection", oldValue = "localhost", 
                    newValue = "db.production.com")
    public static CallbackInfo updateDbLocation() {
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="performance-optimization-pattern"><a class="header" href="#performance-optimization-pattern">Performance Optimization Pattern</a></h2>
<p>Use hooks for efficient performance monitoring:</p>
<pre><code class="language-java">@ModifyClass("com.example.CriticalPath")
public class PerformanceHooks {
    private static final int SLOW_THRESHOLD = 1000; // ms
    
    @Inject(methodName = "criticalOperation", methodDesc = "()V", at = At.HEAD)
    public static CallbackInfo startTimer() {
        TIMER.set(System.currentTimeMillis());
        return CallbackInfo.empty();
    }
    
    @Inject(methodName = "criticalOperation", methodDesc = "()V", at = At.RETURN)
    public static CallbackInfo checkTimer() {
        long duration = System.currentTimeMillis() - TIMER.get();
        if (duration &gt; SLOW_THRESHOLD) {
            System.out.println("Slow operation: " + duration + "ms");
        }
        return CallbackInfo.empty();
    }
    
    private static final ThreadLocal&lt;Long&gt; TIMER = ThreadLocal.withInitial(() -&gt; 0L);
}
</code></pre>
<h2 id="security-pattern---input-validation"><a class="header" href="#security-pattern---input-validation">Security Pattern - Input Validation</a></h2>
<p>Validate all inputs at entry points:</p>
<pre><code class="language-java">@ModifyClass("com.example.WebController")
public class SecurityHooks {
    
    @Inject(methodName = "handleRequest", methodDesc = "(Ljava/lang/String;)V", 
            at = At.HEAD)
    public static CallbackInfo validateRequest(String request, CallbackInfo ci) {
        if (request == null || isMalicious(request)) {
            ci.cancelled = true;  // Block request
            return ci;
        }
        return ci;
    }
    
    private static boolean isMalicious(String request) {
        // Check for SQL injection, XSS, etc.
        return request.contains("DROP") || request.contains("&lt;script&gt;");
    }
}
</code></pre>
<h2 id="testing-pattern---mock-objects"><a class="header" href="#testing-pattern---mock-objects">Testing Pattern - Mock Objects</a></h2>
<p>Use hooks for dependency injection in tests:</p>
<pre><code class="language-java">@ModifyClass("com.example.UserService")
public class TestHooks {
    private static UserRepository mockRepository = new MockUserRepository();
    
    @Inject(methodName = "getUserById", methodDesc = "(I)Lcom/example/User;", 
            at = At.HEAD)
    public static CallbackInfo useMockRepository() {
        // Inject mock repository
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="ab-testing-pattern"><a class="header" href="#ab-testing-pattern">A/B Testing Pattern</a></h2>
<p>Route to different implementations based on user:</p>
<pre><code class="language-java">@ModifyClass("com.example.Algorithm")
public class ABTestingHooks {
    
    @Invoke(
        targetMethodName = "process",
        targetMethodDesc = "(Ljava/lang/Object;)Ljava/lang/Object;",
        invokeMethodName = "compute",
        invokeMethodDesc = "(Ljava/lang/Object;)Ljava/lang/Object;",
        shift = Shift.BEFORE
    )
    public static CallbackInfo selectImplementation(Object data, CallbackInfo ci) {
        // Route to new or old implementation based on user
        if (useNewImplementation(data)) {
            ci.returnValue = computeNew(data);
            ci.cancelled = true;
        }
        return ci;
    }
    
    private static boolean useNewImplementation(Object data) {
        String userId = extractUserId(data);
        int hash = userId.hashCode();
        return hash % 2 == 0;  // 50/50 split
    }
}
</code></pre>
<h2 id="feature-flag-pattern"><a class="header" href="#feature-flag-pattern">Feature Flag Pattern</a></h2>
<p>Enable/disable features without deployment:</p>
<pre><code class="language-java">@ModifyClass("com.example.Features")
public class FeatureFlagHooks {
    private static final Map&lt;String, Boolean&gt; flags = new ConcurrentHashMap&lt;&gt;();
    
    @Inject(methodName = "newFeature", methodDesc = "()V", at = At.HEAD)
    public static CallbackInfo checkFeatureFlag(CallbackInfo ci) {
        if (!isFeatureEnabled("newFeature")) {
            ci.cancelled = true;  // Skip this method
        }
        return ci;
    }
    
    private static boolean isFeatureEnabled(String feature) {
        return flags.getOrDefault(feature, false);
    }
    
    public static void setFeatureFlag(String feature, boolean enabled) {
        flags.put(feature, enabled);
    }
}
</code></pre>
<h2 id="lazy-initialization-pattern"><a class="header" href="#lazy-initialization-pattern">Lazy Initialization Pattern</a></h2>
<p>Defer expensive initialization:</p>
<pre><code class="language-java">@ModifyClass("com.example.Config")
public class ConfigHooks {
    private static volatile Configuration config;
    
    @Inject(methodName = "getConfig", methodDesc = "()Lcom/example/Configuration;", 
            at = At.HEAD)
    public static CallbackInfo lazyInitialize(CallbackInfo ci) {
        if (config == null) {
            synchronized (ConfigHooks.class) {
                if (config == null) {
                    config = loadConfiguration();  // Expensive operation
                }
            }
        }
        ci.cancelled = true;
        ci.returnValue = config;
        return ci;
    }
}
</code></pre>
<h2 id="next-steps-13"><a class="header" href="#next-steps-13">Next Steps</a></h2>
<ul>
<li>Explore <a href="./mappings.html">Mappings</a> in detail</li>
<li>Review <a href="./best-practices.html">Best Practices</a></li>
<li>Check <a href="./examples.html">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mappings"><a class="header" href="#mappings">Mappings</a></h1>
<p>bytekin supports class and method name mappings for working with obfuscated or renamed code.</p>
<h2 id="what-are-mappings"><a class="header" href="#what-are-mappings">What Are Mappings?</a></h2>
<p>Mappings translate between human-readable names and bytecode names. This is useful when:</p>
<ul>
<li>Working with obfuscated code</li>
<li>Applying transformations to renamed classes</li>
<li>Handling version differences</li>
<li>Supporting multiple naming conventions</li>
</ul>
<h2 id="creating-a-mapping-provider"><a class="header" href="#creating-a-mapping-provider">Creating a Mapping Provider</a></h2>
<p>Implement <code>IMappingProvider</code> interface:</p>
<pre><code class="language-java">public class MyMappingProvider implements IMappingProvider {
    
    @Override
    public String getClassName(String name) {
        // Map class names
        if ("OriginalName".equals(name)) {
            return "MappedName";
        }
        return name;
    }
    
    @Override
    public String getMethodName(String className, String methodName, String descriptor) {
        // Map method names based on class and signature
        if ("MyClass".equals(className) &amp;&amp; "oldMethod".equals(methodName)) {
            return "newMethod";
        }
        return methodName;
    }
    
    @Override
    public String getFieldName(String className, String fieldName) {
        // Map field names
        if ("MyClass".equals(className) &amp;&amp; "oldField".equals(fieldName)) {
            return "newField";
        }
        return fieldName;
    }
}
</code></pre>
<h2 id="using-mappings"><a class="header" href="#using-mappings">Using Mappings</a></h2>
<p>Pass mapping provider to builder:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
    .mapping(new MyMappingProvider())
    .build();
</code></pre>
<h2 id="common-mapping-patterns"><a class="header" href="#common-mapping-patterns">Common Mapping Patterns</a></h2>
<h3 id="simple-rename"><a class="header" href="#simple-rename">Simple Rename</a></h3>
<pre><code class="language-java">public String getClassName(String name) {
    return name.replace("OldPrefix", "NewPrefix");
}
</code></pre>
<h3 id="lookup-table"><a class="header" href="#lookup-table">Lookup Table</a></h3>
<pre><code class="language-java">private static final Map&lt;String, String&gt; classMap = new HashMap&lt;&gt;();

static {
    classMap.put("a", "com.example.ClassA");
    classMap.put("b", "com.example.ClassB");
}

public String getClassName(String name) {
    return classMap.getOrDefault(name, name);
}
</code></pre>
<h3 id="file-based-mappings"><a class="header" href="#file-based-mappings">File-Based Mappings</a></h3>
<pre><code class="language-java">public String getClassName(String name) {
    // Load from configuration file
    Properties props = loadMappings("mappings.properties");
    return props.getProperty(name, name);
}
</code></pre>
<h2 id="mapping-obfuscated-code"><a class="header" href="#mapping-obfuscated-code">Mapping Obfuscated Code</a></h2>
<p>When working with obfuscated code:</p>
<pre><code class="language-java">public class ObfuscationMapping implements IMappingProvider {
    
    @Override
    public String getClassName(String name) {
        // a.class -&gt; com.example.MyClass
        switch (name) {
            case "a": return "com.example.MyClass";
            case "b": return "com.example.OtherClass";
            default: return name;
        }
    }
    
    @Override
    public String getMethodName(String className, String methodName, String descriptor) {
        // a.b() -&gt; MyClass.process()
        if ("com.example.MyClass".equals(className)) {
            switch (methodName) {
                case "b": return "process";
                case "c": return "validate";
                default: return methodName;
            }
        }
        return methodName;
    }
}
</code></pre>
<h2 id="hook-configuration-with-mappings"><a class="header" href="#hook-configuration-with-mappings">Hook Configuration with Mappings</a></h2>
<p>Write hooks using human-readable names:</p>
<pre><code class="language-java">@ModifyClass("com.example.UserService")  // Use readable name
public class UserServiceHooks {
    @Inject(methodName = "getUser", methodDesc = "(I)Lcom/example/User;", at = At.HEAD)
    public static CallbackInfo hook() { }
}
</code></pre>
<p>The mapping provider will translate to actual class names in bytecode.</p>
<h2 id="default-no-op-mapping"><a class="header" href="#default-no-op-mapping">Default (No-Op) Mapping</a></h2>
<p>Use empty mapping for unchanged names:</p>
<pre><code class="language-java">public class EmptyMappingProvider implements IMappingProvider {
    
    @Override
    public String getClassName(String name) {
        return name;  // No change
    }
    
    @Override
    public String getMethodName(String className, String methodName, String descriptor) {
        return methodName;  // No change
    }
    
    @Override
    public String getFieldName(String className, String fieldName) {
        return fieldName;  // No change
    }
}
</code></pre>
<h2 id="advanced-version-specific-mappings"><a class="header" href="#advanced-version-specific-mappings">Advanced: Version-Specific Mappings</a></h2>
<p>Support multiple versions:</p>
<pre><code class="language-java">public class VersionAwareMappingProvider implements IMappingProvider {
    private final String version;
    
    public VersionAwareMappingProvider(String version) {
        this.version = version;
    }
    
    @Override
    public String getClassName(String name) {
        if ("1.0".equals(version)) {
            return mapToV1(name);
        } else if ("2.0".equals(version)) {
            return mapToV2(name);
        }
        return name;
    }
    
    private String mapToV1(String name) {
        // Version 1 mappings
        return name;
    }
    
    private String mapToV2(String name) {
        // Version 2 mappings
        return name;
    }
}
</code></pre>
<h2 id="next-steps-14"><a class="header" href="#next-steps-14">Next Steps</a></h2>
<ul>
<li>Review <a href="./advanced-usage.html">Advanced Usage</a></li>
<li>Check <a href="./best-practices.html">Best Practices</a></li>
<li>Explore <a href="./examples.html">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builder-pattern"><a class="header" href="#builder-pattern">Builder Pattern</a></h1>
<p>bytekin provides a fluent Builder API for constructing transformers programmatically.</p>
<h2 id="basic-usage-5"><a class="header" href="#basic-usage-5">Basic Usage</a></h2>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
    .build();
</code></pre>
<h2 id="using-mappings-1"><a class="header" href="#using-mappings-1">Using Mappings</a></h2>
<p>Apply name mappings during builder construction:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
    .mapping(new CustomMappingProvider())
    .build();
</code></pre>
<h2 id="adding-programmatic-transformations"><a class="header" href="#adding-programmatic-transformations">Adding Programmatic Transformations</a></h2>
<p>Mix annotation-based and programmatic configurations:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(AnnotationHooks.class)
    .inject("com.example.Extra", new Injection(...))
    .invoke("com.example.Another", new Invocation(...))
    .build();
</code></pre>
<h2 id="multiple-hook-classes-1"><a class="header" href="#multiple-hook-classes-1">Multiple Hook Classes</a></h2>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(
    LoggingHooks.class,
    SecurityHooks.class,
    PerformanceHooks.class
)
.mapping(myMappings)
.build();
</code></pre>
<h2 id="builder-methods"><a class="header" href="#builder-methods">Builder Methods</a></h2>
<h3 id="mappingimappingprovider"><a class="header" href="#mappingimappingprovider">mapping(IMappingProvider)</a></h3>
<p>Set a mapping provider for class/method name translation.</p>
<h3 id="injectstring-injection"><a class="header" href="#injectstring-injection">inject(String, Injection)</a></h3>
<p>Add injection transformation programmatically.</p>
<h3 id="invokestring-invocation"><a class="header" href="#invokestring-invocation">invoke(String, Invocation)</a></h3>
<p>Add invocation transformation programmatically.</p>
<h3 id="redirectstring-redirectdata"><a class="header" href="#redirectstring-redirectdata">redirect(String, RedirectData)</a></h3>
<p>Add redirect transformation programmatically.</p>
<h3 id="modifyconstantstring-constantmodification"><a class="header" href="#modifyconstantstring-constantmodification">modifyConstant(String, ConstantModification)</a></h3>
<p>Add constant modification programmatically.</p>
<h3 id="modifyvariablestring-variablemodification"><a class="header" href="#modifyvariablestring-variablemodification">modifyVariable(String, VariableModification)</a></h3>
<p>Add variable modification programmatically.</p>
<h3 id="build"><a class="header" href="#build">build()</a></h3>
<p>Build and return the transformer. This method:</p>
<ol>
<li>Scans all hook classes</li>
<li>Extracts annotations</li>
<li>Adds programmatic transformations</li>
<li>Creates internal transformer map</li>
<li>Returns ready-to-use transformer</li>
</ol>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<ol>
<li><strong>Build once</strong>: Create transformers during initialization</li>
<li><strong>Reuse</strong>: Use the same transformer for multiple transformations</li>
<li><strong>Combine patterns</strong>: Mix annotations and programmatic API</li>
<li><strong>Document configuration</strong>: Comment why specific transformations are applied</li>
</ol>
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<pre><code class="language-java">// Good: Build once
BytekinTransformer transformer = new BytekinTransformer.Builder(Hooks.class).build();

for (String className : classes) {
    byte[] transformed = transformer.transform(className, bytecode);
}

// Bad: Building multiple times
for (String className : classes) {
    BytekinTransformer transformer = new BytekinTransformer.Builder(Hooks.class).build();
    byte[] transformed = transformer.transform(className, bytecode);
}
</code></pre>
<h2 id="next-steps-15"><a class="header" href="#next-steps-15">Next Steps</a></h2>
<ul>
<li>Learn <a href="./advanced-usage.html">Advanced Usage</a></li>
<li>Review <a href="./best-practices.html">Best Practices</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-transformers"><a class="header" href="#custom-transformers">Custom Transformers</a></h1>
<p>Beyond annotations, bytekin allows you to create custom transformers for advanced use cases.</p>
<h2 id="creating-custom-transformers"><a class="header" href="#creating-custom-transformers">Creating Custom Transformers</a></h2>
<p>You can extend the transformation system by implementing custom logic:</p>
<pre><code class="language-java">public class CustomTransformer implements IBytekinMethodTransformer {
    @Override
    public byte[] transform(byte[] bytecode) {
        // Custom transformation logic
        return bytecode;
    }
}
</code></pre>
<h2 id="advanced-customization"><a class="header" href="#advanced-customization">Advanced Customization</a></h2>
<p>For more complex scenarios, work directly with ASM visitor pattern:</p>
<pre><code class="language-java">public class AdvancedCustomTransformer extends ClassVisitor {
    public AdvancedCustomTransformer(ClassVisitor cv) {
        super(ASM9, cv);
    }
    
    @Override
    public MethodVisitor visitMethod(int access, String name, String descriptor, 
                                     String signature, String[] exceptions) {
        MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);
        
        // Return custom method visitor
        return new MethodVisitor(ASM9, mv) {
            @Override
            public void visitCode() {
                // Custom method instrumentation
                super.visitCode();
            }
        };
    }
}
</code></pre>
<h2 id="combining-custom-and-built-in-transformations"><a class="header" href="#combining-custom-and-built-in-transformations">Combining Custom and Built-in Transformations</a></h2>
<p>Mix custom transformers with bytekin's built-in features:</p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(BuiltInHooks.class)
    .build();

// Apply custom transformation after
byte[] original = getClassBytecode("com.example.MyClass");
byte[] withBuiltIn = transformer.transform("com.example.MyClass", original);
byte[] withCustom = applyCustom(withBuiltIn);
</code></pre>
<h2 id="performance-considerations-2"><a class="header" href="#performance-considerations-2">Performance Considerations</a></h2>
<ul>
<li>Keep custom transformers efficient</li>
<li>Cache transformation results when possible</li>
<li>Profile custom code for hotspots</li>
</ul>
<h2 id="next-steps-16"><a class="header" href="#next-steps-16">Next Steps</a></h2>
<ul>
<li>Review <a href="./advanced-usage.html">Advanced Usage</a></li>
<li>Check <a href="./best-practices.html">Best Practices</a></li>
<li>Explore <a href="./examples.html">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<p>This section provides detailed API documentation for bytekin.</p>
<h2 id="core-classes"><a class="header" href="#core-classes">Core Classes</a></h2>
<h3 id="bytekintransformer"><a class="header" href="#bytekintransformer">BytekinTransformer</a></h3>
<p>The main entry point for bytecode transformation.</p>
<pre><code class="language-java">public class BytekinTransformer {
    public byte[] transform(String className, byte[] bytes, int api);
    
    public static class Builder {
        public Builder(Class&lt;?&gt;... classes);
        public Builder mapping(IMappingProvider mapping);
        public Builder inject(String className, Injection injection);
        public Builder invoke(String className, Invocation invocation);
        public Builder redirect(String className, RedirectData redirect);
        public Builder modifyConstant(String className, ConstantModification modification);
        public Builder modifyVariable(String className, VariableModification modification);
        public BytekinTransformer build();
    }
}
</code></pre>
<h3 id="callbackinfo-2"><a class="header" href="#callbackinfo-2">CallbackInfo</a></h3>
<p>Controls transformation behavior within hook methods.</p>
<pre><code class="language-java">public class CallbackInfo {
    public boolean cancelled;
    public Object returnValue;
    public Object[] modifyArgs;
    
    public static CallbackInfo empty();
}
</code></pre>
<h2 id="annotations-1"><a class="header" href="#annotations-1">Annotations</a></h2>
<h3 id="modifyclass"><a class="header" href="#modifyclass">@ModifyClass</a></h3>
<p>Marks a class as a hook container for bytecode transformations.</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ModifyClass {
    String className();
}
</code></pre>
<h3 id="inject"><a class="header" href="#inject">@Inject</a></h3>
<p>Injects code at specific points in methods.</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Inject {
    String methodName();
    String methodDesc();
    At at();
}
</code></pre>
<h3 id="invoke"><a class="header" href="#invoke">@Invoke</a></h3>
<p>Intercepts method calls.</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Invoke {
    String targetMethodName();
    String targetMethodDesc();
    String invokeMethodName();
    String invokeMethodDesc();
    Shift shift();
}
</code></pre>
<h3 id="redirect"><a class="header" href="#redirect">@Redirect</a></h3>
<p>Redirects method calls to different target.</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Redirect {
    String targetMethodName();
    String targetMethodDesc();
    String redirectMethodName();
    String redirectMethodDesc();
}
</code></pre>
<h3 id="modifyconstant"><a class="header" href="#modifyconstant">@ModifyConstant</a></h3>
<p>Modifies constant values in bytecode.</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ModifyConstant {
    String methodName();
    Object oldValue();
    Object newValue();
}
</code></pre>
<h3 id="modifyvariable"><a class="header" href="#modifyvariable">@ModifyVariable</a></h3>
<p>Modifies local variable values.</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ModifyVariable {
    String methodName();
    int variableIndex();
}
</code></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<h3 id="at"><a class="header" href="#at">At</a></h3>
<p>Specifies where to inject code.</p>
<pre><code class="language-java">public enum At {
    HEAD,      // Before method body
    RETURN,    // Before return statements
    TAIL       // At method end
}
</code></pre>
<h3 id="shift"><a class="header" href="#shift">Shift</a></h3>
<p>Specifies timing relative to method invocation.</p>
<pre><code class="language-java">public enum Shift {
    BEFORE,    // Before the call
    AFTER      // After the call
}
</code></pre>
<h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
<h3 id="imappingprovider"><a class="header" href="#imappingprovider">IMappingProvider</a></h3>
<p>Maps class and method names.</p>
<pre><code class="language-java">public interface IMappingProvider {
    String getClassName(String name);
    String getMethodName(String className, String methodName, String descriptor);
    String getFieldName(String className, String fieldName);
}
</code></pre>
<h2 id="data-classes"><a class="header" href="#data-classes">Data Classes</a></h2>
<h3 id="injection-1"><a class="header" href="#injection-1">Injection</a></h3>
<p>Represents an injection transformation.</p>
<pre><code class="language-java">public class Injection {
    // Constructor and methods
}
</code></pre>
<h3 id="invocation-1"><a class="header" href="#invocation-1">Invocation</a></h3>
<p>Represents an invocation transformation.</p>
<pre><code class="language-java">public class Invocation {
    // Constructor and methods
}
</code></pre>
<h3 id="redirectdata"><a class="header" href="#redirectdata">RedirectData</a></h3>
<p>Represents a redirect transformation.</p>
<pre><code class="language-java">public class RedirectData {
    // Constructor and methods
}
</code></pre>
<h3 id="constantmodification"><a class="header" href="#constantmodification">ConstantModification</a></h3>
<p>Represents a constant modification transformation.</p>
<pre><code class="language-java">public class ConstantModification {
    // Constructor and methods
}
</code></pre>
<h3 id="variablemodification"><a class="header" href="#variablemodification">VariableModification</a></h3>
<p>Represents a variable modification transformation.</p>
<pre><code class="language-java">public class VariableModification {
    // Constructor and methods
}
</code></pre>
<h2 id="common-exceptions"><a class="header" href="#common-exceptions">Common Exceptions</a></h2>
<h3 id="verifyerror"><a class="header" href="#verifyerror">VerifyError</a></h3>
<p>Thrown when transformed bytecode is invalid.</p>
<h3 id="classnotfoundexception"><a class="header" href="#classnotfoundexception">ClassNotFoundException</a></h3>
<p>Thrown when target class cannot be found.</p>
<h3 id="classformatexception"><a class="header" href="#classformatexception">ClassFormatException</a></h3>
<p>Thrown when bytecode format is invalid.</p>
<h2 id="utility-classes"><a class="header" href="#utility-classes">Utility Classes</a></h2>
<h3 id="descriptorparser"><a class="header" href="#descriptorparser">DescriptorParser</a></h3>
<p>Utility for parsing and validating method descriptors.</p>
<h3 id="bytecodemanipulator"><a class="header" href="#bytecodemanipulator">BytecodeManipulator</a></h3>
<p>Low-level bytecode manipulation utilities.</p>
<h2 id="threading"><a class="header" href="#threading">Threading</a></h2>
<p>All public methods are <strong>thread-safe after initialization</strong>:</p>
<ul>
<li><code>BytekinTransformer.transform()</code> can be called from multiple threads</li>
<li><code>Builder</code> is <strong>not</strong> thread-safe during configuration</li>
<li><code>CallbackInfo</code> is local to each hook invocation</li>
</ul>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Complexity</th></tr></thead><tbody>
<tr><td>Builder.build()</td><td>O(n) where n = number of hook methods</td></tr>
<tr><td>transform()</td><td>O(m) where m = bytecode size</td></tr>
<tr><td>Hook execution</td><td>O(1) average case</td></tr>
</tbody></table>
</div>
<h2 id="next-steps-17"><a class="header" href="#next-steps-17">Next Steps</a></h2>
<ul>
<li>Review <a href="./annotations.html">Annotations</a> in detail</li>
<li>Check <a href="./classes-interfaces.html">Classes and Interfaces</a></li>
<li>Explore <a href="./examples.html">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="annotations-reference"><a class="header" href="#annotations-reference">Annotations Reference</a></h1>
<p>Complete reference for bytekin annotations.</p>
<h2 id="modifyclass-1"><a class="header" href="#modifyclass-1">@ModifyClass</a></h2>
<h3 id="purpose"><a class="header" href="#purpose">Purpose</a></h3>
<p>Marks a class as containing hook methods for bytecode transformation.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code class="language-java">@ModifyClass("com.example.TargetClass")
public class MyHooks {
    // Hook methods here
}
</code></pre>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td>className</td><td>String</td><td>Yes</td><td>Fully qualified name of the target class</td></tr>
</tbody></table>
</div>
<h3 id="scope"><a class="header" href="#scope">Scope</a></h3>
<p>Applied to class types only.</p>
<h2 id="inject-1"><a class="header" href="#inject-1">@Inject</a></h2>
<h3 id="purpose-1"><a class="header" href="#purpose-1">Purpose</a></h3>
<p>Inject code at specific points in methods.</p>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<pre><code class="language-java">@Inject(
    methodName = "myMethod",
    methodDesc = "(I)Ljava/lang/String;",
    at = At.HEAD
)
public static CallbackInfo hook(int param) { }
</code></pre>
<h3 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td>methodName</td><td>String</td><td>Yes</td><td>Target method name</td></tr>
<tr><td>methodDesc</td><td>String</td><td>Yes</td><td>Method descriptor (JVM format)</td></tr>
<tr><td>at</td><td>At</td><td>Yes</td><td>Where to inject code</td></tr>
</tbody></table>
</div>
<h3 id="scope-1"><a class="header" href="#scope-1">Scope</a></h3>
<p>Applied to methods only.</p>
<h3 id="return-type"><a class="header" href="#return-type">Return Type</a></h3>
<p>Must return <code>CallbackInfo</code>.</p>
<h2 id="invoke-1"><a class="header" href="#invoke-1">@Invoke</a></h2>
<h3 id="purpose-2"><a class="header" href="#purpose-2">Purpose</a></h3>
<p>Intercept method calls.</p>
<h3 id="usage-2"><a class="header" href="#usage-2">Usage</a></h3>
<pre><code class="language-java">@Invoke(
    targetMethodName = "parentMethod",
    targetMethodDesc = "()V",
    invokeMethodName = "childMethod",
    invokeMethodDesc = "(I)V",
    shift = Shift.BEFORE
)
public static CallbackInfo hook() { }
</code></pre>
<h3 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td>targetMethodName</td><td>String</td><td>Yes</td><td>Method containing the call</td></tr>
<tr><td>targetMethodDesc</td><td>String</td><td>Yes</td><td>Descriptor of target method</td></tr>
<tr><td>invokeMethodName</td><td>String</td><td>Yes</td><td>Name of method being called</td></tr>
<tr><td>invokeMethodDesc</td><td>String</td><td>Yes</td><td>Descriptor of called method</td></tr>
<tr><td>shift</td><td>Shift</td><td>Yes</td><td>BEFORE or AFTER the call</td></tr>
</tbody></table>
</div>
<h3 id="scope-2"><a class="header" href="#scope-2">Scope</a></h3>
<p>Applied to methods only.</p>
<h2 id="redirect-1"><a class="header" href="#redirect-1">@Redirect</a></h2>
<h3 id="purpose-3"><a class="header" href="#purpose-3">Purpose</a></h3>
<p>Redirect method calls to different target.</p>
<h3 id="usage-3"><a class="header" href="#usage-3">Usage</a></h3>
<pre><code class="language-java">@Redirect(
    targetMethodName = "oldMethod",
    targetMethodDesc = "()V",
    redirectMethodName = "newMethod",
    redirectMethodDesc = "()V"
)
public static void hook() { }
</code></pre>
<h3 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td>targetMethodName</td><td>String</td><td>Yes</td><td>Method containing the call</td></tr>
<tr><td>targetMethodDesc</td><td>String</td><td>Yes</td><td>Descriptor of target method</td></tr>
<tr><td>redirectMethodName</td><td>String</td><td>Yes</td><td>Name of redirect method</td></tr>
<tr><td>redirectMethodDesc</td><td>String</td><td>Yes</td><td>Descriptor of redirect method</td></tr>
</tbody></table>
</div>
<h2 id="modifyconstant-1"><a class="header" href="#modifyconstant-1">@ModifyConstant</a></h2>
<h3 id="purpose-4"><a class="header" href="#purpose-4">Purpose</a></h3>
<p>Modify constant values in bytecode.</p>
<h3 id="usage-4"><a class="header" href="#usage-4">Usage</a></h3>
<pre><code class="language-java">@ModifyConstant(
    methodName = "getConfig",
    oldValue = "dev",
    newValue = "prod"
)
public static CallbackInfo hook() { }
</code></pre>
<h3 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td>methodName</td><td>String</td><td>Yes</td><td>Method containing the constant</td></tr>
<tr><td>oldValue</td><td>Object</td><td>Yes</td><td>Original constant value</td></tr>
<tr><td>newValue</td><td>Object</td><td>Yes</td><td>New constant value</td></tr>
</tbody></table>
</div>
<h2 id="modifyvariable-1"><a class="header" href="#modifyvariable-1">@ModifyVariable</a></h2>
<h3 id="purpose-5"><a class="header" href="#purpose-5">Purpose</a></h3>
<p>Modify local variable values.</p>
<h3 id="usage-5"><a class="header" href="#usage-5">Usage</a></h3>
<pre><code class="language-java">@ModifyVariable(
    methodName = "process",
    variableIndex = 1
)
public static void hook(String param) { }
</code></pre>
<h3 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td>methodName</td><td>String</td><td>Yes</td><td>Target method name</td></tr>
<tr><td>variableIndex</td><td>int</td><td>Yes</td><td>Local variable slot index</td></tr>
</tbody></table>
</div>
<h2 id="enum-at"><a class="header" href="#enum-at">Enum: At</a></h2>
<h3 id="values"><a class="header" href="#values">Values</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>HEAD</td><td>At start of method, before all code</td></tr>
<tr><td>RETURN</td><td>Before each return statement</td></tr>
<tr><td>TAIL</td><td>At end of method</td></tr>
</tbody></table>
</div>
<h2 id="enum-shift"><a class="header" href="#enum-shift">Enum: Shift</a></h2>
<h3 id="values-1"><a class="header" href="#values-1">Values</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>BEFORE</td><td>Execute hook before method call</td></tr>
<tr><td>AFTER</td><td>Execute hook after method call</td></tr>
</tbody></table>
</div>
<h2 id="next-steps-18"><a class="header" href="#next-steps-18">Next Steps</a></h2>
<ul>
<li>Review <a href="./classes-interfaces.html">Classes and Interfaces</a></li>
<li>Check <a href="./api-reference.html">API Reference</a></li>
<li>Explore <a href="./examples.html">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes-and-interfaces"><a class="header" href="#classes-and-interfaces">Classes and Interfaces</a></h1>
<p>Reference documentation for bytekin classes and interfaces.</p>
<h2 id="core-classes-1"><a class="header" href="#core-classes-1">Core Classes</a></h2>
<h3 id="bytekintransformer-1"><a class="header" href="#bytekintransformer-1">BytekinTransformer</a></h3>
<p>Main transformer class for bytecode manipulation.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>byte[] transform(String className, byte[] bytes, int api)</code> - Transform class bytecode</li>
<li><code>byte[] transform(String className, byte[] bytes)</code> - Transform (default API)</li>
</ul>
<p><strong>Builder:</strong></p>
<ul>
<li><code>new BytekinTransformer.Builder(Class&lt;?&gt;... classes)</code> - Create builder</li>
</ul>
<h3 id="callbackinfo-3"><a class="header" href="#callbackinfo-3">CallbackInfo</a></h3>
<p>Data structure for controlling transformation behavior.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>boolean cancelled</code> - Skip original code execution</li>
<li><code>Object returnValue</code> - Custom return value</li>
<li><code>Object[] modifyArgs</code> - Modified method arguments</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>static CallbackInfo empty()</code> - Create empty callback</li>
<li><code>CallbackInfo(boolean cancelled, Object returnValue, Object[] modifyArgs)</code> - Constructor</li>
</ul>
<h2 id="builder-class"><a class="header" href="#builder-class">Builder Class</a></h2>
<h3 id="bytekintransformerbuilder"><a class="header" href="#bytekintransformerbuilder">BytekinTransformer.Builder</a></h3>
<p>Fluent builder for constructing transformers.</p>
<p><strong>Constructors:</strong></p>
<ul>
<li><code>Builder(Class&lt;?&gt;... classes)</code> - Initialize with hook classes</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>Builder mapping(IMappingProvider)</code> - Set mapping provider</li>
<li><code>Builder inject(String, Injection)</code> - Add injection</li>
<li><code>Builder invoke(String, Invocation)</code> - Add invocation</li>
<li><code>Builder redirect(String, RedirectData)</code> - Add redirect</li>
<li><code>Builder modifyConstant(String, ConstantModification)</code> - Add constant modification</li>
<li><code>Builder modifyVariable(String, VariableModification)</code> - Add variable modification</li>
<li><code>BytekinTransformer build()</code> - Build transformer</li>
</ul>
<h2 id="data-classes-1"><a class="header" href="#data-classes-1">Data Classes</a></h2>
<h3 id="injection-2"><a class="header" href="#injection-2">Injection</a></h3>
<p>Represents an injection point.</p>
<p><strong>Purpose:</strong> Store injection configuration data.</p>
<h3 id="invocation-2"><a class="header" href="#invocation-2">Invocation</a></h3>
<p>Represents an invocation point.</p>
<p><strong>Purpose:</strong> Store invocation configuration data.</p>
<h3 id="redirectdata-1"><a class="header" href="#redirectdata-1">RedirectData</a></h3>
<p>Represents a redirect target.</p>
<p><strong>Purpose:</strong> Store redirect configuration data.</p>
<h3 id="constantmodification-1"><a class="header" href="#constantmodification-1">ConstantModification</a></h3>
<p>Represents a constant modification.</p>
<p><strong>Purpose:</strong> Store constant modification data.</p>
<h3 id="variablemodification-1"><a class="header" href="#variablemodification-1">VariableModification</a></h3>
<p>Represents a variable modification.</p>
<p><strong>Purpose:</strong> Store variable modification data.</p>
<h2 id="interfaces-1"><a class="header" href="#interfaces-1">Interfaces</a></h2>
<h3 id="imappingprovider-1"><a class="header" href="#imappingprovider-1">IMappingProvider</a></h3>
<p>Interface for name mapping.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>String getClassName(String name)</code> - Map class name</li>
<li><code>String getMethodName(String className, String methodName, String descriptor)</code> - Map method name</li>
<li><code>String getFieldName(String className, String fieldName)</code> - Map field name</li>
</ul>
<h3 id="implementation-examples"><a class="header" href="#implementation-examples">Implementation Examples</a></h3>
<p><strong>EmptyMappingProvider</strong> - No-op mapping (returns unchanged names)</p>
<p><strong>Custom Mapping:</strong></p>
<pre><code class="language-java">public class CustomMapping implements IMappingProvider {
    @Override
    public String getClassName(String name) {
        // Custom mapping logic
        return name;
    }
    
    @Override
    public String getMethodName(String className, String methodName, String descriptor) {
        // Custom mapping logic
        return methodName;
    }
    
    @Override
    public String getFieldName(String className, String fieldName) {
        // Custom mapping logic
        return fieldName;
    }
}
</code></pre>
<h2 id="utility-classes-1"><a class="header" href="#utility-classes-1">Utility Classes</a></h2>
<h3 id="descriptorparser-1"><a class="header" href="#descriptorparser-1">DescriptorParser</a></h3>
<p>Parse and validate method descriptors.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>static String parseDescriptor(String desc)</code> - Parse descriptor format</li>
</ul>
<h3 id="bytecodemanipulator-1"><a class="header" href="#bytecodemanipulator-1">BytecodeManipulator</a></h3>
<p>Low-level bytecode utilities.</p>
<p><strong>Purpose:</strong> Internal utilities for bytecode manipulation.</p>
<h2 id="inheritance-hierarchy"><a class="header" href="#inheritance-hierarchy">Inheritance Hierarchy</a></h2>
<pre><code>Object
├── BytekinTransformer
│   └── BytekinTransformer.Builder
├── CallbackInfo
├── Injection
├── Invocation
├── RedirectData
├── ConstantModification
└── VariableModification
</code></pre>
<h2 id="interface-implementations"><a class="header" href="#interface-implementations">Interface Implementations</a></h2>
<pre><code>IMappingProvider
├── EmptyMappingProvider
└── (Custom implementations)
</code></pre>
<h2 id="next-steps-19"><a class="header" href="#next-steps-19">Next Steps</a></h2>
<ul>
<li>Review <a href="./api-reference.html">API Reference</a></li>
<li>Check <a href="./annotations.html">Annotations</a></li>
<li>Explore <a href="./examples.html">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-3"><a class="header" href="#examples-3">Examples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples---basic-usage"><a class="header" href="#examples---basic-usage">Examples - Basic Usage</a></h1>
<p>This section contains complete, working examples for common bytekin use cases.</p>
<h2 id="example-1-adding-logging"><a class="header" href="#example-1-adding-logging">Example 1: Adding Logging</a></h2>
<h3 id="problem"><a class="header" href="#problem">Problem</a></h3>
<p>Add logging to a method without modifying source code.</p>
<h3 id="solution"><a class="header" href="#solution">Solution</a></h3>
<p><strong>Target Class:</strong></p>
<pre><code class="language-java">package com.example;

public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}
</code></pre>
<p><strong>Hook Class:</strong></p>
<pre><code class="language-java">package com.example;

import io.github.brqnko.bytekin.injection.*;
import io.github.brqnko.bytekin.data.CallbackInfo;

@ModifyClass("com.example.Calculator")
public class CalculatorLoggingHooks {

    @Inject(
        methodName = "add",
        methodDesc = "(II)I",
        at = At.HEAD
    )
    public static CallbackInfo logAddition(int a, int b) {
        System.out.println("Adding: " + a + " + " + b);
        return CallbackInfo.empty();
    }
}
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        BytekinTransformer transformer = new BytekinTransformer.Builder(
            CalculatorLoggingHooks.class
        ).build();

        byte[] original = getClassBytecode("com.example.Calculator");
        byte[] transformed = transformer.transform("com.example.Calculator", original);
        
        Calculator calc = loadTransformed(transformed);
        int result = calc.add(5, 3);
        // Output:
        // Adding: 5 + 3
        // 8
    }
}
</code></pre>
<h2 id="example-2-parameter-validation"><a class="header" href="#example-2-parameter-validation">Example 2: Parameter Validation</a></h2>
<h3 id="problem-1"><a class="header" href="#problem-1">Problem</a></h3>
<p>Validate method parameters before execution.</p>
<h3 id="solution-1"><a class="header" href="#solution-1">Solution</a></h3>
<p><strong>Hook Class:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.UserService")
public class UserValidationHooks {

    @Inject(
        methodName = "createUser",
        methodDesc = "(Ljava/lang/String;I)V",
        at = At.HEAD
    )
    public static CallbackInfo validateUser(String name, int age, CallbackInfo ci) {
        if (name == null || name.isEmpty()) {
            System.out.println("ERROR: Name cannot be empty");
            ci.cancelled = true;
            return ci;
        }
        
        if (age &lt; 18) {
            System.out.println("ERROR: User must be 18 or older");
            ci.cancelled = true;
            return ci;
        }
        
        System.out.println("Valid user: " + name + ", age " + age);
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="example-3-caching"><a class="header" href="#example-3-caching">Example 3: Caching</a></h2>
<h3 id="problem-2"><a class="header" href="#problem-2">Problem</a></h3>
<p>Intercept method calls to implement caching.</p>
<h3 id="solution-2"><a class="header" href="#solution-2">Solution</a></h3>
<p><strong>Hook Class:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.DataRepository")
public class CachingHooks {
    private static final Map&lt;String, Object&gt; cache = new ConcurrentHashMap&lt;&gt;();

    @Invoke(
        targetMethodName = "fetch",
        targetMethodDesc = "(Ljava/lang/String;)Ljava/lang/Object;",
        invokeMethodName = "queryDatabase",
        invokeMethodDesc = "(Ljava/lang/String;)Ljava/lang/Object;",
        shift = Shift.BEFORE
    )
    public static CallbackInfo checkCache(String key, CallbackInfo ci) {
        Object cached = cache.get(key);
        if (cached != null) {
            System.out.println("Cache hit for: " + key);
            ci.cancelled = true;
            ci.returnValue = cached;
        } else {
            System.out.println("Cache miss for: " + key);
        }
        return ci;
    }
}
</code></pre>
<h2 id="example-4-security---authentication-check"><a class="header" href="#example-4-security---authentication-check">Example 4: Security - Authentication Check</a></h2>
<h3 id="problem-3"><a class="header" href="#problem-3">Problem</a></h3>
<p>Ensure all sensitive methods require authentication.</p>
<h3 id="solution-3"><a class="header" href="#solution-3">Solution</a></h3>
<p><strong>Hook Class:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.PaymentService")
public class AuthenticationHooks {

    @Inject(
        methodName = "transfer",
        methodDesc = "(Ljava/lang/String;J)Z",
        at = At.HEAD
    )
    public static CallbackInfo checkAuthentication(String account, long amount, CallbackInfo ci) {
        if (!isUserAuthenticated()) {
            System.out.println("ERROR: Authentication required");
            ci.cancelled = true;
            ci.returnValue = false;
            return ci;
        }
        
        System.out.println("Authenticated transfer: " + amount);
        return CallbackInfo.empty();
    }

    private static boolean isUserAuthenticated() {
        // Check authentication status
        return true;
    }
}
</code></pre>
<h2 id="example-5-monitoring---method-call-counter"><a class="header" href="#example-5-monitoring---method-call-counter">Example 5: Monitoring - Method Call Counter</a></h2>
<h3 id="problem-4"><a class="header" href="#problem-4">Problem</a></h3>
<p>Count how many times specific methods are called.</p>
<h3 id="solution-4"><a class="header" href="#solution-4">Solution</a></h3>
<p><strong>Hook Class:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.UserService")
public class MonitoringHooks {
    private static final AtomicInteger callCount = new AtomicInteger(0);

    @Inject(
        methodName = "getUser",
        methodDesc = "(I)Lcom/example/User;",
        at = At.HEAD
    )
    public static CallbackInfo countCalls(int userId) {
        int count = callCount.incrementAndGet();
        if (count % 100 == 0) {
            System.out.println("getUser() called " + count + " times");
        }
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="example-6-transforming-return-values"><a class="header" href="#example-6-transforming-return-values">Example 6: Transforming Return Values</a></h2>
<h3 id="problem-5"><a class="header" href="#problem-5">Problem</a></h3>
<p>Modify the return value of a method.</p>
<h3 id="solution-5"><a class="header" href="#solution-5">Solution</a></h3>
<p><strong>Hook Class:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.PriceCalculator")
public class PriceHooks {

    @Inject(
        methodName = "getPrice",
        methodDesc = "()D",
        at = At.RETURN
    )
    public static CallbackInfo applyDiscount(CallbackInfo ci) {
        double originalPrice = (double) ci.returnValue;
        double discounted = originalPrice * 0.9;  // 10% discount
        ci.returnValue = discounted;
        return ci;
    }
}
</code></pre>
<h2 id="invoke-examples"><a class="header" href="#invoke-examples">Invoke Examples</a></h2>
<h3 id="example-method-call-interception"><a class="header" href="#example-method-call-interception">Example: Method Call Interception</a></h3>
<p><strong>Hook Class:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.DataProcessor")
public class ProcessorHooks {

    @Invoke(
        targetMethodName = "process",
        targetMethodDesc = "(Ljava/lang/String;)Ljava/lang/String;",
        invokeMethodName = "validate",
        invokeMethodDesc = "(Ljava/lang/String;)Ljava/lang/String;",
        shift = Shift.BEFORE
    )
    public static CallbackInfo sanitizeBeforeValidation(String data, CallbackInfo ci) {
        String sanitized = data.trim().toLowerCase();
        ci.modifyArgs = new Object[]{sanitized};
        return ci;
    }
}
</code></pre>
<h2 id="combined-example-comprehensive-transformation"><a class="header" href="#combined-example-comprehensive-transformation">Combined Example: Comprehensive Transformation</a></h2>
<p><strong>Complete Hook Class:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.UserRepository")
public class ComprehensiveHooks {

    @Inject(
        methodName = "save",
        methodDesc = "(Lcom/example/User;)V",
        at = At.HEAD
    )
    public static CallbackInfo validateBeforeSave(Object user, CallbackInfo ci) {
        // Validate input
        if (user == null) {
            System.out.println("ERROR: Cannot save null user");
            ci.cancelled = true;
        }
        return ci;
    }

    @Invoke(
        targetMethodName = "save",
        targetMethodDesc = "(Lcom/example/User;)V",
        invokeMethodName = "validateUser",
        invokeMethodDesc = "(Lcom/example/User;)Z",
        shift = Shift.BEFORE
    )
    public static CallbackInfo modifyValidation(Object user, CallbackInfo ci) {
        // Enhance validation
        System.out.println("Validating user...");
        return ci;
    }

    @Inject(
        methodName = "save",
        methodDesc = "(Lcom/example/User;)V",
        at = At.RETURN
    )
    public static CallbackInfo logSuccess(Object user) {
        System.out.println("User saved successfully");
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="next-steps-20"><a class="header" href="#next-steps-20">Next Steps</a></h2>
<ul>
<li>Review <a href="./examples-advanced.html">Advanced Examples</a></li>
<li>Check <a href="./best-practices.html">Best Practices</a></li>
<li>Explore more <a href="./features.html">Features</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-examples"><a class="header" href="#advanced-examples">Advanced Examples</a></h1>
<p>Advanced use cases and patterns for bytekin.</p>
<h2 id="example-1-custom-classloader"><a class="header" href="#example-1-custom-classloader">Example 1: Custom ClassLoader</a></h2>
<p>Implement a custom ClassLoader that applies transformations:</p>
<pre><code class="language-java">public class TransformingClassLoader extends ClassLoader {
    private final BytekinTransformer transformer;
    private final ClassLoader parent;
    
    public TransformingClassLoader(BytekinTransformer transformer, ClassLoader parent) {
        super(parent);
        this.transformer = transformer;
        this.parent = parent;
    }
    
    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        try {
            byte[] classBytes = loadBytesFromClasspath(name);
            byte[] transformed = transformer.transform(name, classBytes);
            return defineClass(name, transformed, 0, transformed.length);
        } catch (IOException e) {
            throw new ClassNotFoundException("Cannot find " + name, e);
        }
    }
    
    private byte[] loadBytesFromClasspath(String className) throws IOException {
        String path = className.replace('.', '/') + ".class";
        try (InputStream is = parent.getResourceAsStream(path)) {
            return is.readAllBytes();
        }
    }
}

// Usage
BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class).build();
ClassLoader loader = new TransformingClassLoader(transformer, ClassLoader.getSystemClassLoader());
Class&lt;?&gt; clazz = loader.loadClass("com.example.MyClass");
</code></pre>
<h2 id="example-2-java-agent"><a class="header" href="#example-2-java-agent">Example 2: Java Agent</a></h2>
<p>Create a Java agent for bytecode transformation:</p>
<pre><code class="language-java">public class BytekinAgent {
    public static void premain(String agentArgs, Instrumentation inst) {
        BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class).build();
        inst.addTransformer((loader, className, klass, pd, bytecode) -&gt; {
            return transformer.transform(className, bytecode);
        });
    }
}
</code></pre>
<p>Launch with: <code>java -javaagent:bytekin-agent.jar MyApplication</code></p>
<h2 id="example-3-aspect-oriented-programming-aop"><a class="header" href="#example-3-aspect-oriented-programming-aop">Example 3: Aspect-Oriented Programming (AOP)</a></h2>
<p>Implement cross-cutting concerns:</p>
<pre><code class="language-java">@ModifyClass("com.example.UserService")
public class AuditingAspect {
    
    @Inject(methodName = "save", methodDesc = "(Lcom/example/User;)V", at = At.HEAD)
    public static CallbackInfo auditBefore(Object user) {
        System.out.println("Audit: save() started");
        return CallbackInfo.empty();
    }
    
    @Inject(methodName = "delete", methodDesc = "(I)V", at = At.HEAD)
    public static CallbackInfo auditDelete(int id) {
        System.out.println("Audit: delete(" + id + ") started");
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="example-4-lazy-initialization"><a class="header" href="#example-4-lazy-initialization">Example 4: Lazy Initialization</a></h2>
<p>Implement lazy loading pattern:</p>
<pre><code class="language-java">@ModifyClass("com.example.Repository")
public class LazyLoadingHooks {
    private static Object resource;
    
    @Inject(methodName = "initialize", methodDesc = "()V", at = At.HEAD)
    public static CallbackInfo lazyInit(CallbackInfo ci) {
        if (resource == null) {
            synchronized (LazyLoadingHooks.class) {
                if (resource == null) {
                    resource = loadExpensiveResource();
                }
            }
        }
        ci.cancelled = true;
        return ci;
    }
    
    private static Object loadExpensiveResource() {
        // Expensive initialization
        return new Object();
    }
}
</code></pre>
<h2 id="example-5-dynamic-configuration"><a class="header" href="#example-5-dynamic-configuration">Example 5: Dynamic Configuration</a></h2>
<p>Change behavior based on configuration:</p>
<pre><code class="language-java">@ModifyClass("com.example.Service")
public class DynamicConfigHooks {
    private static final Properties config = new Properties();
    
    static {
        try {
            config.load(new FileInputStream("config.properties"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    @Inject(methodName = "process", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
    public static CallbackInfo checkConfig(String input, CallbackInfo ci) {
        boolean enabled = Boolean.parseBoolean(config.getProperty("feature.enabled", "false"));
        if (!enabled) {
            ci.cancelled = true;
        }
        return ci;
    }
}
</code></pre>
<h2 id="example-6-multi-layer-transformation"><a class="header" href="#example-6-multi-layer-transformation">Example 6: Multi-Layer Transformation</a></h2>
<p>Apply multiple transformers sequentially:</p>
<pre><code class="language-java">public class MultiLayerTransformation {
    public static void main(String[] args) {
        BytekinTransformer logging = new BytekinTransformer.Builder(LoggingHooks.class).build();
        BytekinTransformer security = new BytekinTransformer.Builder(SecurityHooks.class).build();
        BytekinTransformer caching = new BytekinTransformer.Builder(CachingHooks.class).build();
        
        byte[] original = getClassBytecode("com.example.Service");
        
        // Apply layer by layer
        byte[] withLogging = logging.transform("com.example.Service", original);
        byte[] withSecurity = security.transform("com.example.Service", withLogging);
        byte[] withCaching = caching.transform("com.example.Service", withSecurity);
        
        Class&lt;?&gt; transformed = loadClass(withCaching);
    }
}
</code></pre>
<h2 id="example-7-performance-profiling"><a class="header" href="#example-7-performance-profiling">Example 7: Performance Profiling</a></h2>
<p>Add profiling without source changes:</p>
<pre><code class="language-java">@ModifyClass("com.example.CriticalPath")
public class ProfilingHooks {
    private static final ThreadLocal&lt;Long&gt; timer = ThreadLocal.withInitial(() -&gt; 0L);
    
    @Inject(methodName = "compute", methodDesc = "()Ljava/lang/Object;", at = At.HEAD)
    public static CallbackInfo startProfiling() {
        timer.set(System.nanoTime());
        return CallbackInfo.empty();
    }
    
    @Inject(methodName = "compute", methodDesc = "()Ljava/lang/Object;", at = At.RETURN)
    public static CallbackInfo endProfiling() {
        long duration = System.nanoTime() - timer.get();
        System.out.println("Duration: " + (duration / 1_000_000.0) + "ms");
        return CallbackInfo.empty();
    }
}
</code></pre>
<h2 id="example-8-resilience-pattern"><a class="header" href="#example-8-resilience-pattern">Example 8: Resilience Pattern</a></h2>
<p>Add retry logic:</p>
<pre><code class="language-java">@ModifyClass("com.example.HttpClient")
public class ResilienceHooks {
    private static final int MAX_RETRIES = 3;
    
    @Inject(methodName = "request", methodDesc = "(Ljava/lang/String;)Ljava/lang/String;", 
            at = At.HEAD)
    public static CallbackInfo addRetry(String url, CallbackInfo ci) {
        String result = null;
        int attempt = 0;
        
        while (attempt &lt; MAX_RETRIES) {
            try {
                result = executeRequest(url);
                break;
            } catch (Exception e) {
                attempt++;
                if (attempt &gt;= MAX_RETRIES) throw e;
            }
        }
        
        ci.cancelled = true;
        ci.returnValue = result;
        return ci;
    }
    
    private static String executeRequest(String url) throws Exception {
        // Make HTTP request
        return "";
    }
}
</code></pre>
<h2 id="example-9-observability"><a class="header" href="#example-9-observability">Example 9: Observability</a></h2>
<p>Collect metrics:</p>
<pre><code class="language-java">@ModifyClass("com.example.DataStore")
public class ObservabilityHooks {
    private static final AtomicLong callCount = new AtomicLong(0);
    private static final AtomicLong errorCount = new AtomicLong(0);
    
    @Inject(methodName = "query", methodDesc = "(Ljava/lang/String;)Ljava/util/List;", 
            at = At.HEAD)
    public static CallbackInfo trackCall(String query) {
        callCount.incrementAndGet();
        return CallbackInfo.empty();
    }
    
    @Invoke(
        targetMethodName = "query",
        targetMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
        invokeMethodName = "throwException",
        invokeMethodDesc = "()V",
        shift = Shift.BEFORE
    )
    public static CallbackInfo trackError() {
        errorCount.incrementAndGet();
        return CallbackInfo.empty();
    }
    
    public static void printMetrics() {
        System.out.println("Calls: " + callCount.get());
        System.out.println("Errors: " + errorCount.get());
    }
}
</code></pre>
<h2 id="example-10-migration-strategy"><a class="header" href="#example-10-migration-strategy">Example 10: Migration Strategy</a></h2>
<p>Gradually migrate from old to new API:</p>
<pre><code class="language-java">@ModifyClass("com.example.Application")
public class MigrationHooks {
    private static final boolean USE_NEW_API = true;
    
    @Redirect(
        targetMethodName = "main",
        targetMethodDesc = "([Ljava/lang/String;)V",
        redirectMethodName = "oldSearch",
        redirectMethodDesc = "(Ljava/lang/String;)Ljava/util/List;",
        from = "search",
        to = USE_NEW_API ? "newSearch" : "oldSearch"
    )
    public static void migrateAPI() {
        // Gradually route to new implementation
    }
}
</code></pre>
<h2 id="next-steps-21"><a class="header" href="#next-steps-21">Next Steps</a></h2>
<ul>
<li>Review <a href="./best-practices.html">Best Practices</a></li>
<li>Check <a href="./troubleshooting.html">Troubleshooting</a></li>
<li>Explore <a href="./advanced-usage.html">Advanced Usage</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h1>
<p>This guide covers best practices for using bytekin effectively and safely.</p>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<h3 id="1-keep-hooks-simple"><a class="header" href="#1-keep-hooks-simple">1. Keep Hooks Simple</a></h3>
<p>Keep hook methods focused and simple:</p>
<p><strong>Good:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "()V", at = At.HEAD)
public static CallbackInfo log() {
    System.out.println("Starting process");
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>Avoid:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "()V", at = At.HEAD)
public static CallbackInfo complexLogic() {
    // Multiple database calls
    // Complex calculations
    // File I/O operations
    // This is too much for a hook!
    return CallbackInfo.empty();
}
</code></pre>
<h3 id="2-extract-complex-logic"><a class="header" href="#2-extract-complex-logic">2. Extract Complex Logic</a></h3>
<p>Move complex logic to separate methods:</p>
<pre><code class="language-java">@Inject(methodName = "validate", methodDesc = "(Ljava/lang/String;)Z", at = At.HEAD)
public static CallbackInfo onValidate(String input, CallbackInfo ci) {
    if (!isValidInput(input)) {
        ci.cancelled = true;
        ci.returnValue = false;
    }
    return ci;
}

private static boolean isValidInput(String input) {
    // Complex validation logic here
    return !input.isEmpty() &amp;&amp; input.length() &lt; 256;
}
</code></pre>
<h2 id="performance-guidelines"><a class="header" href="#performance-guidelines">Performance Guidelines</a></h2>
<h3 id="1-minimize-hook-overhead"><a class="header" href="#1-minimize-hook-overhead">1. Minimize Hook Overhead</a></h3>
<p>Hooks are executed frequently. Keep them fast:</p>
<p><strong>Good:</strong></p>
<pre><code class="language-java">@Inject(methodName = "getData", methodDesc = "()Ljava/lang/Object;", at = At.HEAD)
public static CallbackInfo checkCache() {
    if (cacheHit()) {
        // Quick cache lookup
        return new CallbackInfo(true, getFromCache(), null);
    }
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>Avoid:</strong></p>
<pre><code class="language-java">@Inject(methodName = "getData", methodDesc = "()Ljava/lang/Object;", at = At.HEAD)
public static CallbackInfo expensiveCheck() {
    // Scanning entire database
    List&lt;Item&gt; results = database.queryAll();
    // Processing results
    // ...this is too slow!
    return CallbackInfo.empty();
}
</code></pre>
<h3 id="2-reuse-builder"><a class="header" href="#2-reuse-builder">2. Reuse Builder</a></h3>
<p>Build transformers once and reuse:</p>
<p><strong>Good:</strong></p>
<pre><code class="language-java">// In initialization code
BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
    .build();

// Use transformer multiple times
byte[] transformed1 = transformer.transform("com.example.Class1", bytes1);
byte[] transformed2 = transformer.transform("com.example.Class2", bytes2);
</code></pre>
<p><strong>Avoid:</strong></p>
<pre><code class="language-java">// DON'T do this in a loop!
for (String className : classNames) {
    // Creating transformer for each class is wasteful
    BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
        .build();
    byte[] transformed = transformer.transform(className, bytes);
}
</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="1-handle-exceptions-in-hooks"><a class="header" href="#1-handle-exceptions-in-hooks">1. Handle Exceptions in Hooks</a></h3>
<p>Exceptions in hooks can break transformations:</p>
<p><strong>Good:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "()V", at = At.HEAD)
public static CallbackInfo safeLogging() {
    try {
        System.out.println("Processing started");
    } catch (Exception e) {
        // Handle gracefully, don't let it propagate
        e.printStackTrace();
    }
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>Avoid:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "()V", at = At.HEAD)
public static CallbackInfo unsafeLogging() {
    // If this throws, it breaks the transformation!
    Path path = Paths.get("/invalid/path");
    Files.writeString(path, "log");
    return CallbackInfo.empty();
}
</code></pre>
<h3 id="2-validate-return-values"><a class="header" href="#2-validate-return-values">2. Validate Return Values</a></h3>
<p>When modifying CallbackInfo, ensure types are correct:</p>
<p><strong>Good:</strong></p>
<pre><code class="language-java">@Inject(methodName = "getValue", methodDesc = "()I", at = At.HEAD)
public static CallbackInfo returnCustomValue() {
    CallbackInfo ci = new CallbackInfo();
    ci.cancelled = true;
    ci.returnValue = 42;  // Integer matches return type
    return ci;
}
</code></pre>
<p><strong>Avoid:</strong></p>
<pre><code class="language-java">@Inject(methodName = "getValue", methodDesc = "()I", at = At.HEAD)
public static CallbackInfo wrongType() {
    CallbackInfo ci = new CallbackInfo();
    ci.cancelled = true;
    ci.returnValue = "42";  // String doesn't match int return type!
    return ci;
}
</code></pre>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<h3 id="1-document-transformations"><a class="header" href="#1-document-transformations">1. Document Transformations</a></h3>
<p>Clearly document what each hook does:</p>
<pre><code class="language-java">/**
 * Adds authentication check to all data access methods.
 * If user is not authenticated, cancels the method and returns false.
 */
@ModifyClass("com.example.DataStore")
public class DataStoreHooks {

    /**
     * Injects authentication check at the start of read operations.
     * 
     * @param ci Callback info - set cancelled=true if not authenticated
     */
    @Inject(methodName = "read", methodDesc = "()Ljava/lang/Object;", at = At.HEAD)
    public static CallbackInfo ensureAuthenticated(CallbackInfo ci) {
        if (!isAuthenticated()) {
            ci.cancelled = true;
            ci.returnValue = null;
        }
        return ci;
    }
}
</code></pre>
<h3 id="2-document-parameters"><a class="header" href="#2-document-parameters">2. Document Parameters</a></h3>
<p>Clearly indicate which parameters correspond to method arguments:</p>
<pre><code class="language-java">/**
 * Sanitizes user input before processing.
 * 
 * @param userId the user ID (first parameter of target method)
 * @param action the requested action (second parameter)
 */
@Inject(methodName = "execute", methodDesc = "(Ljava/lang/String;Ljava/lang/String;)V", 
        at = At.HEAD)
public static CallbackInfo sanitizeInput(String userId, String action) {
    // userId and action are from the target method's parameters
    return CallbackInfo.empty();
}
</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<h3 id="1-test-transformations"><a class="header" href="#1-test-transformations">1. Test Transformations</a></h3>
<p>Always test your transformations:</p>
<pre><code class="language-java">public class TransformationTest {
    @Test
    public void testInjectionWorks() {
        BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
            .build();
        
        byte[] original = getClassBytecode("com.example.Target");
        byte[] transformed = transformer.transform("com.example.Target", original);
        
        // Load and test transformed class
        Class&lt;?&gt; clazz = loadFromBytecode(transformed);
        Object instance = clazz.newInstance();
        
        // Verify transformation was applied
        assertNotNull(instance);
    }
}
</code></pre>
<h3 id="2-verify-no-regression"><a class="header" href="#2-verify-no-regression">2. Verify No Regression</a></h3>
<p>Ensure original behavior is preserved:</p>
<pre><code class="language-java">@Test
public void testOriginalBehaviorPreserved() {
    // Test without transformation
    Calculator calc1 = new Calculator();
    int result1 = calc1.add(3, 4);
    
    // Test with transformation
    byte[] transformed = applyTransformation(Calculator.class);
    Calculator calc2 = loadTransformed(transformed);
    int result2 = calc2.add(3, 4);
    
    // Results should be the same
    assertEquals(result1, result2);
}
</code></pre>
<h2 id="compatibility"><a class="header" href="#compatibility">Compatibility</a></h2>
<h3 id="1-version-compatibility"><a class="header" href="#1-version-compatibility">1. Version Compatibility</a></h3>
<p>Document supported Java versions:</p>
<pre><code class="language-java">/**
 * These hooks work with Java 8+
 * Uses standard method descriptors compatible across versions
 */
@ModifyClass("com.example.Service")
public class CompatibleHooks {
    // ...
}
</code></pre>
<h3 id="2-library-compatibility"><a class="header" href="#2-library-compatibility">2. Library Compatibility</a></h3>
<p>Check for incompatibilities with other bytecode tools:</p>
<pre><code class="language-java">// Document conflicts with other bytecode manipulation
// For example: Spring, Mockito, AspectJ, etc.
</code></pre>
<h2 id="security"><a class="header" href="#security">Security</a></h2>
<h3 id="1-input-validation"><a class="header" href="#1-input-validation">1. Input Validation</a></h3>
<p>Always validate inputs in hooks:</p>
<pre><code class="language-java">@Inject(methodName = "processFile", methodDesc = "(Ljava/lang/String;)V", 
        at = At.HEAD)
public static CallbackInfo validatePath(String path, CallbackInfo ci) {
    if (path != null &amp;&amp; isPathTraversal(path)) {
        // Prevent directory traversal attacks
        ci.cancelled = true;
    }
    return ci;
}

private static boolean isPathTraversal(String path) {
    return path.contains("..") || path.startsWith("/");
}
</code></pre>
<h3 id="2-avoid-sensitive-data-exposure"><a class="header" href="#2-avoid-sensitive-data-exposure">2. Avoid Sensitive Data Exposure</a></h3>
<p>Don't log or expose sensitive information:</p>
<p><strong>Good:</strong></p>
<pre><code class="language-java">@Inject(methodName = "login", methodDesc = "(Ljava/lang/String;Ljava/lang/String;)Z", 
        at = At.HEAD)
public static CallbackInfo logAttempt(String user) {
    System.out.println("Login attempt by: " + user);
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>Avoid:</strong></p>
<pre><code class="language-java">@Inject(methodName = "login", methodDesc = "(Ljava/lang/String;Ljava/lang/String;)Z", 
        at = At.HEAD)
public static CallbackInfo logAttempt(String user, String password) {
    // Don't log passwords!
    System.out.println("Login attempt: " + user + " / " + password);
    return CallbackInfo.empty();
}
</code></pre>
<h2 id="debugging-tips"><a class="header" href="#debugging-tips">Debugging Tips</a></h2>
<h3 id="1-bytecode-inspection"><a class="header" href="#1-bytecode-inspection">1. Bytecode Inspection</a></h3>
<p>Inspect generated bytecode to verify transformations:</p>
<pre><code class="language-bash"># Use javap to inspect the transformed class
javap -c TransformedClass.class

# Look for your injected method calls
</code></pre>
<h3 id="2-add-logging"><a class="header" href="#2-add-logging">2. Add Logging</a></h3>
<p>Use logging to track transformation execution:</p>
<pre><code class="language-java">@Inject(methodName = "critical", methodDesc = "()V", at = At.HEAD)
public static CallbackInfo logEntry() {
    System.out.println("[DEBUG] Entering critical method");
    System.out.println("[DEBUG] Stack trace: " + Arrays.toString(Thread.currentThread().getStackTrace()));
    return CallbackInfo.empty();
}
</code></pre>
<h2 id="maintenance"><a class="header" href="#maintenance">Maintenance</a></h2>
<h3 id="1-version-your-hooks"><a class="header" href="#1-version-your-hooks">1. Version Your Hooks</a></h3>
<p>Keep track of hook versions:</p>
<pre><code class="language-java">/**
 * Transformation hooks for version 2.0
 * 
 * Changes from v1.0:
 * - Added authentication checks
 * - Optimized caching strategy
 * - Fixed null pointer issue in legacy code
 */
@ModifyClass("com.example.Service")
public class ServiceHooksV2 {
    // ...
}
</code></pre>
<h3 id="2-keep-records"><a class="header" href="#2-keep-records">2. Keep Records</a></h3>
<p>Document why each transformation exists:</p>
<pre><code>Transform: Calculator.add() logging
Created: 2025-01-15
Reason: Performance monitoring for debug builds
Status: Active
Notes: Can be removed after profiling phase
</code></pre>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="1-wrong-method-descriptors"><a class="header" href="#1-wrong-method-descriptors">1. Wrong Method Descriptors</a></h3>
<p>❌ <strong>Wrong:</strong></p>
<pre><code class="language-java">@Inject(methodName = "add", methodDesc = "(I I)I", at = At.HEAD)  // Spaces in descriptor!
</code></pre>
<p>✅ <strong>Right:</strong></p>
<pre><code class="language-java">@Inject(methodName = "add", methodDesc = "(II)I", at = At.HEAD)
</code></pre>
<h3 id="2-type-mismatches"><a class="header" href="#2-type-mismatches">2. Type Mismatches</a></h3>
<p>❌ <strong>Wrong:</strong></p>
<pre><code class="language-java">@Invoke(..., invokeMethodDesc = "(I)V", shift = Shift.BEFORE)
public static CallbackInfo hook(String param) {  // Type mismatch!
}
</code></pre>
<p>✅ <strong>Right:</strong></p>
<pre><code class="language-java">@Invoke(..., invokeMethodDesc = "(I)V", shift = Shift.BEFORE)
public static CallbackInfo hook(int param) {  // Correct type
}
</code></pre>
<h3 id="3-modifying-immutable-data"><a class="header" href="#3-modifying-immutable-data">3. Modifying Immutable Data</a></h3>
<p>❌ <strong>Wrong:</strong></p>
<pre><code class="language-java">@ModifyVariable(methodName = "process", variableIndex = 1)
public static void modify(String str) {
    str = str.toUpperCase();  // Strings are immutable, won't work!
}
</code></pre>
<p>✅ <strong>Right:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
public static CallbackInfo modifyByReplacing(String str, CallbackInfo ci) {
    ci.modifyArgs = new Object[]{str.toUpperCase()};
    return ci;
}
</code></pre>
<h2 id="next-steps-22"><a class="header" href="#next-steps-22">Next Steps</a></h2>
<ul>
<li>Review <a href="./api-reference.html">API Reference</a></li>
<li>Check out <a href="./examples.html">Examples</a></li>
<li>Join the community and share your patterns</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq---frequently-asked-questions"><a class="header" href="#faq---frequently-asked-questions">FAQ - Frequently Asked Questions</a></h1>
<h2 id="general-questions"><a class="header" href="#general-questions">General Questions</a></h2>
<h3 id="what-is-bytekin-1"><a class="header" href="#what-is-bytekin-1">What is bytekin?</a></h3>
<p>bytekin is a lightweight Java bytecode transformation framework built on ASM. It allows you to modify Java classes at the bytecode level without touching the source code.</p>
<h3 id="why-would-i-need-bytecode-transformation"><a class="header" href="#why-would-i-need-bytecode-transformation">Why would I need bytecode transformation?</a></h3>
<p>Common use cases include:</p>
<ul>
<li>Adding logging without modifying source code</li>
<li>Implementing cross-cutting concerns</li>
<li>Testing and mocking</li>
<li>Performance profiling</li>
<li>Security enhancements</li>
</ul>
<h3 id="how-does-bytekin-compare-to-other-tools"><a class="header" href="#how-does-bytekin-compare-to-other-tools">How does bytekin compare to other tools?</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Size</th><th>Complexity</th><th>Use Case</th></tr></thead><tbody>
<tr><td>bytekin</td><td>Small</td><td>Simple</td><td>Direct bytecode manipulation</td></tr>
<tr><td>Spring AOP</td><td>Large</td><td>Complex</td><td>Enterprise framework</td></tr>
<tr><td>Mockito</td><td>Medium</td><td>Medium</td><td>Testing/Mocking</td></tr>
<tr><td>Aspect</td><td>Medium</td><td>Complex</td><td>Aspect-oriented programming</td></tr>
</tbody></table>
</div>
<h3 id="is-bytekin-production-ready"><a class="header" href="#is-bytekin-production-ready">Is bytekin production-ready?</a></h3>
<p>Yes, bytekin is designed for production use. It has minimal dependencies (only ASM) and has been tested thoroughly.</p>
<h2 id="technical-questions"><a class="header" href="#technical-questions">Technical Questions</a></h2>
<h3 id="what-java-versions-does-bytekin-support"><a class="header" href="#what-java-versions-does-bytekin-support">What Java versions does bytekin support?</a></h3>
<p>bytekin requires <strong>Java 8 or higher</strong>.</p>
<h3 id="can-i-use-bytekin-with-spring-boot"><a class="header" href="#can-i-use-bytekin-with-spring-boot">Can I use bytekin with Spring Boot?</a></h3>
<p>Yes! bytekin can work alongside Spring Boot. You would typically apply transformations during a custom <code>ClassLoader</code> setup or at build time.</p>
<h3 id="does-bytekin-work-with-obfuscated-code"><a class="header" href="#does-bytekin-work-with-obfuscated-code">Does bytekin work with obfuscated code?</a></h3>
<p>Yes, with mappings! Use the mapping system to handle obfuscated class and method names.</p>
<h3 id="can-i-combine-multiple-transformations"><a class="header" href="#can-i-combine-multiple-transformations">Can I combine multiple transformations?</a></h3>
<p>Yes! You can use multiple <code>@Inject</code>, <code>@Invoke</code>, and other annotations on the same class. They all get applied.</p>
<h2 id="usage-questions"><a class="header" href="#usage-questions">Usage Questions</a></h2>
<h3 id="how-do-i-find-the-method-descriptor-for-a-method"><a class="header" href="#how-do-i-find-the-method-descriptor-for-a-method">How do I find the method descriptor for a method?</a></h3>
<p>Use <code>javap</code>:</p>
<pre><code class="language-bash">javap -c MyClass.class
</code></pre>
<p>Look at the method signature and convert it to JVM descriptor format:</p>
<ul>
<li><code>int add(int a, int b)</code> → <code>(II)I</code></li>
<li><code>String process(String s)</code> → <code>(Ljava/lang/String;)Ljava/lang/String;</code></li>
</ul>
<h3 id="whats-the-difference-between-inject-and-invoke"><a class="header" href="#whats-the-difference-between-inject-and-invoke">What's the difference between Inject and Invoke?</a></h3>
<ul>
<li><strong>Inject</strong>: Insert your code at a specific point in a method</li>
<li><strong>Invoke</strong>: Intercept a method call within a method and possibly modify arguments</li>
</ul>
<h3 id="can-i-cancel-a-method-execution"><a class="header" href="#can-i-cancel-a-method-execution">Can I cancel a method execution?</a></h3>
<p>Yes, set <code>ci.cancelled = true</code> in your hook method. However, this only works for certain transformation types.</p>
<h3 id="how-do-i-modify-method-arguments"><a class="header" href="#how-do-i-modify-method-arguments">How do I modify method arguments?</a></h3>
<p>Use <code>CallbackInfo.modifyArgs</code>:</p>
<pre><code class="language-java">ci.modifyArgs = new Object[]{ modifiedArg1, modifiedArg2 };
</code></pre>
<h3 id="can-i-access-static-fields-from-hook-methods"><a class="header" href="#can-i-access-static-fields-from-hook-methods">Can I access static fields from hook methods?</a></h3>
<p>Yes, you can reference static fields from your hook class:</p>
<pre><code class="language-java">@Inject(...)
public static CallbackInfo hook() {
    // Access static fields
    if (cacheEnabled) {
        // ...
    }
}
</code></pre>
<h2 id="performance-questions"><a class="header" href="#performance-questions">Performance Questions</a></h2>
<h3 id="whats-the-overhead-of-using-bytekin"><a class="header" href="#whats-the-overhead-of-using-bytekin">What's the overhead of using bytekin?</a></h3>
<ul>
<li><strong>Transformation time</strong>: Minimal, happens once at class load</li>
<li><strong>Runtime overhead</strong>: Zero! Transformed bytecode runs at same speed as hand-written code</li>
</ul>
<h3 id="should-i-rebuild-transformers-for-each-transform"><a class="header" href="#should-i-rebuild-transformers-for-each-transform">Should I rebuild transformers for each transform?</a></h3>
<p>No! Build once and reuse:</p>
<pre><code class="language-java">// Good
BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class).build();
for (String className : classNames) {
    byte[] transformed = transformer.transform(className, bytecode);
}

// Bad
for (String className : classNames) {
    BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class).build();
    byte[] transformed = transformer.transform(className, bytecode);
}
</code></pre>
<h3 id="how-much-does-bytecode-transformation-impact-startup-time"><a class="header" href="#how-much-does-bytecode-transformation-impact-startup-time">How much does bytecode transformation impact startup time?</a></h3>
<p>Impact is minimal when transformations are simple and applied only to necessary classes.</p>
<h2 id="troubleshooting-questions"><a class="header" href="#troubleshooting-questions">Troubleshooting Questions</a></h2>
<h3 id="my-transformations-arent-being-applied"><a class="header" href="#my-transformations-arent-being-applied">My transformations aren't being applied</a></h3>
<p>Common causes:</p>
<ol>
<li><strong>Wrong class name</strong>: Check the <code>@ModifyClass</code> value matches exactly</li>
<li><strong>Wrong method descriptor</strong>: Verify the <code>methodDesc</code> parameter</li>
<li><strong>Class not loaded</strong>: Ensure the class is loaded before transformation</li>
</ol>
<h3 id="im-getting-classcastexception"><a class="header" href="#im-getting-classcastexception">I'm getting ClassCastException</a></h3>
<p>This usually means:</p>
<ol>
<li>Type mismatch in <code>CallbackInfo.returnValue</code></li>
<li>Wrong type in hook method signature</li>
<li>Modifying arguments to incompatible types</li>
</ol>
<h3 id="hook-method-is-not-being-called"><a class="header" href="#hook-method-is-not-being-called">Hook method is not being called</a></h3>
<p>Check:</p>
<ol>
<li>Is the hook class passed to the Builder?</li>
<li>Are method name and descriptor correct?</li>
<li>Is the target class name correct?</li>
</ol>
<h3 id="javalangverifyerror"><a class="header" href="#javalangverifyerror">java.lang.VerifyError</a></h3>
<p>This means the transformed bytecode is invalid. Common causes:</p>
<ol>
<li>Incorrect bytecode modification</li>
<li>Type mismatches</li>
<li>Invalid method signatures</li>
</ol>
<h3 id="performance-degradation-after-transformation"><a class="header" href="#performance-degradation-after-transformation">Performance degradation after transformation</a></h3>
<p>If transformations are slow:</p>
<ol>
<li>Simplify hook methods</li>
<li>Avoid expensive operations in hooks</li>
<li>Use conditional logic to skip unnecessary work</li>
<li>Profile with a JVM profiler</li>
</ol>
<h2 id="advanced-questions"><a class="header" href="#advanced-questions">Advanced Questions</a></h2>
<h3 id="can-i-create-custom-transformers"><a class="header" href="#can-i-create-custom-transformers">Can I create custom transformers?</a></h3>
<p>Yes! You can extend the transformer classes or use the programmatic API instead of annotations.</p>
<h3 id="does-bytekin-support-method-overloading"><a class="header" href="#does-bytekin-support-method-overloading">Does bytekin support method overloading?</a></h3>
<p>Yes, by using the complete method descriptor which includes parameter types and return type.</p>
<h3 id="can-i-transform-the-same-class-multiple-times"><a class="header" href="#can-i-transform-the-same-class-multiple-times">Can I transform the same class multiple times?</a></h3>
<p>Yes, you can apply different transformations sequentially.</p>
<h3 id="is-bytekin-thread-safe"><a class="header" href="#is-bytekin-thread-safe">Is bytekin thread-safe?</a></h3>
<p>After building, <code>BytekinTransformer.transform()</code> is thread-safe and can be called from multiple threads concurrently.</p>
<h3 id="can-i-use-bytekin-with-java-agents"><a class="header" href="#can-i-use-bytekin-with-java-agents">Can I use bytekin with Java agents?</a></h3>
<p>Yes! bytekin works well with Java agents. Use it within your agent's <code>transform()</code> method.</p>
<h2 id="migration-and-upgrade-questions"><a class="header" href="#migration-and-upgrade-questions">Migration and Upgrade Questions</a></h2>
<h3 id="how-do-i-migrate-from-another-bytecode-tool"><a class="header" href="#how-do-i-migrate-from-another-bytecode-tool">How do I migrate from another bytecode tool?</a></h3>
<p>The concepts are similar:</p>
<ol>
<li>Define target classes</li>
<li>Create hook methods with transformation annotations</li>
<li>Build transformers</li>
<li>Apply transformations</li>
</ol>
<h3 id="can-i-upgrade-bytekin-without-changing-my-code"><a class="header" href="#can-i-upgrade-bytekin-without-changing-my-code">Can I upgrade bytekin without changing my code?</a></h3>
<p>Yes, bytekin maintains backward compatibility. Always check release notes before upgrading.</p>
<h2 id="license-and-legal-questions"><a class="header" href="#license-and-legal-questions">License and Legal Questions</a></h2>
<h3 id="what-license-is-bytekin-under"><a class="header" href="#what-license-is-bytekin-under">What license is bytekin under?</a></h3>
<p>bytekin is licensed under the <strong>Apache License 2.0</strong>.</p>
<h3 id="can-i-use-bytekin-in-commercial-projects"><a class="header" href="#can-i-use-bytekin-in-commercial-projects">Can I use bytekin in commercial projects?</a></h3>
<p>Yes! Apache 2.0 allows commercial use.</p>
<h3 id="do-i-need-to-open-source-my-code-if-i-use-bytekin"><a class="header" href="#do-i-need-to-open-source-my-code-if-i-use-bytekin">Do I need to open-source my code if I use bytekin?</a></h3>
<p>No, Apache 2.0 does not require you to open-source your code. Just include the license notice.</p>
<h2 id="community-questions"><a class="header" href="#community-questions">Community Questions</a></h2>
<h3 id="how-do-i-report-bugs"><a class="header" href="#how-do-i-report-bugs">How do I report bugs?</a></h3>
<p>Report bugs on the <a href="https://github.com/brqnko/bytekin/issues">GitHub Issues</a> page.</p>
<h3 id="how-can-i-contribute"><a class="header" href="#how-can-i-contribute">How can I contribute?</a></h3>
<p>Contributions are welcome! See the GitHub repository for contribution guidelines.</p>
<h3 id="where-can-i-get-help"><a class="header" href="#where-can-i-get-help">Where can I get help?</a></h3>
<ul>
<li>Check the <a href="./introduction.html">documentation</a></li>
<li>Search <a href="https://github.com/brqnko/bytekin/issues">GitHub Issues</a></li>
<li>Review <a href="./examples.html">Examples</a></li>
</ul>
<h2 id="still-have-questions"><a class="header" href="#still-have-questions">Still Have Questions?</a></h2>
<p>If your question isn't answered here:</p>
<ol>
<li>Check the <a href="./api-reference.html">API Reference</a></li>
<li>Review <a href="./best-practices.html">Best Practices</a></li>
<li>Look at <a href="./examples.html">Examples</a></li>
<li>Open an issue on GitHub</li>
</ol>
<h2 id="next-steps-23"><a class="header" href="#next-steps-23">Next Steps</a></h2>
<ul>
<li>Explore <a href="./examples.html">Examples</a></li>
<li>Review <a href="./best-practices.html">Best Practices</a></li>
<li>Check <a href="./troubleshooting.html">Troubleshooting</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-guide"><a class="header" href="#troubleshooting-guide">Troubleshooting Guide</a></h1>
<p>This guide helps you resolve common issues when using bytekin.</p>
<h2 id="transformation-not-applied"><a class="header" href="#transformation-not-applied">Transformation Not Applied</a></h2>
<h3 id="symptoms"><a class="header" href="#symptoms">Symptoms</a></h3>
<ul>
<li>Hook methods are never called</li>
<li>Original code runs without modifications</li>
<li>Breakpoints in hooks are never hit</li>
</ul>
<h3 id="causes-and-solutions"><a class="header" href="#causes-and-solutions">Causes and Solutions</a></h3>
<h4 id="1-incorrect-class-name"><a class="header" href="#1-incorrect-class-name">1. Incorrect Class Name</a></h4>
<p>The <code>@ModifyClass</code> value must exactly match the bytecode class name.</p>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">@ModifyClass("Calculator")  // Wrong!
public class CalcHooks { }
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-java">@ModifyClass("com.example.Calculator")  // Correct
public class CalcHooks { }
</code></pre>
<p><strong>How to verify:</strong></p>
<pre><code class="language-bash"># List all classes in JAR
jar tf myapp.jar | grep -i calculator
</code></pre>
<h4 id="2-wrong-method-descriptor"><a class="header" href="#2-wrong-method-descriptor">2. Wrong Method Descriptor</a></h4>
<p>The <code>methodDesc</code> must exactly match the method signature in bytecode.</p>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">// Method in bytecode: public int add(int a, int b)
@Inject(methodName = "add", methodDesc = "(int, int)int", at = At.HEAD)  // Wrong!
public static CallbackInfo hook() { }
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-java">@Inject(methodName = "add", methodDesc = "(II)I", at = At.HEAD)  // Correct
public static CallbackInfo hook() { }
</code></pre>
<p><strong>How to find correct descriptor:</strong></p>
<pre><code class="language-bash"># Use javap to see method signatures
javap -c com.example.Calculator | grep -A 5 "public int add"
</code></pre>
<h4 id="3-hook-class-not-passed-to-builder"><a class="header" href="#3-hook-class-not-passed-to-builder">3. Hook Class Not Passed to Builder</a></h4>
<p>The hook class must be passed to the Builder.</p>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder()
    .build();  // Where are the hooks?
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-java">BytekinTransformer transformer = new BytekinTransformer.Builder(MyHooks.class)
    .build();  // Pass hook class
</code></pre>
<h4 id="4-class-not-yet-loaded"><a class="header" href="#4-class-not-yet-loaded">4. Class Not Yet Loaded</a></h4>
<p>Transformations must be applied before the class is loaded by the JVM.</p>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">// Class already loaded
Class&lt;?&gt; clazz = Class.forName("com.example.MyClass");

// Now trying to transform - too late!
byte[] transformed = transformer.transform("com.example.MyClass", bytecode);
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Use a custom <code>ClassLoader</code> that applies transformations during loading</li>
<li>Or use Java instrumentation/agents to intercept class loading</li>
</ul>
<h2 id="type-mismatch-errors"><a class="header" href="#type-mismatch-errors">Type Mismatch Errors</a></h2>
<h3 id="symptoms-1"><a class="header" href="#symptoms-1">Symptoms</a></h3>
<ul>
<li><code>java.lang.ClassCastException</code></li>
<li>Wrong values returned from methods</li>
<li>Type incompatibility errors</li>
</ul>
<h3 id="common-causes"><a class="header" href="#common-causes">Common Causes</a></h3>
<h4 id="1-wrong-return-type-in-callbackinfo"><a class="header" href="#1-wrong-return-type-in-callbackinfo">1. Wrong Return Type in CallbackInfo</a></h4>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">@Inject(methodName = "getCount", methodDesc = "()I", at = At.HEAD)
public static CallbackInfo wrongReturn() {
    CallbackInfo ci = new CallbackInfo();
    ci.cancelled = true;
    ci.returnValue = "42";  // String instead of int!
    return ci;
}
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-java">@Inject(methodName = "getCount", methodDesc = "()I", at = At.HEAD)
public static CallbackInfo correctReturn() {
    CallbackInfo ci = new CallbackInfo();
    ci.cancelled = true;
    ci.returnValue = 42;  // Correct: int
    return ci;
}
</code></pre>
<h4 id="2-wrong-parameter-types-in-hook-method"><a class="header" href="#2-wrong-parameter-types-in-hook-method">2. Wrong Parameter Types in Hook Method</a></h4>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">// Target method: void process(int count, String name)
@Inject(methodName = "process", methodDesc = "(ILjava/lang/String;)V", at = At.HEAD)
public static CallbackInfo wrongParams(String name, int count) {  // Reversed!
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "(ILjava/lang/String;)V", at = At.HEAD)
public static CallbackInfo correctParams(int count, String name) {  // Correct order
    return CallbackInfo.empty();
}
</code></pre>
<h4 id="3-modifying-arguments-to-wrong-type"><a class="header" href="#3-modifying-arguments-to-wrong-type">3. Modifying Arguments to Wrong Type</a></h4>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">@Invoke(..., shift = Shift.BEFORE)
public static CallbackInfo wrongArgType() {
    CallbackInfo ci = new CallbackInfo();
    ci.modifyArgs = new Object[]{"100"};  // String instead of int
    return ci;
}
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-java">@Invoke(..., shift = Shift.BEFORE)
public static CallbackInfo correctArgType() {
    CallbackInfo ci = new CallbackInfo();
    ci.modifyArgs = new Object[]{100};  // Correct: int
    return ci;
}
</code></pre>
<h2 id="null-pointer-exceptions"><a class="header" href="#null-pointer-exceptions">Null Pointer Exceptions</a></h2>
<h3 id="symptoms-2"><a class="header" href="#symptoms-2">Symptoms</a></h3>
<ul>
<li>NPE during transformation</li>
<li>NPE when calling transformed methods</li>
<li>Stack trace originates from bytecode</li>
</ul>
<h3 id="causes-and-solutions-1"><a class="header" href="#causes-and-solutions-1">Causes and Solutions</a></h3>
<h4 id="1-returning-null-from-injection"><a class="header" href="#1-returning-null-from-injection">1. Returning null from Injection</a></h4>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">@Inject(methodName = "getValue", methodDesc = "()Ljava/lang/String;", at = At.HEAD)
public static CallbackInfo returnNull() {
    CallbackInfo ci = new CallbackInfo();
    ci.cancelled = true;
    ci.returnValue = null;  // Valid for objects, but may not be expected
    return ci;
}
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Document that null can be returned</li>
<li>Or return a default value instead:</li>
</ul>
<pre><code class="language-java">ci.returnValue = "";  // Empty string instead of null
</code></pre>
<h4 id="2-accessing-null-parameters-in-hooks"><a class="header" href="#2-accessing-null-parameters-in-hooks">2. Accessing null Parameters in Hooks</a></h4>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
public static CallbackInfo unsafeAccess(String input) {
    System.out.println(input.length());  // NPE if input is null!
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "(Ljava/lang/String;)V", at = At.HEAD)
public static CallbackInfo safeAccess(String input) {
    if (input != null) {
        System.out.println(input.length());
    }
    return CallbackInfo.empty();
}
</code></pre>
<h2 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h2>
<h3 id="symptoms-3"><a class="header" href="#symptoms-3">Symptoms</a></h3>
<ul>
<li>Application startup is slow</li>
<li>Memory usage is high</li>
<li>Response times are degraded</li>
</ul>
<h3 id="causes-and-solutions-2"><a class="header" href="#causes-and-solutions-2">Causes and Solutions</a></h3>
<h4 id="1-complex-hook-methods"><a class="header" href="#1-complex-hook-methods">1. Complex Hook Methods</a></h4>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">@Inject(methodName = "process", methodDesc = "()V", at = At.HEAD)
public static CallbackInfo slowHook() {
    // Database queries
    List&lt;Item&gt; items = database.queryAll();
    // File I/O
    Files.write(Paths.get("log.txt"), data);
    // Expensive computations
    // ...
    return CallbackInfo.empty();
}
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Keep hooks simple and fast</li>
<li>Defer expensive work to background threads</li>
<li>Use lazy initialization for resources</li>
</ul>
<h4 id="2-rebuilding-transformers-repeatedly"><a class="header" href="#2-rebuilding-transformers-repeatedly">2. Rebuilding Transformers Repeatedly</a></h4>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">for (String className : classNames) {
    // Creating new transformer for each class!
    BytekinTransformer transformer = new BytekinTransformer.Builder(Hooks.class)
        .build();
    transformer.transform(className, bytecode);
}
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-java">// Build once, reuse many times
BytekinTransformer transformer = new BytekinTransformer.Builder(Hooks.class)
    .build();

for (String className : classNames) {
    transformer.transform(className, bytecode);
}
</code></pre>
<h4 id="3-transforming-unnecessary-classes"><a class="header" href="#3-transforming-unnecessary-classes">3. Transforming Unnecessary Classes</a></h4>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">// Applying transformation to all classes, even ones that don't need it
for (String className : allClasses) {
    byte[] transformed = transformer.transform(className, bytecode);
}
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Transform only specific classes that need it</li>
<li>Use filtering/naming patterns</li>
<li>Profile to identify hotspots</li>
</ul>
<h2 id="bytecode-verification-errors"><a class="header" href="#bytecode-verification-errors">Bytecode Verification Errors</a></h2>
<h3 id="symptoms-4"><a class="header" href="#symptoms-4">Symptoms</a></h3>
<ul>
<li><code>java.lang.VerifyError</code> when loading class</li>
<li>"Illegal type at offset X" errors</li>
<li>Stack trace is hard to interpret</li>
</ul>
<h3 id="common-causes-1"><a class="header" href="#common-causes-1">Common Causes</a></h3>
<h4 id="1-invalid-bytecode-modifications"><a class="header" href="#1-invalid-bytecode-modifications">1. Invalid Bytecode Modifications</a></h4>
<p>This usually means the transformation created invalid bytecode.</p>
<p><strong>How to Debug:</strong></p>
<ol>
<li>Use <code>javap</code> to inspect the transformed bytecode</li>
<li>Look for unusual instruction sequences</li>
<li>Verify return types match</li>
</ol>
<h4 id="2-incorrect-method-descriptors"><a class="header" href="#2-incorrect-method-descriptors">2. Incorrect Method Descriptors</a></h4>
<p>An incorrect descriptor can cause verification failures.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Double-check all method descriptors</li>
<li>Use online descriptor converters to verify</li>
<li>Compare with <code>javap</code> output</li>
</ul>
<h2 id="methods-not-found"><a class="header" href="#methods-not-found">Methods Not Found</a></h2>
<h3 id="symptoms-5"><a class="header" href="#symptoms-5">Symptoms</a></h3>
<ul>
<li>Specific methods aren't being transformed</li>
<li>Overloaded methods cause issues</li>
<li>Constructor transformations fail</li>
</ul>
<h3 id="causes-and-solutions-3"><a class="header" href="#causes-and-solutions-3">Causes and Solutions</a></h3>
<h4 id="1-overloaded-methods"><a class="header" href="#1-overloaded-methods">1. Overloaded Methods</a></h4>
<p>Overloaded methods must be distinguished by their full descriptor.</p>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">// Class has multiple add() methods
// add(int, int) and add(double, double)

@Inject(methodName = "add", methodDesc = "(II)I", at = At.HEAD)  // Only matches int version
public static CallbackInfo hook() { }
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Use complete descriptor with parameter and return types</li>
<li>The descriptor automatically distinguishes overloads</li>
</ul>
<h4 id="2-private-or-internal-methods"><a class="header" href="#2-private-or-internal-methods">2. Private or Internal Methods</a></h4>
<p>Some private methods might not be accessible.</p>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">@Inject(methodName = "internalMethod", methodDesc = "()V", at = At.HEAD)  // Private method
public static CallbackInfo hook() { }
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Verify the method is not synthetic or bridge method</li>
<li>Check that method name and descriptor are exactly correct</li>
</ul>
<h2 id="cannot-load-transformed-classes"><a class="header" href="#cannot-load-transformed-classes">Cannot Load Transformed Classes</a></h2>
<h3 id="symptoms-6"><a class="header" href="#symptoms-6">Symptoms</a></h3>
<ul>
<li>ClassNotFoundException after transformation</li>
<li>Class appears to be missing</li>
<li>Custom ClassLoader issues</li>
</ul>
<h3 id="causes-and-solutions-4"><a class="header" href="#causes-and-solutions-4">Causes and Solutions</a></h3>
<h4 id="1-incorrect-classloader-setup"><a class="header" href="#1-incorrect-classloader-setup">1. Incorrect ClassLoader Setup</a></h4>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">// Trying to use transformed bytecode with default classloader
byte[] transformed = transformer.transform("com.example.MyClass", bytecode);
Class&lt;?&gt; clazz = Class.forName("com.example.MyClass");  // Won't use transformed bytecode!
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Create custom ClassLoader to use transformed bytecode</li>
<li>Or use instrumentation/agents to intercept loading</li>
</ul>
<h4 id="2-bytecode-corruption"><a class="header" href="#2-bytecode-corruption">2. Bytecode Corruption</a></h4>
<p>The transformation might have produced invalid bytecode.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Verify transformation didn't corrupt bytecode</li>
<li>Check bytecode size/integrity</li>
<li>Use bytecode inspection tools</li>
</ul>
<h2 id="debugging-tips-1"><a class="header" href="#debugging-tips-1">Debugging Tips</a></h2>
<h3 id="1-enable-verbose-output"><a class="header" href="#1-enable-verbose-output">1. Enable Verbose Output</a></h3>
<pre><code class="language-java">// Add debug logging in hooks
@Inject(methodName = "process", methodDesc = "()V", at = At.HEAD)
public static CallbackInfo debug() {
    System.out.println("[DEBUG] Hook executed");
    System.out.println("[DEBUG] Stack: " + Arrays.toString(Thread.currentThread().getStackTrace()));
    return CallbackInfo.empty();
}
</code></pre>
<h3 id="2-inspect-bytecode"><a class="header" href="#2-inspect-bytecode">2. Inspect Bytecode</a></h3>
<pre><code class="language-bash"># View transformed bytecode
javap -c -private TransformedClass.class

# Look for your injected calls
</code></pre>
<h3 id="3-use-a-bytecode-viewer"><a class="header" href="#3-use-a-bytecode-viewer">3. Use a Bytecode Viewer</a></h3>
<p>Tools like Bytecode Viewer or IDEA plugins help visualize bytecode.</p>
<h3 id="4-profile-performance"><a class="header" href="#4-profile-performance">4. Profile Performance</a></h3>
<pre><code class="language-bash"># Use JProfiler or YourKit to identify bottlenecks
# Monitor memory usage and CPU time
</code></pre>
<h2 id="common-questions"><a class="header" href="#common-questions">Common Questions</a></h2>
<p><strong>Q: Can I transform bootstrap classes?</strong>
A: Not easily with standard classloaders. Use Java agents with instrumentation API.</p>
<p><strong>Q: Do transformations affect serialization?</strong>
A: Transformed classes will have different bytecode but same serialization format if you don't change fields.</p>
<p><strong>Q: Can I use bytekin in Spring Boot?</strong>
A: Yes, but you need to configure custom class loading or use agents.</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ol>
<li>Check this troubleshooting guide</li>
<li>Review <a href="./best-practices.html">Best Practices</a></li>
<li>Look at <a href="./examples.html">Examples</a></li>
<li>Open an issue on <a href="https://github.com/brqnko/bytekin/issues">GitHub</a></li>
</ol>
<h2 id="next-steps-24"><a class="header" href="#next-steps-24">Next Steps</a></h2>
<ul>
<li>Review <a href="./best-practices.html">Best Practices</a></li>
<li>Check <a href="./examples.html">Examples</a></li>
<li>Report issues on GitHub</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
