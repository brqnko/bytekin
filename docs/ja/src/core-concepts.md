# コアコンセプト

このセクションでは、bytekinとバイトコード変換の背後にある基本的なコンセプトについて説明します。

## バイトコードとは?

Javaソースコードは**バイトコード**にコンパイルされます - これはJava仮想マシン(JVM)上で実行されるプラットフォーム非依存の中間表現です。ソースコードとは異なり、バイトコードは人間が読める形式ではありませんが、標準化されておりプログラム的に操作できます。

### バイトコードの構造

Javaバイトコードは以下で構成されています:
- **定数プール**: 文字列リテラル、メソッド参照、フィールド参照
- **メソッド**: 命令シーケンスを持つコンパイル済みメソッド
- **フィールド**: クラスプロパティ
- **属性**: 行番号、ローカル変数、例外などのメタデータ

## バイトコード変換とは?

**バイトコード変換**は、コンパイル後でクラスロード前にバイトコードを読み取り、分析し、変更するプロセスです。これにより、ソースコードを変更せずにクラスの動作を変更できます。

### ユースケース

1. **ランタイム監視**: ソースを変更せずにログ記録を追加
2. **横断的関心事**: 複数のクラスに動作を適用
3. **テスト**: メソッドをモックまたはスタブ化
4. **セキュリティ**: セキュリティチェックをインジェクト
5. **パフォーマンス**: プロファイリング計装を追加

## bytekinの位置づけ

bytekinは以下によってバイトコード変換を簡素化します:

1. **ASMの複雑さを抽象化**: 生のASM上にクリーンなAPIを提供
2. **アノテーションベース構成**: Javaアノテーションを使用して変換を定義
3. **複数の戦略**: インジェクション、メソッドインターセプション、リダイレクトのサポート
4. **マッピングサポート**: 難読化または名前変更されたクラスを処理
5. **柔軟なビルダーパターン**: プログラム的に変換を構成

## 変換パイプライン

```
ターゲットクラスバイトコード
        ↓
   BytekinTransformer
        ↓
  フッククラスをスキャン
        ↓
  変換を適用
        ↓
   変更されたバイトコード
```

## 主要コンポーネント

### フッククラス

ターゲットクラスの変換方法を定義する`@ModifyClass`でアノテートされたクラス。変換アノテーションを持つメソッドを含みます。

### トランスフォーマー

バイトコードに変換を適用するオブジェクト。bytekinは変換プロセス全体を処理する`BytekinTransformer`を提供します。

### アノテーション

変換動作を定義するJavaコードの特別なマーカー:
- `@ModifyClass`: ターゲットクラスをマーク
- `@Inject`: 特定の位置にコードを挿入
- `@Invoke`: メソッド呼び出しをインターセプト
- その他...

### CallbackInfo

変換動作を制御するデータ構造:
- `cancelled`: 元のコードをスキップするかどうか
- `returnValue`: カスタム戻り値
- `modifyArgs`: 変更されたメソッド引数

## 重要なコンセプト

### メソッドディスクリプタ

メソッドディスクリプタはJVM形式でメソッドシグネチャを記述します:
```
(パラメータ型)戻り値型
```

例:
- `(II)I` - 2つのintを取り、intを返す
- `(Ljava/lang/String;)V` - Stringを取り、voidを返す
- `()Ljava/lang/String;` - 何も取らず、Stringを返す

### クラス名

bytekinでは、クラス名はドット表記を使用します:
- Java表記: `java.lang.String`
- 内部表記: `java/lang/String`
- bytekinはJava表記を使用

## 次のステップ

- [bytekinの仕組み](./how-it-works.md)について学習
- [すべての機能](./features.md)を探索
